<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 翻译 | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/fan-yi/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-09T21:40:35+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Spree 2.3.0已经发布]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/07/28/spree-2-dot-3-0yi-jing-fa-bu/"/>
    <updated>2014-07-28T21:32:54+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/07/28/spree-2-dot-3-0yi-jing-fa-bu</id>
    <content type="html"><![CDATA[<p><strong>声明：</strong>原文来自Spree官方博客<a href="http://spreecommerce.com/blog/spree-2-3-released">Spree 2.3.0 Released</a>，原文发布日期是2014-06-30，本文仅作翻译。</p>

<p><strong>简要介绍：</strong><a href="http://spreecommerce.com/">Spree</a>是一个基于<a href="http://rubyonrails.org/">Ruby on Rails</a>开发的开源在线商城框架，提供了从商品展示购买、下单支付到库存管理以及订单管理等一系列基本功能，并且支持通过第三方扩展的形式定制或者扩展框架的功能，最新版本的Spree已经支持最新的Rails版本。</p>

<p>Spree 2.3的最新更改已经加入对Rails 4.1的支持，提供了更好的配置项的存储，更好的针对多店铺的支持，以及更好的游客追踪。Spree 2.3的发布，有赖于总的97位贡献者以及他们总的700多个的commit记录。现在，我们非常兴奋地宣布：Spree 2.3发布了！</p>

<!-- More -->


<h3>Rails 4.1 的支持</h3>

<p>现在，Rails 4.1已经得到了Spree 2.3的支持。如果你希望基于Rails 4.1进行开发，那么Spree 2.3就是特为你准备的发布版。</p>

<h3>基于序列化记录的配置项</h3>

<p>现在，所有的配置项存储在一个记录上，而不是存储在<code>spree_preferences</code>表中。这意味着，为了获取一个配置项，比如价格的计算器配置，就会触发一个数据库查询，所查询的那一行记录有一个包含了所有配置信息的命名为<code>preferences</code>的列。</p>

<p>而在此之前，对于每一个配置记录本身，可能都会有一个单独的数据库调用，而在查询到所请求的配置项之后，还是有可能会有任意数目的数据库调用产生。而现在，我们总的只需要调用一次，这意味着程序本身将会有一些速度上的提升。</p>

<h3>更好的多店铺支持</h3>

<p>我们已经添加了一个名为<code>Spree::Store</code>的model，用于支持基本的多店铺/多域名的站点。其在<code>spree-multi-domain</code>这个扩展的基础上提供了针对多店铺/多域名的基本框架。一些原有的配置项被转移到了这个model上，以此实现根据具体的店铺提供不同配置值：</p>

<ul>
<li><code>Spree::Config[:site_name]</code> 迁移到了 <code>name</code></li>
<li><code>Spree::Config[:site_url]</code> 迁移到了 <code>url</code></li>
<li><code>Spree::Config[:default_meta_description]</code> 迁移到了 <code>meta_description</code></li>
<li><code>Spree::Config[:default_meta_keywords]</code> 迁移到了 <code>meta_keywords</code></li>
<li><code>Spree::Config[:default_seo_title]</code> 迁移到了 <code>seo_title</code></li>
</ul>


<p>一个数据库迁移文件将会负责把这些原有的配置项转移到一个新的默认的store实例上。</p>

<p>一个新的名为<code>ControllerHelpers::Store</code>的Concern提供了一个<code>current_store</code>helper，可以在请求的域名的基础上，通过它获取当前店铺。</p>

<h3>更好的游客追踪</h3>

<p>现在，我们用了一个签名的cookie在浏览器中存储游客的唯一的token。通过它允许关闭了浏览器的顾客可以在再次访问时继续完成他们的购物流程。更重要的是，这也帮助作为商店主人的你方便地识别游客的订单。由于我们在访客来访时都会设置<code>cookies.signed[:guest_token]</code>，所以除了订单，或许你可以把cookie用于其他用途。</p>

<p>举个实际例子，如果游客需要收藏一个商品，你可以创建一个用于记录收藏记录的model，然后把<code>cookies.signed[:guest_token]</code>赋值给这个model中的<code>token</code>字段。这将有助于你分析当前用户在此之前的订单以及收藏记录，这对于商品推荐将是非常有用的。</p>

<h3>总结</h3>

<p>你可以从<a href="https://github.com/spree/spree/releases/tag/v2.3.0">Github</a>上浏览更详细的变更列表。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性方法]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa/"/>
    <updated>2014-03-12T20:58:17+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails &ndash; Attribute Methods</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>在我们<a href="/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨</a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似<code>attribute_method_suffix</code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似<code>name</code>这样的模型属性以及对应生成的类似<code>name_changed?</code>这样的方法的。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>声明（Declarations）</h3>

<p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，<code>attribute_method_suffix</code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在<a href="/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论</a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个<code>_changed?</code>方法(<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码)：
```ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
让我们打开ActiveModel库中的`attribute_methods.rb`文件，并且看一下到底发生了什么事情。
</code>ruby
def attribute_method_suffix(*suffixes)
  self.attribute_method_matchers += suffixes.map! do |suffix|</p>

<pre><code>AttributeMethodMatcher.new suffix: suffix
</code></pre>

<p>  end
  #&hellip;
end
```</p>

<p>当你调用<code>attribute_method_suffix</code>方法的时候，每一个后缀都通过<code>map!</code>方法转换为一个<code>AttributeMethodMatcher</code>对象。这些对象会被存储在<code>attribute_method_matchers</code>中。如果你重新看一下这个module的顶部，你会发现<code>attribute_method_matchers</code>是在每一个包含此module的类中使用<code>class_attribute</code>定义的方法：
```ruby
module AttributeMethods
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>class_attribute :attribute_aliases,
                :attribute_method_matchers,
                instance_writer: false
#...
</code></pre>

<p>```</p>

<p><code>class_attribute</code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
```ruby
class Person
  class_attribute :database
  #&hellip;
end</p>

<p>class Employee &lt; Person
end</p>

<p>Person.database = Sql.new(:host=>&lsquo;localhost&rsquo;)
Employee.database #=> &lt;Sql:host=&lsquo;localhost&rsquo;>
```</p>

<p>Ruby中并没有<code>class_attribute</code>的内置实现，它是在ActiveSupport(<strong>提示</strong>:命令行中键入<code>qw activesupport</code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下<code>attribute.rb</code></p>

<p>现在我们来看一下<code>AttributeMethodMatcher</code>。
```ruby
class AttributeMethodMatcher #:nodoc:
  attr_reader :prefix, :suffix, :method_missing_target</p>

<p>  def initialize(options = {})</p>

<pre><code>#...
@prefix, @suffix = options.fetch(:prefix, ''), options.fetch(:suffix, '')
@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
@method_missing_target = "#{@prefix}attribute#{@suffix}"
@method_name = "#{prefix}%s#{suffix}"
</code></pre>

<p>  end
<code>
代码中的`prefix`以及`suffix`是通过`Hash#fetch`方法提取出来的。这会返回一个对应键的值，或者是一个默认值。如果调用方法的时候没有提供默认值，`Hash#fetch`方法将会抛出一个异常，提示指定的键不存在。对于options的处理来说是一种不错的模式，特别是对于boolean型数据来说：
</code>ruby
options = {:name => &ldquo;Mortimer&rdquo;, :imaginary => false}</p>

<h1>Don&rsquo;t do this:</h1>

<p>options[:imaginary] || true     #=> true</p>

<h1>Do this:</h1>

<p>options.fetch(:imaginary, true) #=> false
```</p>

<p>对于我们的<code>attribute_method_suffix</code>其中的<code>'_changed'</code>示例来说，<code>AttributeMethodMatcher</code>将会有如下的实例变量：
<code>ruby
@prefix                #=&gt; ""
@suffix                #=&gt; "_changed?"
@regex                 #=&gt; /^(?:)(.*)(?:_changed\?)$/
@method_missing_target #=&gt; "attribute_changed?"
@method_name           #=&gt; "%s_changed?"
</code></p>

<p>你一定想知道<code>%s_changed</code>中的<code>%s</code>是用来干什么的吧？这是一个格式化字符串（format string）。你可以使用<code>sprintf</code>方法对它插入值，或者使用缩写（shortcut）<code>%</code>：
<code>ruby
sprintf("%s_changed?", "name") #=&gt; "named_changed?"
"%s_changed?" % "age"          #=&gt; "age_changed?"
</code></p>

<p>第二个比较有趣的地方就是正则表达式创建的方式。请留意创建<code>@regex</code>变量时<code>Regexp.escape</code>的用法。如果后缀没有被escape，则正则表达式中带有特殊含义的符号将会被错误解释(misinterpreted)：
```ruby</p>

<h1>Don&rsquo;t do this!</h1>

<p>regex = /^(?:#{@prefix})(.<em>)(?:#{@suffix})$/ #=> /^(?:)(.</em>)(?:_changed?)$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> nil
regex.match(&ldquo;name_change&rdquo;)                   #=> #<MatchData "name_change" 1:"name"></p>

<h1>Do this:</h1>

<p>@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> #<MatchData "name_changed?" 1:"name">
regex.match(&ldquo;name_change&rdquo;)                   #=> nil
```</p>

<p>请仔细记住<code>regex</code>以及<code>method_name</code>，它们可以用来匹配和生成属性方法，我们在后面还会继续用到它们。</p>

<p>我们现在已经搞明白了属性方法是如何声明的，但是实际中，Rails又是如何使用它们的呢？</p>

<h3>通过Method Missing调用（Invocation With Method Missing）</h3>

<p>当我们调用了一个未定义的方法时，Rails将会在抛出异常之前调用对象的<code>method_missing</code>方法。让我们看看Rails是如何利用这个技巧调用属性方法的：
```ruby
def method_missing(method, *args, &amp;block)
  if respond_to_without_attributes?(method, true)</p>

<pre><code>super
</code></pre>

<p>  else</p>

<pre><code>match = match_attribute_method?(method.to_s)
match ? attribute_missing(match, *args, &amp;block) : super
</code></pre>

<p>  end
end
```</p>

<p>传给<code>method_missing</code>方法的第一个参数是一个用symbol类型表示的方法名，比如，我们的<code>:name_changed?</code>。<code>*args</code>是（未定义的）方法被调用时传入的所有参数，<code>&amp;block</code>是一个可选的代码块。Rails首先通过调用<code>respond_to_without_attributes</code>方法检查是否有别的方法可以对应这次调用。如果别的方法可以处理这次调用，则通过<code>super</code>方法转移控制权。如果找不到别的方法可以处理当前的调用，ActiveModel则会通过<code>match_attribute_method?</code>方法检查当前调用的方法是否是一个属性方法。如果是，它则会接着调用<code>attribute_missing</code>方法。</p>

<p><code>match_attribute_method</code>方法利用了之前声明过的<code>AttributeMethodMatcher</code>对象：
<code>ruby
def match_attribute_method?(method_name)
  match = self.class.send(:attribute_method_matcher, method_name)
  match if match &amp;&amp; attribute_method?(match.attr_name)
end
</code></p>

<p>在这个方法里边发生了两件事。第一，Rails查找到了一个匹配器(matcher)，并且检查这是否真的是一个属性。说实话，我自己也是比较迷惑，为什么<code>match_attribute_method?</code>方法调用的是<code>self.class.send(:attribute_method_matcher, method_name)</code>，而不是<code>self.attribute_method_matcher(method_name)</code>，但是我们还是可以假设它们的效果是一样的。</p>

<p>如果我们再接着看<code>attribute_method_matcher</code>，就会发现它的最核心的代码仅仅只是扫描匹配了<code>AttributeMethodMatcher</code>实例，它所做的事就是对比对象本身的正则表达式与当前的方法名：
<code>ruby
def attribute_method_matcher(method_name)
  #...
  attribute_method_matchers.detect { |method| method.match(method_name) }
  #...
end
</code></p>

<p>如果Rails找到了匹配当前调用的方法的属性，那么接下来所有参数都会被传递给<code>attribute_missing</code>方法：
<code>ruby
def attribute_missing(match, *args, &amp;block)
  __send__(match.target, match.attr_name, *args, &amp;block)
end
</code></p>

<p>这个方法将匹配到的属性名以及传入的任意参数或者代码块代理给了<code>match.target</code>。回头看下我们的实例变量，<code>match.target</code>将会是<code>attribute_changed?</code>，而且<code>match.attr_name</code>则是"name"。<code>__send__</code>方法将会调用<code>attribute_changed?</code>方法，或者是你定义的任意一个特殊的属性方法。</p>

<h3>元编程（Metaprogramming）</h3>

<p>有很多的方式可以对一个方法的调用进行分发（dispatch），如果这个方法经常被调用，那么实现一个<code>name_changed?</code>方法将会更为有效。Rails通过<code>define_attribute_methods</code>方法做到了对这类属性方法的自动定义：
```ruby
def define_attribute_methods(*attr_names)
  attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
end</p>

<p>def define_attribute_method(attr_name)
  attribute_method_matchers.each do |matcher|</p>

<pre><code>method_name = matcher.method_name(attr_name)

define_proxy_call true,
                  generated_attribute_methods,
                  method_name,
                  matcher.method_missing_target,
                  attr_name.to_s
</code></pre>

<p>  end
end
```</p>

<p><code>matcher.method_name</code>使用了我们前面见到过的格式化字符串，并且插入了<code>attr_name</code>。在我们的例子中，<code>"%s_changed?"</code>变成了<code>"name_changed?"</code>。现在我们我们准备好了了解在<code>define_proxy_call</code>中的元编程。下面是这个方法被删掉了一些特殊场景下的代码的版本，你可以在阅读完这篇文章后自己去了解更多的代码。
```ruby
def define_proxy_call(include_private, mod, name, send, <em>extra)
  defn = &ldquo;def #{name}(</em>args)&rdquo;
  extra = (extra.map!(&amp;:inspect) &lt;&lt; &ldquo;*args&rdquo;).join(&ldquo;, &rdquo;)
  target = &ldquo;#{send}(#{extra})&rdquo;</p>

<p>  mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1</p>

<pre><code>#{defn}
  #{target}
end
</code></pre>

<p>  RUBY
end
```</p>

<p>这里为我们定义了一个新的方法。<code>name</code>就是正要被定义的方法名，而<code>send</code>则是处理器(handler)，另外的<code>extra</code>是属性名。<code>mod</code>参数是一个Rails用<code>generated_attribute_methods</code>方法生成的特殊的模块（module），它被嵌入（mixin）到我们的类中。现在让我们多看一下<code>module_eval</code>方法。这里有三件有趣的事情发生了。</p>

<p>第一件事就是<a href="http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html">HEREDOC</a>被用作一个参数传给了一个方法。这是有点难懂的，但是对某些场景却是非常有用的。举个例子，想象我们在一个服务器响应(response)中有一个方法要用来嵌入Javascript代码：
<code>ruby
include_js(&lt;&lt;-JS, :minify =&gt; true)
  $('#logo').show();
  App.refresh();
JS
</code></p>

<p>这将会把字符串<code>"$('#logo').show(); App.refresh();"</code>作为调用<code>include_js</code>时传入的第一个参数，而<code>:minify =&gt; true</code>作为第二个参数。在Ruby中需要生成代码时，这是一个非常有用的技巧。值得高兴的是，诸如<a href="https://github.com/textmate/textmate">TextMate</a>这类编辑器都能够识别这个模式，并且正确地高亮显示字符串。即使你并不需要生成代码，HEREDOC对于多行的字符串也是比较有用的。</p>

<p>现在我们就知道了<code>&lt;&lt;-RUBY</code>做了些什么事，但是<code>__FILE__</code>以及<code>__LINE__ + 1</code>呢？<code>__FILE__</code>返回了当前文件的（相对）路径，而<code>__LINE__</code>返回了当前代码的行号。<code>module_eval</code>接收这些参数，并通过这些参数决定新的代码定义在文件中“看起来”的位置。在对于栈跟踪（stack traces）来说是特别有用的。</p>

<p>最后，让我们看一些<code>module_eval</code>中实际执行的代码。我们可以把值替换成我们的<code>name_changed?</code>：
```ruby
mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1
  def name_changed?(*args)</p>

<pre><code>attribute_changed?("name", *args)
</code></pre>

<p>  end
RUBY
<code>``
现在</code>name_changed?<code>就是一个真实的方法了，比起依赖于</code>method_missing`方法的实现，这种方法的开销要小得多。</p>

<h3>总结（Recap）</h3>

<p>我们发现了调用<code>attribute_method_suffix</code>方法会保存一个配置好的对象，这个对象用于Rails中两种元编程方法中的一种。不考虑是否使用了<code>method_missing</code>，或者通过<code>module_eval</code>定义了新的方法，方法的调用最后总会被传递到诸如<code>attribute_changed?(attr)</code>这样的方法上。</p>

<p>走过这次比较宽泛的旅途，我们也收获了一些有用的技巧：</p>

<ul>
<li>你必须使用<code>Hash#fetch</code>从options中读取参数，特别是对于boolean类型参数来说。</li>
<li>诸如<code>"%s_changed"</code>这样的格式化字符串，可以被用于简单的模板。</li>
<li>可以使用<code>Regexp.escape</code>escape正则表达式。</li>
<li>当你试图调用一个未定义的方法时，Ruby会调用<code>method_missing</code>方法。</li>
<li>HEREDOCs可以用在方法参数中，也可以用来定义多行的字符串。</li>
<li><code>__FILE__</code>以及<code>__LINE__</code>指向当前的文件以及行号。</li>
<li>你可以使用<code>module_eval</code>动态生成代码。</li>
</ul>


<p>坚持浏览Rails的源代码吧，你总会发现你原本不知道的宝藏！</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>《解读Rails》中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跟踪model中属性（值）的变更]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng/"/>
    <updated>2014-03-07T13:02:47+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_change_tracking/">Reading Rails &ndash; Change Tracking</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天来看看Rails是如何追踪model里边属性的变更的。
<code>ruby
person = Person.find(8)
person.name = "Mortimer"
person.name_changed?    #=&gt; true
person.name_was         #=&gt; "Horton"
person.changes          #=&gt; {"name"=&gt;["Horton","Mortimer"]}
person.save!
person.changes          #=&gt; {}
</code>
<code>name_changed?</code>方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>ActiveModel</h3>

<p>当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码）定义了没有与数据库捆绑的逻辑。我们将从<code>dirty.rb</code>文件开始。在这个模块最开始的地方，代码调用了<code>attribute_method_suffix</code>：
``` ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
`attribute_method_suffix`定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似`_changed?`后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到`def attribute_changed?`：
</code> ruby
def attribute_changed?(attr)
  changed_attributes.include?(attr)
end
<code>
我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似`name_changed?`的方法时，Rails将会把`"name"`作为参数`attr`传给上述方法。往回看一点点，你会发现`changed_attributes`只是一个包含了从属性名到旧的属性值的映射的`Hash`而已：
</code> ruby</p>

<h1>Returns a hash of the attributes with unsaved changes indicating their original</h1>

<h1>values like <tt>attr => original value</tt>.</h1>

<p>#</p>

<h1>person.name # => &ldquo;bob&rdquo;</h1>

<h1>person.name = &lsquo;robert&rsquo;</h1>

<h1>person.changed_attributes # => {&ldquo;name&rdquo; => &ldquo;bob&rdquo;}</h1>

<p>def changed_attributes
  @changed_attributes ||= {}
end
<code>``
在Ruby中，如果你之前都没有见过</code>||=<code>操作，那么你可能需要了解这其实是一个用于初始化变量值的技巧。当它第一次被访问的时候，变量的值是</code>nil<code>，所以它返回了一个空的</code>Hash<code>并且用其初始化</code>@changed_attributes<code>。当它再一次被访问的时候，</code>@changed_attributes<code>已经被赋值过了。那么现在我们可以回答我们的第一个问题了，</code>name_changed?<code>方法被转发到</code>attribute_changed?<code>方法，而后者会在</code>changed_attributes`中查找特定的值。</p>

<p>在我们的例子中，我们看到<code>changes</code>返回一个类似<code>{"name"=&gt;["Horton","Mortimer"]}</code>这样既包含旧的属性值，又包含新的属性值的<code>Hash</code>。让我们这又是如何做到的：
<code>ruby
def changes
  ActiveSupport::HashWithIndifferentAccess[changed.map { |attr| [attr, attribute_change(attr)] }]
end
</code>
这段代码看起来有点难以理解，但是我们可以一步一步分析。首先我们从<code>ActiveSupport::HashWithIndifferentAccess</code>开始，这是在ActiveSupport中所定义的<code>Hash</code>的子类，通过字符串类型或者符号类型的键去访问它将得到一样的结果：
<code>ruby
hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:name] = "Mortimer"
hash["name"] #=&gt; "Mortimer"
</code>
接下来就有点奇怪了，Rails调用了<code>Hash[]</code>方法。这是一个鲜为人知的从包含键/值对的数组中初始化一个哈希表的方法。
<code>ruby
Hash[
  [:name, "Mortimer"],
  [:species, "Crow"]
] #=&gt; {[:name, "Mortimer"]=&gt;[:species, "Crow"]}
</code>
可以查看<code>Hash Tricks</code>找到更多类似的方法。<code>changes</code>中剩余部分的代码就比较清晰了。属性名被映射到类似<code>[attr, attribute_change(attr)]</code>的数组。其中第一个元素，也就是<code>attr</code>编程了一个键，而对应的值则是<code>attribute_change(attr)</code>返回的结果。
<code>ruby
def attribute_change(attr)
  [changed_attributes[attr], __send__(attr)] if attribute_changed?(attr)
end
</code>
这是另一个被分发的属性方法，但是在这个例子里，它返回了一个包含了两个元素的数组，第一个元素是从<code>changed_attributes</code>哈希表中读到的<code>attr</code>所对应的旧的值，第二个则是所对应的新的值。Rails通过使用<code>__send__</code>方法调用了名为<code>attr</code>的方法，进而得到新的属性值。然后这对值会被返回，并且用作<code>changes</code>哈希表中<code>attr</code>所对应的值。</p>

<h3>ActiveRecord</h3>

<p>现在让我们来找出Rails是如何记录更改的。ActiveRecord实现了读写ActiveModel所跟踪的属性的代码。跟ActiveModel一样，ActiveRecord也有一个<code>dirty.rb</code>文件，我们将要对这个文件进行挖掘。通过在定义了<code>changed_attributes</code>的文件中（<strong>提示</strong>：命令行中键入<code>qw activerecord</code>）找到的相关代码，我们可以看到这个文件包装了ActiveRecord的<code>write_attribute</code>与逻辑以实现对变更的跟踪。
``` ruby</p>

<h1>Wrap write_attribute to remember original attribute value.</h1>

<p>def write_attribute(attr, value)
  attr = attr.to_s</p>

<p>  # The attribute already has an unsaved change.
  if attribute_changed?(attr)</p>

<pre><code>old = @changed_attributes[attr]
@changed_attributes.delete(attr) unless _field_changed?(attr, old, value)
</code></pre>

<p>  else</p>

<pre><code>old = clone_attribute_value(:read_attribute, attr)
@changed_attributes[attr] = old if _field_changed?(attr, old, value)
</code></pre>

<p>  end</p>

<p>  # Carry on.
  super(attr, value)
end
<code>
让我们暂时偏离一下主题，并且看一下方法的包装。这是在Rails的代码里边非常常见的模式。当你调用`super`的时候，Ruby查找当前对象的所有祖先，包括相关的模块。由于一个类可以引进多个模块，所以你可以多层地包装方法。这里是一个简单的例子：
</code> ruby
module Shouting
  def say(message)</p>

<pre><code>message.upcase
</code></pre>

<p>  end
end</p>

<p>class Speaker
  include Shouting</p>

<p>  def say(message)</p>

<pre><code>puts super(message)
</code></pre>

<p>  end
end</p>

<p>Speaker.new.say(&ldquo;Hi!&rdquo;) #=> &ldquo;HI!&rdquo;
<code>``
请注意</code>Shouting<code>是</code>Speaker<code>所包含的模块，而不是后者所扩展的类。Rails使用这种技巧去包装方法，以此确保在不同的文件里有独立的关注点（Concern）。这也意味着为了了解整个系统，你可能需要从多个文件里边找到相关的代码。假如你看到了一个对</code>super`的调用，这是一个可以告诉你在别的地方还有更多代码需要了解的好线索。假如你想学习更多的这方面的知识，James Coglan有一个非常详细的文章讲解了Ruby的<a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/">方法分发</a>。</p>

<p>回到<code>write_attribute</code>方法。根据属性（值）是否已经改变，会有两个可能的场景。第一个分支检查你是否正在将一个属性（值）还原到原来的值，如果是这样，它将会从记录了已改变属性的哈希表中删除属性。第二个分支仅仅在新的值与旧的值不同的时候记录下更改。一旦更改被记录下来，实际的用于更新属性的逻辑通过调用<code>super</code>方法完成。</p>

<h3>总结</h3>

<p>Rails为你的model提供了变更的跟踪。这个功能是在ActiveModel中实现的，但是真正的监测更改的逻辑则是在ActiveRecord中实现的。</p>

<p>通过了解这个功能，我们也发掘到了一些有趣的小贴士：</p>

<ul>
<li>ActiveModel定义了<code>attribute_method_suffix</code>方法用于分发类似<code>name_changed?</code>的方法。</li>
<li><code>||=</code>操作符是一个可以用来初始化变量的方便的方法。</li>
<li>在<code>HashWithIndifferentAccess</code>中，字符串类型以及符号类型的键是一样的。</li>
<li><code>Hash</code>可以通过<code>Hash[key_value_pairs]</code>方法初始化。</li>
<li>你可以使用模块拦截方法并为方法加上另一层的功能。</li>
</ul>


<p>假如你有关于你想阅读的关于Rails中其他部分的建议，请让我知道。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读Rails - 处理异常]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/"/>
    <updated>2014-03-05T13:53:09+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_handling_exceptions/">Reading Rails &ndash; Handling Exceptions</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。</p>

<!-- More -->


<p>Rails通过让你使用<code>rescue_from</code>方法，让你在你的<code>controller</code>里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。
``` ruby
class ApplicationController
  # Redirect users if they try to use disabled features.
  rescue_from FeatureDisabledError, InsufficientAccessError do |ex|</p>

<pre><code>flash[:alert] = "Your account does not support #{ex.feature_name}"
redirect_to "/pricing"
</code></pre>

<p>  end
  #&hellip;
```
我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。</p>

<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>定义处理器(Handlers)</h3>

<p>ActiveSupport包含了一个用于定义异常如何被处理的模块<code>Rescuable</code>。第一个需要了解的方法就是<code>rescue_from</code>。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（<strong>提示</strong>：查看代码，请在命令行中输入<code>qw activesupport</code>）：
``` ruby
def rescue_from(*klasses, &amp;block)
  options = klasses.extract_options!</p>

<p>  unless options.has_key?(:with)</p>

<pre><code>if block_given?
  options[:with] = block
else
  #...
</code></pre>

<p><code>``
首先，</code>*klasses<code>接收数量不定的异常类，所以你可以进行类似</code>rescue_from(FeatureDisabledError, InsufficientAccessError)`这样的调用。它们将会被存放在一个数组里。</p>

<p>接下来，请留意<code>extract_options!</code>的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用<code>:with</code>项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。</p>

<p>接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。
``` ruby
def rescue_from(*klasses, &amp;block)
  #&hellip;</p>

<pre><code>key = if klass.is_a?(Class) &amp;&amp; klass &lt;= Exception
  klass.name
elsif klass.is_a?(String)
  klass
else
</code></pre>

<p>  #&hellip;
<code>``
这里你应该注意的是，Rails是如何判定</code>klass<code>是不是继承自</code>Exception<code>的。通常情况下，你可能会通过使用</code>obj.is_a?(Exception)<code>来判断一个对象是不是某一个具体类型的实例，即使如此，</code>klass<code>并不是</code>Exception<code>，而只是</code>Class<code>。那么我们又怎么找出它使哪一类呢？Ruby在</code>Module<code>上定义了类似</code>&lt;=<code>这样的[用于比较的操作符](http://ruby-doc.org/core-1.9.3/Module.html#method-i-3C)。当操作符左边的对象是操作符右边对象的子类的时候，它会返回true。举个例子，</code>ActiveRecord::RecordNotFound &lt; Exception<code>返回true，而</code>ActiveRecord::RecordNotFound > Exception`返回false。</p>

<p>在这个方法的末尾，我们看到表示异常类的<code>String</code>对象稍后被储存在二元数组中：
<code>ruby
def rescue_from(*klasses, &amp;block)
  #...
  self.rescue_handlers += [[key, options[:with]]]
end
</code>
现在我们已经知道了处理器是如何储存的，但是当Rails需要处理异常的时候，它又是如何查找这些处理器的呢？</p>

<h3>查找处理器（Finding Handlers）</h3>

<p>经过对<code>rescue_handlers</code>的快速搜索发现，这一切使用到了<code>handler_for_rescue</code>。我们可以看到每一个可能的处理器都被一一检查，直到我们找到能够与<code>exception</code>匹配的处理器：
``` ruby
def handler_for_rescue(exception)
  # 我们遵循从右到左的顺序，是因为每当发现一个rescue_from声明的时候，
  # 相应的klass_name, handler对就会被压入resuce_handlers里。
  _, rescuer = self.class.rescue_handlers.reverse.detect do |klass_name, handler|</p>

<pre><code>#...
klass = self.class.const_get(klass_name) rescue nil
klass ||= klass_name.constantize rescue nil
exception.is_a?(klass) if klass
</code></pre>

<p>  end
  #&hellip;
<code>``
如同注释所言，</code>rescue_handlers<code>被反序读取。假如有两个处理器能够处理同一个异常，那么最后定义的处理器会被优先选中。假如你先定义了一个针对</code>ActiveRecord::NotFoundError<code>异常的处理器，接着又定义了针对</code>Exception<code>异常的处理器，那么前者将永远都不会被调用，因为针对</code>Exception`的处理器总是会优先匹配。</p>

<p>现在，在代码块里边，又发生了什么呢？</p>

<p>首先，字符串对象<code>klass_name</code>被当做当前类内部的常量进行查找，在找不到的情况下会继续判断它是不是定义在程序内部其他地方的常量，以此将<code>klass_name</code>转换为实际的类。每一步都通过返回<code>nil</code>进行rescue。这么做的一个原因就是当前处理器可能是针对某个尚未加载的异常的类型。举例来说，一个插件里可能为<code>ActiveRecord::NotFoundError</code>定义了错误处理，但是你可能并没有使用<code>ActiveRecord</code>。在这样的情况下，引用这个异常将会导致异常。每一行最后的<code>rescue nil</code>能够在无法找到类时无声无息地组织异常的抛出。</p>

<p>最后我们检查这个异常（等待匹配的异常）是否是这个处理器所对应异常类的实例。如果是，数组<code>[klass_name, handler]</code>将会被返回。返回到上边看看<code>_, rescuer = ...</code>这一行代码，这一一个数组拆分的例子。因为我们实际上只想要返回数组的第二个元素，也就是处理器，所以<code>_</code>在这里只是一个占位符。</p>

<h3>处理异常（Rescuing Exceptions)</h3>

<p>现在我们知道了程序是如何查找异常处理器的，但是它又是如何被调用的呢？为了回答这最后一个问题，我们可以返回到源代码文件的顶部然后探索一下<code>rescue_with_handler</code>方法。当给它传递一个异常的时候，它将会尝试通过调用合适的处理器来处理这个异常。
``` ruby
def rescue_with_handler(exception)
  if handler = handler_for_rescue(exception)</p>

<pre><code>handler.arity != 0 ? handler.call(exception) : handler.call
</code></pre>

<p>  end
end
<code>
为了了解这个方法是如何在你的controller里边生效的，我们需要查看ActionPack包里边的代码。（**提示**：可以在命令行中键入`qw actionpack`打开ActionPace的代码）Rails定义了一个叫做`ActionController::Rescue`的中间件，它被混入到了`Rescuable`模块里边，并且通过`precess_action`调用。
</code> ruby
def process_action(*args)
  super
rescue Exception => exception
  rescue_with_handler(exception) || raise(exception)
end
<code>``
Rails在收到每一个请求时都会调用</code>process_action<code>，假如请求导致一个异常即将被抛出，</code>rescue_with_handler`都会试图去处理这个异常。</p>

<h3>在Rails之外使用Rescuable（Using Rescuable Outside of Rails）</h3>

<p><code>Rescuable</code>能够被混入到其它代码之中。假如你想集中化你的异常处理部分的逻辑，那么你可以考虑一下使用<code>Rescuable</code>。举个例子，假如你有很多发向远程服务的请求，并且你不想在每一个方法里边重复异常处理的逻辑：
``` ruby
class RemoteService
  include Rescuable</p>

<p>  rescue_from Net::HTTPNotFound, Net::HTTPNotAcceptable do |ex|</p>

<pre><code>disable_service!
log_http_failure(@endpoint, ex)
</code></pre>

<p>  end</p>

<p>  rescue_from Net::HTTPNetworkAuthenticationRequired do |ex|</p>

<pre><code>authorize!
</code></pre>

<p>  end</p>

<p>  def get_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>  def update_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>end
```
使用一点元编程的技巧，你甚至可以通过类似的模式对已有的方法进行封装以避免rescue代码块。</p>

<h3>总结（Recap）</h3>

<p>ActiveSupport的<code>Rescuable</code>模块允许我们定义异常处理方法。ActionController的<code>Rescue</code>中间件捕捉异常，并试图处理这些异常。
我们也同时了解到：</p>

<ul>
<li>一个签名类似<code>rescue_from(*klasses)</code>的方法可以接收数量不定的参数。</li>
<li><code>Array#extract_options!</code>方法是一个用于从arguments数组得到options的技巧。</li>
<li>你可以通过类似<code>klass &lt;= Exception</code>这样的代码判读一个类是否某个类的子类。</li>
<li><code>rescue nil</code>将会静默地消除异常。</li>
</ul>


<p>就算是再小的代码片段都包含了非常多有用的信息，请让我知道你下一步想要了解什么东西，我们还会看到能够从Rails里边挖掘到的新奇玩意。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读Rails - 适配器模式]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/"/>
    <updated>2014-03-03T13:40:03+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;utm_medium=email">Reading Rails &ndash; The Adapter Pattern</a>，限于本人水平有限，翻译不当之处，敬请指教！</p>

<p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是<a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）</a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。</p>

<!-- MORE -->


<p>为了跟随本文的步骤，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开相关的代码库，或者直接在<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github</a>上查看这些代码。</p>

<h3>适配器模式</h3>

<p><a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式</a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。</p>

<p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：
<code>ruby
def find_nearest_restaurant(locator)
  locator.nearest(:restaurant, self.lat, self.lon)
end
</code>
我们假设有一个针对<code>locator</code>的接口，但是如果我们想要<code>find_nearest_restaurant</code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：
``` ruby
def find_nearest_restaurant(locator)
  if locator.is_a? GeoFish</p>

<pre><code>locator.nearest(:restaurant, self.lat, self.lon)
</code></pre>

<p>  elsif locator.is_a? ActsAsFound</p>

<pre><code>locator.find_food(:lat =&gt; self.lat, :lon =&gt; self.lon)
</code></pre>

<p>  else</p>

<pre><code>raise NotImplementedError, "#{locator.class.name} is not supported."
</code></pre>

<p>  end
end
<code>``
这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许</code>find_nearest_restaurant<code>就是我们使用</code>locator`的唯一场景。</p>

<p>那假如你真的需要去支持一个新的<code>locator</code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现<code>find_nearest_hospital</code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。</p>

<p>在这个例子中，我们可以为<code>GeoFish</code>以及<code>ActsAsFound</code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：
``` ruby
def find_nearest_hospital(locator)
  locator.find :type => :hospital,</p>

<pre><code>           :lat =&gt; self.lat,
           :lon =&gt; self.lon
</code></pre>

<p>end</p>

<p>locator = GeoFishAdapter.new(geo_fish_locator)
find_nearest_hospital(locator)
```
特意假设的例子就到此为止，接下来让我们看看真实的代码。</p>

<h3>MultiJSON</h3>

<p><code>ActiveSupport</code>在做JSON格式的解码时，用到的是<code>MultiJSON</code>，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对<a href="https://github.com/ohler55/oj">oj</a>和<a href="https://github.com/brianmario/yajl-ruby">yajl</a>的适配器。
(<strong>提示</strong>: 可在命令行中输入<code>qw multi_json</code>查看源码。)
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Oj &lt; Adapter
  #...
  def load(string, options={})
    options[:symbol_keys] = options.delete(:symbolize_keys)
    ::Oj.load(string, options)
  end
  #...
</code></pre>

<p><code>
Oj的适配器修改了`options`哈希表，使用`Hash#delete`将`:symbolize_keys`项转换为Oj的`:symbol_keys`项：
</code> ruby
options = {:symbolize_keys => true}
options[:symbol_keys] = options.delete(:symbolize_keys) # => true
options                                                 # => {:symbol_keys=>true}
<code>``
接下来MultiJSON调用了</code>::Oj.load(string, options)<code>。MultiJSON适配后的API跟Oj原有的API非常相似，在此不必赘述。不过你是否注意到，Oj是如何引用的呢？</code>::Oj<code>引用了顶层的</code>Oj<code>类，而不是</code>MultiJson::Adapters::Oj`。</p>

<p>现在让我们看看MultiJSON又是如何适配Yajl库的：
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Yajl &lt; Adapter
  #...
  def load(string, options={})
    ::Yajl::Parser.new(:symbolize_keys =&gt; options[:symbolize_keys]).parse(string)
  end
  #...
</code></pre>

<p><code>``
这个适配器从不同的方式实现了</code>load<code>方法。Yajl的方式是先创建一个解析器的实力，然后将传入的字符串</code>string<code>作为参数调用</code>Yajl::Parser#parse<code>方法。在</code>options<code>哈希表上的处理也略有不同。只有</code>:symbolize_keys`项被传递给了Yajl。</p>

<p>这些JSON的适配器看似微不足道，但是他们却可以让你随心所欲地在不同的库之间进行切换，而不需要在每一个解析JSON的地方更新代码。</p>

<h3>ActiveRecord</h3>

<p>很多JSON库往往都遵从相似的模式，这让适配工作变得相当轻松。但是如果你是在处理一些更加复杂的情况时，结果会是怎样？ActiveRecord包含了针对不同数据库的适配器。尽管PostgreSQL和MySQL都是SQL数据库，但是他们之间还是有很多不同之处，而ActiveRecord通过使用适配器模式屏蔽了这些不同。(<strong>提示</strong>: 命令行中输入<code>qw activerecord</code>查看ActiveRecord的代码)</p>

<p>打开ActiveRecord代码库中的<code>lib/connection_adapters</code>目录，里边会有针对PostgreSQL,MySQL以及SQLite的适配器。除此之外，还有一个名为<code>AbstractAdapter</code>的适配器，它作为每一个具体的适配器的基类。<code>AbstractAdapter</code>实现了在大部分数据库中常见的功能，这些功能在其子类比如<code>PostgreSQLAdapter</code>以及<code>AbstractMysqlAdapter</code>中被重新定制，而其中<code>AbstractMysqlAdapter</code>则是另外两个不同的MySQL适配器——MysqlAdapter以及Mysql2Adapter——的父类。让我们通过一些真实世界中的例子来看看他们是如何一起工作的。</p>

<p>PostgreSQL和MySQL在SQL方言的实现稍有不同。查询语句<code>SELECT * FROM users</code>在这两个数据库都可以正常执行，但是它们在一些类型的处理上会稍显不同。在MySQL和PostgreSQL中，时间格式就不尽相同。其中，PostgreSQL支持微秒级别的时间，而MySQL只是到了最近的一个稳定发布的版本中才支持。那这两个适配器又是如何处理这种差异的呢？</p>

<p>ActiveRecord通过被混入到<code>AbstractAdapter</code>的<code>ActiveRecord::ConnectionAdapters::Quoting</code>中的<code>quoted_date</code>引用日期。而<code>AbstractAdapter</code>中的实现仅仅只是格式化了日期：
<code>ruby
def quoted_date(value)
  #...
  value.to_s(:db)
end
</code>
Rails中的ActiveSupport扩展了<code>Time#to_s</code>，使其能够接收一个代表格式名的符号类型参数。<code>:db</code>所代表的格式就是<code>%Y-%m-%d %H:%M:%S</code>：
``` ruby</p>

<h1>Examples of common formats:</h1>

<p>Time.now.to_s(:db)      #=> &ldquo;2014-02-19 06:08:13&rdquo;
Time.now.to_s(:short)   #=> &ldquo;19 Feb 06:08&rdquo;
Time.now.to_s(:rfc822)  #=> &ldquo;Wed, 19 Feb 2014 06:08:13 +0000&rdquo;
<code>
MySQL的适配器都没有重写`quoted_date`方法，它们自然会继承这种行为。另一边，`PostgreSQLAdapter`则对日期的处理做了两个修改：
</code> ruby
def quoted_date(value)
  result = super
  if value.acts_like?(:time) &amp;&amp; value.respond_to?(:usec)</p>

<pre><code>result = "#{result}.#{sprintf("%06d", value.usec)}"
</code></pre>

<p>  end</p>

<p>  if value.year &lt; 0</p>

<pre><code>result = result.sub(/^-/, "") + " BC"
</code></pre>

<p>  end
  result
end
<code>``
它在一开始便调用</code>super<code>方法，所以它也会得到一个类似MySQL中格式化后的日期。接下来，它检测</code>value<code>是否像是一个具体时间。这是一个ActiveSupport中扩展的方法，当一个对象类似</code>Time<code>类型的实例时，它会返回</code>true<code>。这让它更容易表明各种对象已被假设为类似</code>Time<code>的对象。（**提示**: 对</code>acts_like?<code>方法感兴趣？请在命令行中执行</code>qw activesupport<code>，然后阅读</code>core_ext/object/acts_like.rb`）</p>

<p>第二部分的条件检查<code>value</code>是否有用于返回毫秒的<code>usec</code>方法。如果可以求得毫秒数，那么它将通过<code>sprintf</code>方法被追加到<code>result</code>字符串的末尾。跟很多时间格式一样，<code>sprintf</code>也有很多不同的方式用于格式化数字：
<code>ruby
sprintf("%06d", 32) #=&gt; "000032"
sprintf("%6d",  32) #=&gt; "    32"
sprintf("%d",   32) #=&gt; "32"
sprintf("%.2f", 32) #=&gt; "32.00"
</code>
最后，假如日期是一个负数，<code>PostgreSQLAdapter</code>就会通过加上"BC"去重新格式化日期，这是PostgreSQL数据库的实际要求：
<code>ruby
SELECT '2000-01-20'::timestamp;
-- 2000-01-20 00:00:00
SELECT '2000-01-20 BC'::timestamp;
-- 2000-01-20 00:00:00 BC
SELECT '-2000-01-20'::timestamp;
-- ERROR:  time zone displacement out of range: "-2000-01-20"
</code>
这只是ActiveRecord适配多个API时的一个极小的方式，但它却能帮助你免除由于不同数据库的细节所带来的差异和烦恼。</p>

<p>另一个体现SQL数据库的不同点是数据库表被创建的方式。MySQL以及PostgreSQL中对主键的处理各不相同：
``` ruby</p>

<h1>AbstractMysqlAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  :primary_key => &ldquo;int(11) DEFAULT NULL auto_increment PRIMARY KEY&rdquo;,
  #&hellip;
}</p>

<h1>PostgreSQLAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  primary_key: &ldquo;serial primary key&rdquo;,
  #&hellip;
}
```
这两种适配器都能够明白ActiveRecord中的主键的表示方式，但是它们会在创建新表的时候将此翻译为不同的SQL语句。当你下次在编写一个migration或者执行一个查询的时候，思考一下ActiveRecord的适配器以及它们为你做的所有微小的事情。</p>

<h3>DateTime和Time</h3>

<p>当MultiJson以及ActiveRecord实现了传统的适配器的时候，Ruby的灵活性使得另一种解决方案成为可能。<code>DateTime</code>以及<code>Time</code>都用于表示时间，但是它们在内部的处理上是不同的。虽然有着这些细微的差异，但是它们所暴露出来的API却是极其类似的（<strong>提示</strong>：命令行中执行<code>qw activesupport</code>查看此处相关代码）：
``` ruby
t = Time.now
t.day     #=> 19         (Day of month)
t.wday    #=> 3          (Day of week)
t.usec    #=> 371552     (Microseconds)
t.to_i    #=> 1392871392 (Epoch secconds)</p>

<p>d = DateTime.now
d.day     #=> 19         (Day of month)
d.wday    #=> 3          (Day of week)
d.usec    #=> NoMethodError: undefined method <code>usec'
d.to_i    #=&gt; NoMethodError: undefined method</code>to_i'
<code>
ActiveSupport通过添加缺失的方法来直接修改`DateTime`和`Time`，进而抹平了两者之间的差异。从实例上看，这里就有一个例子演示了ActiveSupport如何定义`DateTime#to_i`：
</code> ruby
class DateTime
  def to_i</p>

<pre><code>seconds_since_unix_epoch.to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_unix_epoch</p>

<pre><code>(jd - 2440588) * 86400 - offset_in_seconds + seconds_since_midnight
</code></pre>

<p>  end</p>

<p>  def offset_in_seconds</p>

<pre><code>(offset * 86400).to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_midnight</p>

<pre><code>sec + (min * 60) + (hour * 3600)
</code></pre>

<p>  end
end
<code>``
每一个用于支持的方法，</code>seconds_since_unix_epoch<code>，</code>offset_in_seconds<code>，以及</code>seconds_since_midnight<code>都使用或者扩展了</code>DateTime<code>中已经存在的API去定义与</code>Time`中匹配的方法。</p>

<p>假如说我们前面所看到的适配器是相对于被适配对象的外部适配器，那么我们现在所看到的这个就可以被称之为内部适配器。与外部适配器不同的是，这种方法受限于已有的API，并且可能导致一些麻烦的矛盾问题。举例来说，<code>DateTime</code>和<code>Time</code>在一些特殊的场景下就有可能出现不一样的行为：
<code>ruby
datetime == time #=&gt; true
datetime + 1     #=&gt; 2014-02-26 07:32:39
time + 1         #=&gt; 2014-02-25 07:32:40
</code>
当加上1的时候，<code>DateTime</code>加上了一天，而<code>Time</code>则是加上了一秒。当你需要使用它们的时候，你要记住ActiveSupport基于这些不同，提供了诸如<code>change</code>和<code>Duration</code>等保证一致行为的方法或类。</p>

<p>这是一个好的模式吗？它理所当然是方便的，但是如你刚才所见，你仍旧需要注意其中的一些不同之处。</p>

<h3>总结</h3>

<p>设计模式不是只有Java才需要的。Rails通过使用设计模式以提供用于JSON解析以及数据库维护的统一接口。由于Ruby的灵活性，类似<code>DateTime</code>以及<code>Time</code>这样的类可以被直接地修改而提供相似的接口。Rails的源码就是一个可以让你挖掘真实世界中不同设计模式实例的天堂。</p>

<p>在这次的实践中，我们同时也发掘了一些有趣的代码：</p>

<ul>
<li><code>hash[:foo] = hash.delete(:bar)</code>是一个用于重命名哈希表中某一项的巧妙方法。</li>
<li>调用<code>::ClassName</code>会调用顶层的类。</li>
<li>ActiveSupport为<code>Time</code>、<code>Date</code>以及其他的类添加了一个可选的代表格式的参数<code>format</code>。</li>
<li><code>sprintf</code>可以用于格式化数字。</li>
</ul>


<p>想要探索更多的知识？回去看看MultiJson是如何处理以及解析格式的。仔细阅读你在你的数据库中所使用到的ActiveRecord的适配器的代码。浏览ActiveSupport中用于xml适配器的<code>XmlMini</code>，它跟MultiJson中的JSON适配器是类似的。在这些里面还会有很多可以学习的。</p>

<p>喜欢这篇文章？<br>
<a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
</feed>
