<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 翻译 | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/fan-yi/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2018-02-10T21:57:53+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[解读 Rails: Migrations]]></title>
    <link href="http://Martin91.github.io/blog/articles/2017/10/14/jie-du-rails-migrations/"/>
    <updated>2017-10-14T22:29:20+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2017/10/14/jie-du-rails-migrations</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://www.monkeyandcrow.com/blog/reading_rails_migrations/">Reading Rails &ndash; Migrations</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>今天我们将会探讨一下 Rails 经常被忽视的可靠的工作伙伴 —— Migrator。它是如何搜寻你的 migrations 并且执行它们的呢？我们将再一次慢慢地挖掘 Rails 的源代码，并在此过程中慧海拾珠。</p>

<!-- MORE -->


<p>为了跟随本文的步骤，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开相关的代码库，或者直接在<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github</a>上查看这些代码。</p>

<h3>动身启程</h3>

<p>在展开讨论之前，此处并无特殊准备要求。或许你已经创建好了项目所需要的但是仍是空的数据库。如果你执行 <code>rake db:migrate</code>，所有的未执行的 migrations 就会开始执行。让我们从查看 <code>databases.rake</code> 里的 Rake 任务的源码开始动起来：</p>

<p><code>ruby
desc "Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog)."
task :migrate =&gt; [:environment, :load_config] do
  ActiveRecord::Migration.verbose = ENV["VERBOSE"] ? ENV["VERBOSE"] == "true" : true
  ActiveRecord::Migrator.migrate(ActiveRecord::Migrator.migrations_paths, ENV["VERSION"] ? ENV["VERSION"].to_i : nil)
  #...
end
</code></p>

<p>虽然我们并不打算揭露 Rake 本身的工作机制，但是值得注意的是，执行 <code>migrate</code> 要求另外两个任务 <code>[:environment, :load_config]</code> 的首先执行。这能确保 Rails 的运行环境以及你的 <code>database.yml</code> 文件被加载进来。</p>

<p>上面的 rake 任务通过环境变量配置了 <code>ActiveRecord::Migration</code> 以及 <code>ActiveRecord::Migrator</code>。环境变量是一种非常有效的可用于向你的应用程序传递信息的方式。缺省地，诸如<code>USER</code>的很多（环境）变量都是已经设置好的，他们也可以在每个（终端）命令执行时单独设置。举个例子，如果你通过 <code>VERBOSE=false rake db:migrate</code> 调用了 Rake 任务，<code>ENV["VERBOSE"]</code>的值就会是字符串<code>"false"</code>。</p>

<p>```ruby</p>

<h1>通过环境变量启动 irb：</h1>

<h1>> FOOD=cake irb</h1>

<p>ENV[&lsquo;FOOD&rsquo;]     #=> &lsquo;cake&rsquo;
ENV[&lsquo;USER&rsquo;]     #=> &lsquo;adam&rsquo;
ENV[&lsquo;WAFFLES&rsquo;]  #=> nil
```</p>

<p>migration 的真正工作是从 <code>ActiveRecord::Migrator.migrate</code> 开始的，这个方法接受了第一个参数，用于表示 migrations 文件可能存在的路径的集合，另外还有一个可选参数，用于表示 migrate 执行的目标版本。</p>

<h3>搜寻 migrations</h3>

<p>现在就打开 ActiveRecord 里的 <code>migration.rb</code> 文件，不过在深入探究之前，先查看下在这个文件里最上面定义的异常。定义自定义的异常是非常容易的，<code>migration.rb</code> 里就有一些不错的例子：</p>

<p>```ruby
module ActiveRecord
  # 可以用于在回滚过程中中止 migrations 的异常类
  class IrreversibleMigration &lt; ActiveRecordError
  end</p>

<p>  #&hellip;
  class IllegalMigrationNameError &lt; ActiveRecordError#:nodoc:</p>

<pre><code>def initialize(name)
  super("Illegal name for migration file: #{name}\n\t(only lower case letters, numbers, and '_' allowed)")
end
</code></pre>

<p>  end</p>

<p>  #&hellip;
```</p>

<p>像我们在之前讲 <a href="/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/">Rails 处理异常</a> 的文章中一样，自定义异常能够被特别处理。在这个案例里，<code>IrreversibleMigration</code> 表示当前的 <code>migration</code> 不能被回滚。另外一个需要定义你自己的异常的原因是，可以像<code>IllegalMigrationNameError</code>一样，通过重定义<code>initialize</code>方法来实现生成一致的错误消息。同时，要确保你调用了 <code>super</code>。</p>

<p>现在向下滚动（文件），让我们看看 <code>Migrator.migrate</code>：</p>

<p>```ruby
class Migrator
  class &lt;&lt; self</p>

<pre><code>def migrate(migrations_paths, target_version = nil, &amp;block)
  case
  when target_version.nil?
    up(migrations_paths, target_version, &amp;block)
  #...
  when current_version &gt; target_version
    down(migrations_paths, target_version, &amp;block)
  else
    up(migrations_paths, target_version, &amp;block)
  end
end
</code></pre>

<p>  #&hellip;
```</p>

<p>取决于 <code>target_version</code>，我们将通过 <code>up</code> 或者 <code>down</code> 完成 migrate。这两个方法遵循了同样的模式，都是扫描了 <code>migration_paths</code> 里的可执行的 migrations，然后初始化一个新的 <code>Migrator</code> 的实例。让我们看看这些 migrations 是如何被搜寻到的：</p>

<p>```ruby
class Migrator
  class &lt;&lt; self</p>

<pre><code>def migrations(paths)
  paths = Array(paths)

  files = Dir[*paths.map { |p| "#{p}/**/[0-9]*_*.rb" }]

  migrations = files.map do |file|
    version, name, scope = file.scan(/([0-9]+)_([_a-z0-9]*)\.?([_a-z0-9]*)?\.rb\z/).first

    raise IllegalMigrationNameError.new(file) unless version
    version = version.to_i
    name = name.camelize

    MigrationProxy.new(name, version, file, scope)
  end

  migrations.sort_by(&amp;:version)
end
</code></pre>

<p>```</p>

<p>这个方法里满是非常值得学习的实例，让我们停留几分钟并且仔细阅读它。最开始，代码里通过一个 <code>Array()</code> 方法这样的小技巧，确保了参数始终是数组类型。“你说这（Array）是个方法？”是的！这虽然不是很正统，但定义一个驼峰式命名的方法是合法的，甚至这样的方法名还可以和类同名：</p>

<p>```ruby
class Flummox
end</p>

<p>def Flummox()
  &ldquo;confusing&rdquo;
end</p>

<p>Flummox       #=> Flummox
Flummox.new   #=> #&lt;Flummox:0x0000000bf0b5d0>
Flummox()     #=> &ldquo;confusing&rdquo;
```</p>

<p>Ruby 使用了这个特性定义了一个 <code>Array()</code> 方法，这个方法始终返回一个数组。</p>

<p><code>ruby
Array(nil)                #=&gt; []
Array([])                 #=&gt; []
Array(1)                  #=&gt; [1]
Array("Hello")            #=&gt; ["Hello"]
Array(["Hello", "World"]) #=&gt; ["Hello", "World"]
</code></p>

<p>这个方法类似于 <code>to_a</code>，但是可以在任何（类型的）对象上调用。Rails 通过 <code>paths = Array(paths)</code>使用了这个（方法），得以确保 <code>paths</code> 将是一个数组。</p>

<p>在接下来一行的代码里，Rails 搜寻了指定的路径并且进行了过滤：</p>

<p><code>ruby
files = Dir[*paths.map { |p| "#{p}/**/[0-9]*_*.rb" }]
</code></p>

<p>让我们将这个代码分解一下。<code>paths.map { |p| "#{p}/**/[0-9]*_*.rb" }</code>将每一个路径转换成一个 <a href="http://en.wikipedia.org/wiki/Glob_(programming)"><code>shell glob</code></a>。一个类似 <code>"db/migrate"</code> 的路径就变成了 <code>"db/migrate/**/[0-9]*_*.rb"</code>，这将会在 <code>"db/migrate"</code> 或者它的所有子目录里匹配所有用数字开头的文件。这些（shell glob 表示的）路径通过 <code>*</code> 操作符分成（单个元素）并且传递给了 <code>Dir[]</code>。</p>

<p><code>Dir[]</code> 是非常有用的。它接收类似 <code>"db/migrate/**/[0-9]*_*.rb"</code> 这样的模式（作为参数），然后返回匹配的文件列表。当你需要在指定路径里查找文件的时候，<code>Dir[]</code> 就是称手利器。其中，<code>**</code> 表示递归地在所有子目录中执行匹配，而 <code>*</code> 则表示一个或多个字符的通配符，也就是说，前面的这个模式就是为了匹配类似 <code>20131127051346_create_people.rb</code> 的 migrations （文件）。</p>

<p>Rails 遍历每一个匹配的文件，并且通过 <code>String#scan</code> 结合正则表达式提取信息。如果你对正则表达式不是很熟悉，那现在就应该抛开一切，先学习好正则表达式再说。<code>String#scan</code> 以字符串形式返回所有匹配的结果。如果表达式里还包含了 capturing groups（匹配分组），它们将会以内嵌数组（subarrays）的方式返回。比如：</p>

<p>```ruby
s = &ldquo;123 abc 456&rdquo;</p>

<h1>没有 capturing groups:</h1>

<p>s.scan(/\d+/)           #=> [&ldquo;123&rdquo;, &ldquo;456&rdquo;]
s.scan(/\d+\s\w+/)      #=> [&ldquo;123 abc&rdquo;]</p>

<h1>先匹配数字，再匹配单词：</h1>

<p>s.scan(/(\d+)\s+(\w+)/) #=> [[&ldquo;123&rdquo;, &ldquo;abc&rdquo;]]
```</p>

<p>所以 <code>file.scan</code> 将会匹配版本号<code>([0-9]+)</code>，名字<code>([_a-z0-9]*)</code>，以及一个可选的 scope <code>([_a-z0-9]*)?</code>。由于 <code>String#scan</code> 始终返回数组，并且我们知道这个模式只会出现一次，所以 Rails 直接提取第一个匹配结果。Rails 一次性执行了多个变量赋值 <code>version, name, scope = ...</code>。这是得益于数组的解构：</p>

<p><code>ruby
version, name, scope = ["20131127051346", "create_people"]
version #=&gt; "20131127051346"
name    #=&gt; "create_people"
scope   #=&gt; nil
</code></p>

<p>注意一下，如果（等号左边）变量的数量大于（等号右边）数组的元素的数量，多余变量的值将会被赋值为<code>nil</code>。这是一种从正则表达式（匹配后的值）进行多个赋值的快捷技巧。</p>

<p>匹配的版本号 version 通过 <code>to_i</code> 方法转换为一个整数（Fixnum），而同时，名字 name 通过 <code>name.camelize</code> 完成了格式转换。<code>String#camelize</code>是 <code>ActiveSupport</code> 里的方法，用于下划线命名 <code>snake_case</code> 和 驼峰式命名 <code>CamelCase</code> 之间的相互转换。这个方法可以将 <code>"create_people"</code> 转换为 <code>CreatePeople</code>。</p>

<p>让我们过会再看下 <code>MigrationProxy</code>，现在先看下 <code>Migrator#migrations</code> 这个方法的最后一个部分，<code>migrations.sort_by(&amp;:version)</code>。这个表达式将所有 migrations 基于版本号进行了排序。如何排序的方式会是更有趣的内容。</p>

<p>从 Ruby 1.9 开始，<code>&amp;</code>操作将会在被它作用的对象上调用 <code>to_proc</code> 方法。当在一个 symbol 上调用时，返回的结果是一个代码块里调用与 symbol 同命名的方法的 <code>Proc</code> 对象。所以 <code>&amp;:version</code> 等同于某行代码的 <code>{|obj| obj.version }</code>。</p>

<p>```ruby
Library = Struct.new(:name, :version)
libraries = [
  Library.new(&ldquo;Rails&rdquo;, &ldquo;4.0.1&rdquo;),
  Library.new(&ldquo;Rake&rdquo;, &ldquo;10.1.0&rdquo;)
]</p>

<p>libraries.map{|lib| lib.version } #=> [&ldquo;4.0.1&rdquo;, &ldquo;10.1.0&rdquo;]</p>

<h1>&amp;:version => Proc.new{|lib| lib.version } (Roughly)</h1>

<p>libraries.map(&amp;:version)          #=> [&ldquo;4.0.1&rdquo;, &ldquo;10.1.0&rdquo;]
```</p>

<p>在 Rails 里，这种技巧在排序或者映射的时候非常常见。和众多的技巧一样，请确认你的团队能够适应这种语法。如有疑虑，更好的方案就是不再使用（这种技巧），这会让代码更清晰。</p>

<h3>The Migration</h3>

<p>现在，回到 <code>MigrationProxy</code>。顾名思义，只是一个 <code>Migration</code> 的实例的代理。代理对象（Proxy objects）是一个常见的用于透明地将一个对象替换为另一个对象的设计模式。在这个例子中，<code>MigrationProxy</code>代替了一个真正的 <code>Migration</code> 对象，而且除非必需，它会延缓对 migration 的源码的实际的加载。<code>MigrationProxy</code> 通过委托方法（delegating methods）达到目的：</p>

<p>```ruby
class MigrationProxy
  #&hellip;
  delegate :migrate, :announce, :write, :disable_ddl_transaction, to: :migration</p>

<p>  private</p>

<pre><code>def migration
  @migration ||= load_migration
end

def load_migration
  require(File.expand_path(filename))
  name.constantize.new
end
</code></pre>

<p>end
```</p>

<p><code>delegate</code> 方法将它的每一个参数都发送给了 <code>to:</code> 选项返回的对象，在这里，这个对象就是我们的 <code>migration</code>。如果 <code>@migration</code> 实例变量尚未定义或赋值，<code>migration</code> 方法将会执行懒加载migration <code>load_migration</code>。<code>load_migration</code> 方法按序加载(require) ruby 源码，然后使用 <code>name.constantize.new</code> 创建一个新的实例。<code>String#constantize</code> 是 ActiveSupport 中定义的方法，用于返回名字与字符串相同的常量：</p>

<p><code>ruby
"Person".constantize       #=&gt; Person
"Person".constantize.class #=&gt; Class
"person".constantize       #=&gt; NameError: wrong constant name person
</code></p>

<p>当你想要动态地引用一个类时，这个技巧非常有效。</p>

<p>通过 <code>MigrationProxy</code>，Rails 只加载并且实例化必要的 migrations，这能为 migration 的处理提速，同时节约更多内存。</p>

<p>真正的 <code>Migration</code> 类在代理委托了 <code>migrate</code> 方法的时候才被 <code>Migrator</code> 调用。这个按序调用 <code>Migration#up</code> 或者 <code>Migration#down</code> 取决于 migration 是在先前执行，还是在执行回滚。</p>

<h3>总结（Recap）</h3>

<p>我们仅仅只是一瞥了 Rails 的 migration 机制的源码的表面，但是我们却已经学到了一些有趣的知识。Migrations 由一个调用了 <code>Migrator</code> 的 Rake 任务启动，<code>Migrator</code> 又按序查找到了我们的 migrations，并且使用了 <code>MigrationProxy</code> 对象对这些 migrations 进行了包装，直到真正的 <code>Migration</code> 需要被执行的时候。</p>

<p>一如既往，我们已经了解了一些有趣的方法、习惯以及技巧：</p>

<ul>
<li>环境变量可以通过 <code>ENV</code> 常量访问；</li>
<li>定义自定义的异常类，是一种常见的对异常进行处理的手段；</li>
<li><code>Array()</code> 方法将任意对象转换为数组；</li>
<li><code>Dir[]</code> 使用 <code>shell glob</code> 语法搜索文件；</li>
<li><code>String#scan</code> 返回字符串里所有匹配的结果，并且支持匹配分组（capturing groups）；</li>
<li><code>String#camelize</code> 将下划线形式（snake_case）字符串转换为驼峰式（CamelCase）;</li>
<li><code>&amp;</code> 操作符在符号类型的对象上调用时，会创建一个 <code>Proc</code> 对象</li>
<li><code>delegate</code> 可以用于实现代理的设计模式</li>
<li>可以通过 <code>String#contantize</code> 方法动态加载常量</li>
</ul>


<p>下一次，或许我们就能弄明白 <code>Migrator</code> 是如何确切知道哪些 migrations 已经在你的数据库里执行过。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spree 2.3.0已经发布]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/07/28/spree-2-dot-3-0yi-jing-fa-bu/"/>
    <updated>2014-07-28T21:32:54+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/07/28/spree-2-dot-3-0yi-jing-fa-bu</id>
    <content type="html"><![CDATA[<p><strong>声明：</strong>原文来自Spree官方博客<a href="http://spreecommerce.com/blog/spree-2-3-released">Spree 2.3.0 Released</a>，原文发布日期是2014-06-30，本文仅作翻译。</p>

<p><strong>简要介绍：</strong><a href="http://spreecommerce.com/">Spree</a>是一个基于<a href="http://rubyonrails.org/">Ruby on Rails</a>开发的开源在线商城框架，提供了从商品展示购买、下单支付到库存管理以及订单管理等一系列基本功能，并且支持通过第三方扩展的形式定制或者扩展框架的功能，最新版本的Spree已经支持最新的Rails版本。</p>

<p>Spree 2.3的最新更改已经加入对Rails 4.1的支持，提供了更好的配置项的存储，更好的针对多店铺的支持，以及更好的游客追踪。Spree 2.3的发布，有赖于总的97位贡献者以及他们总的700多个的commit记录。现在，我们非常兴奋地宣布：Spree 2.3发布了！</p>

<!-- More -->


<h3>Rails 4.1 的支持</h3>

<p>现在，Rails 4.1已经得到了Spree 2.3的支持。如果你希望基于Rails 4.1进行开发，那么Spree 2.3就是特为你准备的发布版。</p>

<h3>基于序列化记录的配置项</h3>

<p>现在，所有的配置项存储在一个记录上，而不是存储在<code>spree_preferences</code>表中。这意味着，为了获取一个配置项，比如价格的计算器配置，就会触发一个数据库查询，所查询的那一行记录有一个包含了所有配置信息的命名为<code>preferences</code>的列。</p>

<p>而在此之前，对于每一个配置记录本身，可能都会有一个单独的数据库调用，而在查询到所请求的配置项之后，还是有可能会有任意数目的数据库调用产生。而现在，我们总的只需要调用一次，这意味着程序本身将会有一些速度上的提升。</p>

<h3>更好的多店铺支持</h3>

<p>我们已经添加了一个名为<code>Spree::Store</code>的model，用于支持基本的多店铺/多域名的站点。其在<code>spree-multi-domain</code>这个扩展的基础上提供了针对多店铺/多域名的基本框架。一些原有的配置项被转移到了这个model上，以此实现根据具体的店铺提供不同配置值：</p>

<ul>
<li><code>Spree::Config[:site_name]</code> 迁移到了 <code>name</code></li>
<li><code>Spree::Config[:site_url]</code> 迁移到了 <code>url</code></li>
<li><code>Spree::Config[:default_meta_description]</code> 迁移到了 <code>meta_description</code></li>
<li><code>Spree::Config[:default_meta_keywords]</code> 迁移到了 <code>meta_keywords</code></li>
<li><code>Spree::Config[:default_seo_title]</code> 迁移到了 <code>seo_title</code></li>
</ul>


<p>一个数据库迁移文件将会负责把这些原有的配置项转移到一个新的默认的store实例上。</p>

<p>一个新的名为<code>ControllerHelpers::Store</code>的Concern提供了一个<code>current_store</code>helper，可以在请求的域名的基础上，通过它获取当前店铺。</p>

<h3>更好的游客追踪</h3>

<p>现在，我们用了一个签名的cookie在浏览器中存储游客的唯一的token。通过它允许关闭了浏览器的顾客可以在再次访问时继续完成他们的购物流程。更重要的是，这也帮助作为商店主人的你方便地识别游客的订单。由于我们在访客来访时都会设置<code>cookies.signed[:guest_token]</code>，所以除了订单，或许你可以把cookie用于其他用途。</p>

<p>举个实际例子，如果游客需要收藏一个商品，你可以创建一个用于记录收藏记录的model，然后把<code>cookies.signed[:guest_token]</code>赋值给这个model中的<code>token</code>字段。这将有助于你分析当前用户在此之前的订单以及收藏记录，这对于商品推荐将是非常有用的。</p>

<h3>总结</h3>

<p>你可以从<a href="https://github.com/spree/spree/releases/tag/v2.3.0">Github</a>上浏览更详细的变更列表。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[属性方法]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa/"/>
    <updated>2014-03-12T20:58:17+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/12/shu-xing-fang-fa</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails &ndash; Attribute Methods</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>在我们<a href="/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨</a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似<code>attribute_method_suffix</code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似<code>name</code>这样的模型属性以及对应生成的类似<code>name_changed?</code>这样的方法的。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>声明（Declarations）</h3>

<p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，<code>attribute_method_suffix</code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在<a href="/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论</a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个<code>_changed?</code>方法(<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码)：
```ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
让我们打开ActiveModel库中的`attribute_methods.rb`文件，并且看一下到底发生了什么事情。
</code>ruby
def attribute_method_suffix(*suffixes)
  self.attribute_method_matchers += suffixes.map! do |suffix|</p>

<pre><code>AttributeMethodMatcher.new suffix: suffix
</code></pre>

<p>  end
  #&hellip;
end
```</p>

<p>当你调用<code>attribute_method_suffix</code>方法的时候，每一个后缀都通过<code>map!</code>方法转换为一个<code>AttributeMethodMatcher</code>对象。这些对象会被存储在<code>attribute_method_matchers</code>中。如果你重新看一下这个module的顶部，你会发现<code>attribute_method_matchers</code>是在每一个包含此module的类中使用<code>class_attribute</code>定义的方法：
```ruby
module AttributeMethods
  extend ActiveSupport::Concern</p>

<p>  included do</p>

<pre><code>class_attribute :attribute_aliases,
                :attribute_method_matchers,
                instance_writer: false
#...
</code></pre>

<p>```</p>

<p><code>class_attribute</code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
```ruby
class Person
  class_attribute :database
  #&hellip;
end</p>

<p>class Employee &lt; Person
end</p>

<p>Person.database = Sql.new(:host=>&lsquo;localhost&rsquo;)
Employee.database #=> &lt;Sql:host=&lsquo;localhost&rsquo;>
```</p>

<p>Ruby中并没有<code>class_attribute</code>的内置实现，它是在ActiveSupport(<strong>提示</strong>:命令行中键入<code>qw activesupport</code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下<code>attribute.rb</code></p>

<p>现在我们来看一下<code>AttributeMethodMatcher</code>。
```ruby
class AttributeMethodMatcher #:nodoc:
  attr_reader :prefix, :suffix, :method_missing_target</p>

<p>  def initialize(options = {})</p>

<pre><code>#...
@prefix, @suffix = options.fetch(:prefix, ''), options.fetch(:suffix, '')
@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
@method_missing_target = "#{@prefix}attribute#{@suffix}"
@method_name = "#{prefix}%s#{suffix}"
</code></pre>

<p>  end
<code>
代码中的`prefix`以及`suffix`是通过`Hash#fetch`方法提取出来的。这会返回一个对应键的值，或者是一个默认值。如果调用方法的时候没有提供默认值，`Hash#fetch`方法将会抛出一个异常，提示指定的键不存在。对于options的处理来说是一种不错的模式，特别是对于boolean型数据来说：
</code>ruby
options = {:name => &ldquo;Mortimer&rdquo;, :imaginary => false}</p>

<h1>Don&rsquo;t do this:</h1>

<p>options[:imaginary] || true     #=> true</p>

<h1>Do this:</h1>

<p>options.fetch(:imaginary, true) #=> false
```</p>

<p>对于我们的<code>attribute_method_suffix</code>其中的<code>'_changed'</code>示例来说，<code>AttributeMethodMatcher</code>将会有如下的实例变量：
<code>ruby
@prefix                #=&gt; ""
@suffix                #=&gt; "_changed?"
@regex                 #=&gt; /^(?:)(.*)(?:_changed\?)$/
@method_missing_target #=&gt; "attribute_changed?"
@method_name           #=&gt; "%s_changed?"
</code></p>

<p>你一定想知道<code>%s_changed</code>中的<code>%s</code>是用来干什么的吧？这是一个格式化字符串（format string）。你可以使用<code>sprintf</code>方法对它插入值，或者使用缩写（shortcut）<code>%</code>：
<code>ruby
sprintf("%s_changed?", "name") #=&gt; "named_changed?"
"%s_changed?" % "age"          #=&gt; "age_changed?"
</code></p>

<p>第二个比较有趣的地方就是正则表达式创建的方式。请留意创建<code>@regex</code>变量时<code>Regexp.escape</code>的用法。如果后缀没有被escape，则正则表达式中带有特殊含义的符号将会被错误解释(misinterpreted)：
```ruby</p>

<h1>Don&rsquo;t do this!</h1>

<p>regex = /^(?:#{@prefix})(.<em>)(?:#{@suffix})$/ #=> /^(?:)(.</em>)(?:_changed?)$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> nil
regex.match(&ldquo;name_change&rdquo;)                   #=> #<MatchData "name_change" 1:"name"></p>

<h1>Do this:</h1>

<p>@regex = /^(?:#{Regexp.escape(@prefix)})(.*)(?:#{Regexp.escape(@suffix)})$/
regex.match(&ldquo;name_changed?&rdquo;)                 #=> #<MatchData "name_changed?" 1:"name">
regex.match(&ldquo;name_change&rdquo;)                   #=> nil
```</p>

<p>请仔细记住<code>regex</code>以及<code>method_name</code>，它们可以用来匹配和生成属性方法，我们在后面还会继续用到它们。</p>

<p>我们现在已经搞明白了属性方法是如何声明的，但是实际中，Rails又是如何使用它们的呢？</p>

<h3>通过Method Missing调用（Invocation With Method Missing）</h3>

<p>当我们调用了一个未定义的方法时，Rails将会在抛出异常之前调用对象的<code>method_missing</code>方法。让我们看看Rails是如何利用这个技巧调用属性方法的：
```ruby
def method_missing(method, *args, &amp;block)
  if respond_to_without_attributes?(method, true)</p>

<pre><code>super
</code></pre>

<p>  else</p>

<pre><code>match = match_attribute_method?(method.to_s)
match ? attribute_missing(match, *args, &amp;block) : super
</code></pre>

<p>  end
end
```</p>

<p>传给<code>method_missing</code>方法的第一个参数是一个用symbol类型表示的方法名，比如，我们的<code>:name_changed?</code>。<code>*args</code>是（未定义的）方法被调用时传入的所有参数，<code>&amp;block</code>是一个可选的代码块。Rails首先通过调用<code>respond_to_without_attributes</code>方法检查是否有别的方法可以对应这次调用。如果别的方法可以处理这次调用，则通过<code>super</code>方法转移控制权。如果找不到别的方法可以处理当前的调用，ActiveModel则会通过<code>match_attribute_method?</code>方法检查当前调用的方法是否是一个属性方法。如果是，它则会接着调用<code>attribute_missing</code>方法。</p>

<p><code>match_attribute_method</code>方法利用了之前声明过的<code>AttributeMethodMatcher</code>对象：
<code>ruby
def match_attribute_method?(method_name)
  match = self.class.send(:attribute_method_matcher, method_name)
  match if match &amp;&amp; attribute_method?(match.attr_name)
end
</code></p>

<p>在这个方法里边发生了两件事。第一，Rails查找到了一个匹配器(matcher)，并且检查这是否真的是一个属性。说实话，我自己也是比较迷惑，为什么<code>match_attribute_method?</code>方法调用的是<code>self.class.send(:attribute_method_matcher, method_name)</code>，而不是<code>self.attribute_method_matcher(method_name)</code>，但是我们还是可以假设它们的效果是一样的。</p>

<p>如果我们再接着看<code>attribute_method_matcher</code>，就会发现它的最核心的代码仅仅只是扫描匹配了<code>AttributeMethodMatcher</code>实例，它所做的事就是对比对象本身的正则表达式与当前的方法名：
<code>ruby
def attribute_method_matcher(method_name)
  #...
  attribute_method_matchers.detect { |method| method.match(method_name) }
  #...
end
</code></p>

<p>如果Rails找到了匹配当前调用的方法的属性，那么接下来所有参数都会被传递给<code>attribute_missing</code>方法：
<code>ruby
def attribute_missing(match, *args, &amp;block)
  __send__(match.target, match.attr_name, *args, &amp;block)
end
</code></p>

<p>这个方法将匹配到的属性名以及传入的任意参数或者代码块代理给了<code>match.target</code>。回头看下我们的实例变量，<code>match.target</code>将会是<code>attribute_changed?</code>，而且<code>match.attr_name</code>则是"name"。<code>__send__</code>方法将会调用<code>attribute_changed?</code>方法，或者是你定义的任意一个特殊的属性方法。</p>

<h3>元编程（Metaprogramming）</h3>

<p>有很多的方式可以对一个方法的调用进行分发（dispatch），如果这个方法经常被调用，那么实现一个<code>name_changed?</code>方法将会更为有效。Rails通过<code>define_attribute_methods</code>方法做到了对这类属性方法的自动定义：
```ruby
def define_attribute_methods(*attr_names)
  attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
end</p>

<p>def define_attribute_method(attr_name)
  attribute_method_matchers.each do |matcher|</p>

<pre><code>method_name = matcher.method_name(attr_name)

define_proxy_call true,
                  generated_attribute_methods,
                  method_name,
                  matcher.method_missing_target,
                  attr_name.to_s
</code></pre>

<p>  end
end
```</p>

<p><code>matcher.method_name</code>使用了我们前面见到过的格式化字符串，并且插入了<code>attr_name</code>。在我们的例子中，<code>"%s_changed?"</code>变成了<code>"name_changed?"</code>。现在我们我们准备好了了解在<code>define_proxy_call</code>中的元编程。下面是这个方法被删掉了一些特殊场景下的代码的版本，你可以在阅读完这篇文章后自己去了解更多的代码。
```ruby
def define_proxy_call(include_private, mod, name, send, <em>extra)
  defn = &ldquo;def #{name}(</em>args)&rdquo;
  extra = (extra.map!(&amp;:inspect) &lt;&lt; &ldquo;*args&rdquo;).join(&ldquo;, &rdquo;)
  target = &ldquo;#{send}(#{extra})&rdquo;</p>

<p>  mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1</p>

<pre><code>#{defn}
  #{target}
end
</code></pre>

<p>  RUBY
end
```</p>

<p>这里为我们定义了一个新的方法。<code>name</code>就是正要被定义的方法名，而<code>send</code>则是处理器(handler)，另外的<code>extra</code>是属性名。<code>mod</code>参数是一个Rails用<code>generated_attribute_methods</code>方法生成的特殊的模块（module），它被嵌入（mixin）到我们的类中。现在让我们多看一下<code>module_eval</code>方法。这里有三件有趣的事情发生了。</p>

<p>第一件事就是<a href="http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html">HEREDOC</a>被用作一个参数传给了一个方法。这是有点难懂的，但是对某些场景却是非常有用的。举个例子，想象我们在一个服务器响应(response)中有一个方法要用来嵌入Javascript代码：
<code>ruby
include_js(&lt;&lt;-JS, :minify =&gt; true)
  $('#logo').show();
  App.refresh();
JS
</code></p>

<p>这将会把字符串<code>"$('#logo').show(); App.refresh();"</code>作为调用<code>include_js</code>时传入的第一个参数，而<code>:minify =&gt; true</code>作为第二个参数。在Ruby中需要生成代码时，这是一个非常有用的技巧。值得高兴的是，诸如<a href="https://github.com/textmate/textmate">TextMate</a>这类编辑器都能够识别这个模式，并且正确地高亮显示字符串。即使你并不需要生成代码，HEREDOC对于多行的字符串也是比较有用的。</p>

<p>现在我们就知道了<code>&lt;&lt;-RUBY</code>做了些什么事，但是<code>__FILE__</code>以及<code>__LINE__ + 1</code>呢？<code>__FILE__</code>返回了当前文件的（相对）路径，而<code>__LINE__</code>返回了当前代码的行号。<code>module_eval</code>接收这些参数，并通过这些参数决定新的代码定义在文件中“看起来”的位置。在对于栈跟踪（stack traces）来说是特别有用的。</p>

<p>最后，让我们看一些<code>module_eval</code>中实际执行的代码。我们可以把值替换成我们的<code>name_changed?</code>：
```ruby
mod.module_eval &lt;&lt;-RUBY, <strong>FILE</strong>, <strong>LINE</strong> + 1
  def name_changed?(*args)</p>

<pre><code>attribute_changed?("name", *args)
</code></pre>

<p>  end
RUBY
<code>``
现在</code>name_changed?<code>就是一个真实的方法了，比起依赖于</code>method_missing`方法的实现，这种方法的开销要小得多。</p>

<h3>总结（Recap）</h3>

<p>我们发现了调用<code>attribute_method_suffix</code>方法会保存一个配置好的对象，这个对象用于Rails中两种元编程方法中的一种。不考虑是否使用了<code>method_missing</code>，或者通过<code>module_eval</code>定义了新的方法，方法的调用最后总会被传递到诸如<code>attribute_changed?(attr)</code>这样的方法上。</p>

<p>走过这次比较宽泛的旅途，我们也收获了一些有用的技巧：</p>

<ul>
<li>你必须使用<code>Hash#fetch</code>从options中读取参数，特别是对于boolean类型参数来说。</li>
<li>诸如<code>"%s_changed"</code>这样的格式化字符串，可以被用于简单的模板。</li>
<li>可以使用<code>Regexp.escape</code>escape正则表达式。</li>
<li>当你试图调用一个未定义的方法时，Ruby会调用<code>method_missing</code>方法。</li>
<li>HEREDOCs可以用在方法参数中，也可以用来定义多行的字符串。</li>
<li><code>__FILE__</code>以及<code>__LINE__</code>指向当前的文件以及行号。</li>
<li>你可以使用<code>module_eval</code>动态生成代码。</li>
</ul>


<p>坚持浏览Rails的源代码吧，你总会发现你原本不知道的宝藏！</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>《解读Rails》中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[跟踪model中属性（值）的变更]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng/"/>
    <updated>2014-03-07T13:02:47+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/07/zhui-zong-bian-geng</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_change_tracking/">Reading Rails &ndash; Change Tracking</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天来看看Rails是如何追踪model里边属性的变更的。
<code>ruby
person = Person.find(8)
person.name = "Mortimer"
person.name_changed?    #=&gt; true
person.name_was         #=&gt; "Horton"
person.changes          #=&gt; {"name"=&gt;["Horton","Mortimer"]}
person.save!
person.changes          #=&gt; {}
</code>
<code>name_changed?</code>方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。</p>

<!-- More -->


<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>ActiveModel</h3>

<p>当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（<strong>提示</strong>： 命令行中键入<code>qw activemodel</code>查看代码）定义了没有与数据库捆绑的逻辑。我们将从<code>dirty.rb</code>文件开始。在这个模块最开始的地方，代码调用了<code>attribute_method_suffix</code>：
``` ruby
module Dirty
  extend ActiveSupport::Concern
  include ActiveModel::AttributeMethods</p>

<p>  included do</p>

<pre><code>attribute_method_suffix '_changed?', '_change', '_will_change!', '_was'
#...
</code></pre>

<p><code>
`attribute_method_suffix`定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似`_changed?`后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到`def attribute_changed?`：
</code> ruby
def attribute_changed?(attr)
  changed_attributes.include?(attr)
end
<code>
我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似`name_changed?`的方法时，Rails将会把`"name"`作为参数`attr`传给上述方法。往回看一点点，你会发现`changed_attributes`只是一个包含了从属性名到旧的属性值的映射的`Hash`而已：
</code> ruby</p>

<h1>Returns a hash of the attributes with unsaved changes indicating their original</h1>

<h1>values like <tt>attr => original value</tt>.</h1>

<p>#</p>

<h1>person.name # => &ldquo;bob&rdquo;</h1>

<h1>person.name = &lsquo;robert&rsquo;</h1>

<h1>person.changed_attributes # => {&ldquo;name&rdquo; => &ldquo;bob&rdquo;}</h1>

<p>def changed_attributes
  @changed_attributes ||= {}
end
<code>``
在Ruby中，如果你之前都没有见过</code>||=<code>操作，那么你可能需要了解这其实是一个用于初始化变量值的技巧。当它第一次被访问的时候，变量的值是</code>nil<code>，所以它返回了一个空的</code>Hash<code>并且用其初始化</code>@changed_attributes<code>。当它再一次被访问的时候，</code>@changed_attributes<code>已经被赋值过了。那么现在我们可以回答我们的第一个问题了，</code>name_changed?<code>方法被转发到</code>attribute_changed?<code>方法，而后者会在</code>changed_attributes`中查找特定的值。</p>

<p>在我们的例子中，我们看到<code>changes</code>返回一个类似<code>{"name"=&gt;["Horton","Mortimer"]}</code>这样既包含旧的属性值，又包含新的属性值的<code>Hash</code>。让我们这又是如何做到的：
<code>ruby
def changes
  ActiveSupport::HashWithIndifferentAccess[changed.map { |attr| [attr, attribute_change(attr)] }]
end
</code>
这段代码看起来有点难以理解，但是我们可以一步一步分析。首先我们从<code>ActiveSupport::HashWithIndifferentAccess</code>开始，这是在ActiveSupport中所定义的<code>Hash</code>的子类，通过字符串类型或者符号类型的键去访问它将得到一样的结果：
<code>ruby
hash = ActiveSupport::HashWithIndifferentAccess.new
hash[:name] = "Mortimer"
hash["name"] #=&gt; "Mortimer"
</code>
接下来就有点奇怪了，Rails调用了<code>Hash[]</code>方法。这是一个鲜为人知的从包含键/值对的数组中初始化一个哈希表的方法。
<code>ruby
Hash[
  [:name, "Mortimer"],
  [:species, "Crow"]
] #=&gt; {[:name, "Mortimer"]=&gt;[:species, "Crow"]}
</code>
可以查看<code>Hash Tricks</code>找到更多类似的方法。<code>changes</code>中剩余部分的代码就比较清晰了。属性名被映射到类似<code>[attr, attribute_change(attr)]</code>的数组。其中第一个元素，也就是<code>attr</code>编程了一个键，而对应的值则是<code>attribute_change(attr)</code>返回的结果。
<code>ruby
def attribute_change(attr)
  [changed_attributes[attr], __send__(attr)] if attribute_changed?(attr)
end
</code>
这是另一个被分发的属性方法，但是在这个例子里，它返回了一个包含了两个元素的数组，第一个元素是从<code>changed_attributes</code>哈希表中读到的<code>attr</code>所对应的旧的值，第二个则是所对应的新的值。Rails通过使用<code>__send__</code>方法调用了名为<code>attr</code>的方法，进而得到新的属性值。然后这对值会被返回，并且用作<code>changes</code>哈希表中<code>attr</code>所对应的值。</p>

<h3>ActiveRecord</h3>

<p>现在让我们来找出Rails是如何记录更改的。ActiveRecord实现了读写ActiveModel所跟踪的属性的代码。跟ActiveModel一样，ActiveRecord也有一个<code>dirty.rb</code>文件，我们将要对这个文件进行挖掘。通过在定义了<code>changed_attributes</code>的文件中（<strong>提示</strong>：命令行中键入<code>qw activerecord</code>）找到的相关代码，我们可以看到这个文件包装了ActiveRecord的<code>write_attribute</code>与逻辑以实现对变更的跟踪。
``` ruby</p>

<h1>Wrap write_attribute to remember original attribute value.</h1>

<p>def write_attribute(attr, value)
  attr = attr.to_s</p>

<p>  # The attribute already has an unsaved change.
  if attribute_changed?(attr)</p>

<pre><code>old = @changed_attributes[attr]
@changed_attributes.delete(attr) unless _field_changed?(attr, old, value)
</code></pre>

<p>  else</p>

<pre><code>old = clone_attribute_value(:read_attribute, attr)
@changed_attributes[attr] = old if _field_changed?(attr, old, value)
</code></pre>

<p>  end</p>

<p>  # Carry on.
  super(attr, value)
end
<code>
让我们暂时偏离一下主题，并且看一下方法的包装。这是在Rails的代码里边非常常见的模式。当你调用`super`的时候，Ruby查找当前对象的所有祖先，包括相关的模块。由于一个类可以引进多个模块，所以你可以多层地包装方法。这里是一个简单的例子：
</code> ruby
module Shouting
  def say(message)</p>

<pre><code>message.upcase
</code></pre>

<p>  end
end</p>

<p>class Speaker
  include Shouting</p>

<p>  def say(message)</p>

<pre><code>puts super(message)
</code></pre>

<p>  end
end</p>

<p>Speaker.new.say(&ldquo;Hi!&rdquo;) #=> &ldquo;HI!&rdquo;
<code>``
请注意</code>Shouting<code>是</code>Speaker<code>所包含的模块，而不是后者所扩展的类。Rails使用这种技巧去包装方法，以此确保在不同的文件里有独立的关注点（Concern）。这也意味着为了了解整个系统，你可能需要从多个文件里边找到相关的代码。假如你看到了一个对</code>super`的调用，这是一个可以告诉你在别的地方还有更多代码需要了解的好线索。假如你想学习更多的这方面的知识，James Coglan有一个非常详细的文章讲解了Ruby的<a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/">方法分发</a>。</p>

<p>回到<code>write_attribute</code>方法。根据属性（值）是否已经改变，会有两个可能的场景。第一个分支检查你是否正在将一个属性（值）还原到原来的值，如果是这样，它将会从记录了已改变属性的哈希表中删除属性。第二个分支仅仅在新的值与旧的值不同的时候记录下更改。一旦更改被记录下来，实际的用于更新属性的逻辑通过调用<code>super</code>方法完成。</p>

<h3>总结</h3>

<p>Rails为你的model提供了变更的跟踪。这个功能是在ActiveModel中实现的，但是真正的监测更改的逻辑则是在ActiveRecord中实现的。</p>

<p>通过了解这个功能，我们也发掘到了一些有趣的小贴士：</p>

<ul>
<li>ActiveModel定义了<code>attribute_method_suffix</code>方法用于分发类似<code>name_changed?</code>的方法。</li>
<li><code>||=</code>操作符是一个可以用来初始化变量的方便的方法。</li>
<li>在<code>HashWithIndifferentAccess</code>中，字符串类型以及符号类型的键是一样的。</li>
<li><code>Hash</code>可以通过<code>Hash[key_value_pairs]</code>方法初始化。</li>
<li>你可以使用模块拦截方法并为方法加上另一层的功能。</li>
</ul>


<p>假如你有关于你想阅读的关于Rails中其他部分的建议，请让我知道。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读Rails - 处理异常]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/"/>
    <updated>2014-03-05T13:53:09+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_handling_exceptions/">Reading Rails &ndash; Handling Exceptions</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。</p>

<!-- More -->


<p>Rails通过让你使用<code>rescue_from</code>方法，让你在你的<code>controller</code>里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。
``` ruby
class ApplicationController
  # Redirect users if they try to use disabled features.
  rescue_from FeatureDisabledError, InsufficientAccessError do |ex|</p>

<pre><code>flash[:alert] = "Your account does not support #{ex.feature_name}"
redirect_to "/pricing"
</code></pre>

<p>  end
  #&hellip;
```
我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。</p>

<p>如果需要跟着我的步骤走，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开每一个相关的代码库，或者直接从<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github</a>查看源码即可。</p>

<h3>定义处理器(Handlers)</h3>

<p>ActiveSupport包含了一个用于定义异常如何被处理的模块<code>Rescuable</code>。第一个需要了解的方法就是<code>rescue_from</code>。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（<strong>提示</strong>：查看代码，请在命令行中输入<code>qw activesupport</code>）：
``` ruby
def rescue_from(*klasses, &amp;block)
  options = klasses.extract_options!</p>

<p>  unless options.has_key?(:with)</p>

<pre><code>if block_given?
  options[:with] = block
else
  #...
</code></pre>

<p><code>``
首先，</code>*klasses<code>接收数量不定的异常类，所以你可以进行类似</code>rescue_from(FeatureDisabledError, InsufficientAccessError)`这样的调用。它们将会被存放在一个数组里。</p>

<p>接下来，请留意<code>extract_options!</code>的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用<code>:with</code>项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。</p>

<p>接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。
``` ruby
def rescue_from(*klasses, &amp;block)
  #&hellip;</p>

<pre><code>key = if klass.is_a?(Class) &amp;&amp; klass &lt;= Exception
  klass.name
elsif klass.is_a?(String)
  klass
else
</code></pre>

<p>  #&hellip;
<code>``
这里你应该注意的是，Rails是如何判定</code>klass<code>是不是继承自</code>Exception<code>的。通常情况下，你可能会通过使用</code>obj.is_a?(Exception)<code>来判断一个对象是不是某一个具体类型的实例，即使如此，</code>klass<code>并不是</code>Exception<code>，而只是</code>Class<code>。那么我们又怎么找出它使哪一类呢？Ruby在</code>Module<code>上定义了类似</code>&lt;=<code>这样的[用于比较的操作符](http://ruby-doc.org/core-1.9.3/Module.html#method-i-3C)。当操作符左边的对象是操作符右边对象的子类的时候，它会返回true。举个例子，</code>ActiveRecord::RecordNotFound &lt; Exception<code>返回true，而</code>ActiveRecord::RecordNotFound > Exception`返回false。</p>

<p>在这个方法的末尾，我们看到表示异常类的<code>String</code>对象稍后被储存在二元数组中：
<code>ruby
def rescue_from(*klasses, &amp;block)
  #...
  self.rescue_handlers += [[key, options[:with]]]
end
</code>
现在我们已经知道了处理器是如何储存的，但是当Rails需要处理异常的时候，它又是如何查找这些处理器的呢？</p>

<h3>查找处理器（Finding Handlers）</h3>

<p>经过对<code>rescue_handlers</code>的快速搜索发现，这一切使用到了<code>handler_for_rescue</code>。我们可以看到每一个可能的处理器都被一一检查，直到我们找到能够与<code>exception</code>匹配的处理器：
``` ruby
def handler_for_rescue(exception)
  # 我们遵循从右到左的顺序，是因为每当发现一个rescue_from声明的时候，
  # 相应的klass_name, handler对就会被压入resuce_handlers里。
  _, rescuer = self.class.rescue_handlers.reverse.detect do |klass_name, handler|</p>

<pre><code>#...
klass = self.class.const_get(klass_name) rescue nil
klass ||= klass_name.constantize rescue nil
exception.is_a?(klass) if klass
</code></pre>

<p>  end
  #&hellip;
<code>``
如同注释所言，</code>rescue_handlers<code>被反序读取。假如有两个处理器能够处理同一个异常，那么最后定义的处理器会被优先选中。假如你先定义了一个针对</code>ActiveRecord::NotFoundError<code>异常的处理器，接着又定义了针对</code>Exception<code>异常的处理器，那么前者将永远都不会被调用，因为针对</code>Exception`的处理器总是会优先匹配。</p>

<p>现在，在代码块里边，又发生了什么呢？</p>

<p>首先，字符串对象<code>klass_name</code>被当做当前类内部的常量进行查找，在找不到的情况下会继续判断它是不是定义在程序内部其他地方的常量，以此将<code>klass_name</code>转换为实际的类。每一步都通过返回<code>nil</code>进行rescue。这么做的一个原因就是当前处理器可能是针对某个尚未加载的异常的类型。举例来说，一个插件里可能为<code>ActiveRecord::NotFoundError</code>定义了错误处理，但是你可能并没有使用<code>ActiveRecord</code>。在这样的情况下，引用这个异常将会导致异常。每一行最后的<code>rescue nil</code>能够在无法找到类时无声无息地组织异常的抛出。</p>

<p>最后我们检查这个异常（等待匹配的异常）是否是这个处理器所对应异常类的实例。如果是，数组<code>[klass_name, handler]</code>将会被返回。返回到上边看看<code>_, rescuer = ...</code>这一行代码，这一一个数组拆分的例子。因为我们实际上只想要返回数组的第二个元素，也就是处理器，所以<code>_</code>在这里只是一个占位符。</p>

<h3>处理异常（Rescuing Exceptions)</h3>

<p>现在我们知道了程序是如何查找异常处理器的，但是它又是如何被调用的呢？为了回答这最后一个问题，我们可以返回到源代码文件的顶部然后探索一下<code>rescue_with_handler</code>方法。当给它传递一个异常的时候，它将会尝试通过调用合适的处理器来处理这个异常。
``` ruby
def rescue_with_handler(exception)
  if handler = handler_for_rescue(exception)</p>

<pre><code>handler.arity != 0 ? handler.call(exception) : handler.call
</code></pre>

<p>  end
end
<code>
为了了解这个方法是如何在你的controller里边生效的，我们需要查看ActionPack包里边的代码。（**提示**：可以在命令行中键入`qw actionpack`打开ActionPace的代码）Rails定义了一个叫做`ActionController::Rescue`的中间件，它被混入到了`Rescuable`模块里边，并且通过`precess_action`调用。
</code> ruby
def process_action(*args)
  super
rescue Exception => exception
  rescue_with_handler(exception) || raise(exception)
end
<code>``
Rails在收到每一个请求时都会调用</code>process_action<code>，假如请求导致一个异常即将被抛出，</code>rescue_with_handler`都会试图去处理这个异常。</p>

<h3>在Rails之外使用Rescuable（Using Rescuable Outside of Rails）</h3>

<p><code>Rescuable</code>能够被混入到其它代码之中。假如你想集中化你的异常处理部分的逻辑，那么你可以考虑一下使用<code>Rescuable</code>。举个例子，假如你有很多发向远程服务的请求，并且你不想在每一个方法里边重复异常处理的逻辑：
``` ruby
class RemoteService
  include Rescuable</p>

<p>  rescue_from Net::HTTPNotFound, Net::HTTPNotAcceptable do |ex|</p>

<pre><code>disable_service!
log_http_failure(@endpoint, ex)
</code></pre>

<p>  end</p>

<p>  rescue_from Net::HTTPNetworkAuthenticationRequired do |ex|</p>

<pre><code>authorize!
</code></pre>

<p>  end</p>

<p>  def get_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>  def update_status</p>

<pre><code>#...
</code></pre>

<p>  rescue Exception => exception</p>

<pre><code>rescue_with_handler(exception) || raise(exception)
</code></pre>

<p>  end</p>

<p>end
```
使用一点元编程的技巧，你甚至可以通过类似的模式对已有的方法进行封装以避免rescue代码块。</p>

<h3>总结（Recap）</h3>

<p>ActiveSupport的<code>Rescuable</code>模块允许我们定义异常处理方法。ActionController的<code>Rescue</code>中间件捕捉异常，并试图处理这些异常。
我们也同时了解到：</p>

<ul>
<li>一个签名类似<code>rescue_from(*klasses)</code>的方法可以接收数量不定的参数。</li>
<li><code>Array#extract_options!</code>方法是一个用于从arguments数组得到options的技巧。</li>
<li>你可以通过类似<code>klass &lt;= Exception</code>这样的代码判读一个类是否某个类的子类。</li>
<li><code>rescue nil</code>将会静默地消除异常。</li>
</ul>


<p>就算是再小的代码片段都包含了非常多有用的信息，请让我知道你下一步想要了解什么东西，我们还会看到能够从Rails里边挖掘到的新奇玩意。</p>

<h3>喜欢这篇文章？</h3>

<p><a href="/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
</feed>
