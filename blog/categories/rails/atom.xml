<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: rails | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/rails/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-02-18T12:40:00+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[嘿，小心你的双等号==]]></title>
    <link href="http://Martin91.github.io/blog/articles/2016/01/17/pay-attention-to-your-double-equals/"/>
    <updated>2016-01-17T01:40:48+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2016/01/17/pay-attention-to-your-double-equals</id>
    <content type="html"><![CDATA[<p>前两天在写代码的时候，突然收到警告说项目代码中存在 XSS 漏洞，遂立即根据报告的 URL 排查页面代码，虽然很快就修复了，而且同样问题的讨论两年前就有了，看<a href="https://ruby-china.org/topics/16633">RubyChina: 别用 raw 和 html_safe</a>，一般来说相对有经验的老鸟也应该都知道这个点，但是还是觉得有必要写出来，再次提醒一下其他小伙伴，避免踩坑。</p>

<!-- MORE -->


<h2>问题根源</h2>

<p>其中，在找到的漏洞出现的地方，都存在类似以下这样的 slim 代码：</p>

<p><code>ruby
input class='xxx' value==params[:account]
</code>
问题就出在双等号 <code>==</code> 上，因为在 <strong>slim</strong> 跟 <strong>ERB</strong> 模板（其他模板比如 HAML 之类的就不清楚了）中，双等号其实是 Rails 的 <code>raw</code> 这个 helper 方法的缩写，<a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html#output-safety">参考链接</a>：</p>

<blockquote><p>To insert something verbatim use the raw helper rather than calling html_safe:</p>

<pre><code>&lt;%= raw @cms.current_template %&gt; &lt;%# inserts @cms.current_template as is %&gt;
</code></pre>

<p>or, equivalently, use <code>&lt;%==</code>:</p>

<pre><code>&lt;%== @cms.current_template %&gt; &lt;%# inserts @cms.current_template as is %&gt;
</code></pre></blockquote>

<p>也就是说上面的代码等同于：</p>

<p><code>ruby
input class='xxx' value=raw(params[:account])
</code></p>

<p>其中 <code>raw</code> 方法在 <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw">Rails 文档</a>中的解释是这样子的：</p>

<blockquote><p>This method outputs without escaping a string. Since escaping tags is now default, this can be used when you don&rsquo;t want Rails to automatically escape tags. This is not recommended if the data is coming from the user&rsquo;s input.</p></blockquote>

<p>大概意思就是，这个方法将会跳过对传入的字符串进行标签过滤以及其他处理，直接将字符串输出到 HTML 中。<br/>
所以到现在原因就很清晰了，因为不小心在代码里多加了一个等号，变成了双等号，导致将会直接把用户的输入输出到待渲染的 HTML 中，在不自知的情况下留下了 XSS 漏洞。于是乎，修复方案仅需去掉一个等号即可：</p>

<p><code>ruby
input class='xxx' value=params[:account]
</code>
这样，Rails 就能继续自动过滤输入的 <code>:account</code> 的参数并且自动过滤恶意内容了。</p>

<h2>raw、String#html_safe 以及 &lt;%== %></h2>

<p>在查看 <code>raw</code> 方法的文档时，顺便看了其源码，极其简单，只有一行：</p>

<p>```ruby</p>

<h1>File actionview/lib/action_view/helpers/output_safety_helper.rb, line 16</h1>

<p>def raw(stringish)
  stringish.to_s.html_safe
end
<code>``
</code>raw<code>只是先确保将</code>stringish<code>参数转化为字符串，然后调用了 [</code>String#html_safe<code>](http://api.rubyonrails.org/classes/String.html#method-i-html_safe) 方法而已。而且在</code>String#html_safe` 的文档中，同样反复强调慎重使用这两个方法：</p>

<blockquote><p>It will be inserted into HTML with no additional escaping performed. It is your responsibilty to ensure that the string contains no malicious content. This method is equivalent to the <code>raw</code> helper in views.</p></blockquote>

<p>所以，可以总结一下，以下三种写法的代码都是等价的，都是不安全的：</p>

<p><code>ruby
input class='xxx' value==params[:account]
input class='xxx' value=raw(params[:account])
input class='xxx' value=params[:account].html_safe
</code>
那在切实需要输出包含 HTML 内容比如富文本编辑器编辑的内容时，如何保证安全？<br/>
方案很简单，只需要使用文档中推荐的 <a href="http://api.rubyonrails.org/classes/ActionView/Helpers/SanitizeHelper.html#method-i-sanitize"><code>sanitize</code></a> helper 方法：</p>

<blockquote><ol>
<li>It is recommended that you use <code>sanitize</code> instead of this method(html_safe).</li>
<li>(#sanitize)Sanitizes HTML input, stripping all tags and attributes that aren&rsquo;t whitelisted.</li>
</ol>
</blockquote>

<p>或者使用一些其他第三方的 gem 用来做过滤处理。</p>

<h2>总结</h2>

<ol>
<li>不要使用双等号缩写的方式，以避免其他人（比如项目里的 Rails 新手）在不了解的情况下照着滥用；</li>
<li>尽可能不用 <code>raw</code> helper 或者 <code>String#html_safe</code> 方法，尽可能使用 <code>#sanitize</code>；</li>
<li>多借助工具进行自动扫描，比如 <a href="http://brakemanscanner.org/"><code>brakeman</code></a>，能够快速高效检测出包括 XSS 漏洞在内的多种安全隐患。</li>
</ol>


<h2>参考链接</h2>

<ol>
<li><a href="https://ruby-china.org/topics/16633">别用 raw 和 html_safe</a></li>
<li><a href="http://brakemanscanner.org/">BrakemanScanner</a></li>
<li><a href="http://guides.rubyonrails.org/active_support_core_extensions.html#safe-strings">Rails Guides: Safe Strings</a></li>
<li><a href="http://wiki.open.qq.com/wiki/Web%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%8F%8A%E4%BF%AE%E5%A4%8D#1.2_XSS.E6.BC.8F.E6.B4.9E">腾讯开放平台：XSS漏洞</a></li>
<li><a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Wikipedia: Cross-site scripting</a></li>
<li><a href="http://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw">Rails API: #raw</a></li>
<li><a href="http://api.rubyonrails.org/classes/String.html#method-i-html_safe">Rails API: String#html_safe</a></li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谨防 ActiveSupport::Cache::Store 缓存 nil 值]]></title>
    <link href="http://Martin91.github.io/blog/articles/2015/10/30/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/"/>
    <updated>2015-10-30T20:48:41+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2015/10/30/jin-fang-activesupport-cache-store-huan-cun-nil-zhi</id>
    <content type="html"><![CDATA[<p>Rails 中的 <strong><a href="https://github.com/rails/rails/tree/master/activesupport">active_support</a></strong> 组件主要基于 Rails 需要提供了很多非常有用的基础工具以及对 Ruby 内置类进行扩展。其中的 cache 模块主要提供了 Rails 中底层缓存的定义以及简单实现。今天要跟大家探讨的是之前在使用此模块所遇到的一个坑，有兴趣学习其基本用法的可以点击以下两个链接：</p>

<ul>
<li><a href="http://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store">Rails Guides: ActiveSupport::Cache::Store</a></li>
<li><a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html">Rails API: ActiveSupport::Cache::Store</a></li>
</ul>


<!-- MORE -->


<h3>从 ActiveSupport::Cache::Store#fetch 聊起</h3>

<p>之前在实现一个需要从外部服务请求数据的功能时，处于性能考虑，我在代码中使用了缓存，并且设置缓存失效时间为 7 天，示例代码如下：</p>

<p>```ruby
def read_external_service(params)
  # 这段代码稍微解释下：
  #   当缓存命中时，则直接读取缓存，如果无期待缓存，则通过 HTTP 向外请求结果，并且将结果
  #   缓存下来，这样子，当下次继续调用时，则可直接返回缓存内容，而无需重复向外请求
  #
  Rails.cache.fetch &lsquo;example_cache_key_here&rsquo;, expires_in: 7.days do</p>

<pre><code>response = HTTParty.get 'https://example.com/example/request/path'
JSON.parse(response.body)["data"]
</code></pre>

<p>  end
end
<code>``
上面的代码其实不复杂，核心代码就是使用了 [</code>ActiveSupport::Cache::Store#fetch`](<a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch">http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch</a>) 方法。</p>

<p>一切都很正常地运行着，直到有一天，线上系统不断报警，出错原因就是这段代码总是返回 <code>nil</code> ，而调用者又因为没有判断 <code>nil</code> 值，就会出现 <code>undefined method 'xxx' for nil:NilClass</code> 错误。在 debug 时，我尝试了直接调用外部服务接口，发现请求都有正确返回数据，不可能返回 <code>nil</code> 啊，难道是缓存了 <code>nil</code> 值？下面就直接通过代码验证一下！</p>

<p><code>ruby
[1] pry(main)&gt; require 'active_support'
=&gt; true
[2] pry(main)&gt; cache = ActiveSupport::Cache::MemoryStore.new
=&gt; &lt;#ActiveSupport::Cache::MemoryStore entries=0, size=0, options={}&gt;
[3] pry(main)&gt; cache.read :nil_value
=&gt; nil
[4] pry(main)&gt; cache.exist? :nil_value
=&gt; false
[5] pry(main)&gt; cache.fetch :nil_value do
[5] pry(main)*   nil   # this `nil` value will be cached
[5] pry(main)* end
=&gt; nil
[6] pry(main)&gt; cache.read :nil_value
=&gt; nil
[7] pry(main)&gt; cache.exist? :nil_value
=&gt; true
</code>
看吧， <code>fetch</code> 方法确实会缓存 <code>nil</code> 值（通过 <code>exist?</code> 方法可以判断是否缓存了指定的 key ），所以系统出错原因就清晰了：在某次代码执行中，我的缓存刚好失效了，所以系统向外部发送了请求，恰巧这时候外部系统因为故障或者其他可能原因，没有返回期待数据，导致代码中最终缓存了 <code>nil</code> 值，在接下来的时间里，虽然外部系统可能恢复了正确服务，可是这时候因为我们的系统已经缓存了 <code>nil</code>值，所以在每次调用时都返回缓存的 <code>nil</code>，而不是重新请求正确结果，导致最后不停的报错告警。</p>

<p>这里插播一句，通过后来仔细查阅文档，才发现文档里已经注明：</p>

<blockquote><p>Nil values can be cached.</p></blockquote>

<p><strong>╮(╯▽╰)╭ 怪我咯~</strong></p>

<h3>解决方案</h3>

<p>意识到这个问题之后，解决思路简单粗暴，就是在可能返回 <code>nil</code> 值的地方放弃写入缓存：</p>

<p>```ruby
def read_external_service(params)
  cache_key = &lsquo;example_cache_key_here&rsquo;
  result = Rails.cache.read(cache_key)
  # 缓存命中，且内容不为 nil ，直接返回缓存内容
  return result if result.present?</p>

<p>  # 缓存失效，只能重新请求了~
  response = HTTParty.get &lsquo;<a href="https://example.com/example/request/path">https://example.com/example/request/path</a>&rsquo;
  result = JSON.parse(response.body)[&ldquo;data&rdquo;]</p>

<p>  # 请求结果正确，写入缓存；否则，放弃之~~~
  Rails.cache.write(cache_key, result, expires_in: 7.days) if result.present?
  result
end
```</p>

<p>呃~~~虽然解决问题了，可是，就为了告诉系统不要相信 <code>nil</code>，就写得这么繁琐，好么？好么？好么？</p>

<h3>踏上阅读源码之路</h3>

<p>我尝试搜索了 <code>#fetch</code> 方法是否有支持比如 <code>reject_nil</code> 这样的 option，可惜的是，没有！可是真的没有吗？我不信！看源码去！</p>

<p>首先还是拜访下 <a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L154"><code>ActiveSupport::Cache::Store</code></a> 这个类啦，它可是所有缓存实现类的抽象类，别问我抽象类是什么，就是它明明只说话不干活，但是其他干活的都得向它看齐！好啦，说人话，其实就是说，我们在调用 <code>Rails.cache.read</code>、<code>Rails.cache.fetch</code> 等读写方法时，这些方法都是在 <code>ActiveSupport::Cache::Store</code> 中定义的，但是它只定义逻辑，而实际底层的读写实现，则都是交由其各种子类实现的，比如前面的 <code>ActiveSupport::Cache::MemoryStore</code>。</p>

<p>首先让我们来看看 <a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L275"><code>fetch</code></a>方法的全部内容：</p>

<p>```ruby
def fetch(name, options = nil)
  if block_given?</p>

<pre><code>options = merged_options(options)
key = namespaced_key(name, options)

instrument(:read, name, options) do |payload|
  cached_entry = read_entry(key, options) unless options[:force]
  payload[:super_operation] = :fetch if payload
  entry = handle_expired_entry(cached_entry, key, options)

  if entry
    payload[:hit] = true if payload
    get_entry_value(entry, name, options)
  else
    payload[:hit] = false if payload
    save_block_result_to_cache(name, options) { |_name| yield _name }
  end
end
</code></pre>

<p>  else</p>

<pre><code>read(name, options)
</code></pre>

<p>  end
```</p>

<p>从代码中可以看到，当 <code>#fetch</code> 方法调用时没有传递 block 的话，它本质上就是 <code>read</code> 方法的别名而已。而当调用时传递了 block 的话，即如我前面的示例代码，让我们把代码分开看下：</p>

<p><code>ruby
cached_entry = read_entry(key, options) unless options[:force]
payload[:super_operation] = :fetch if payload
entry = handle_expired_entry(cached_entry, key, options)
</code>
它首先判断是否设置了 <code>force</code> 选项，如果有，则不读取缓存，由此模拟缓存强制失效；如果未设置 <code>force</code> 选项或者该选项不等于 true value，则尝试读取缓存，并且调用 <a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L564-L578"><code>handle_expired_entry</code></a>判断缓存是否仍旧有效。</p>

<p><code>ruby
if entry
  payload[:hit] = true if payload
  get_entry_value(entry, name, options)
</code>
这三行代码，则是在缓存命中时，直接读取缓存内容并且返回。</p>

<p><code>ruby
else
  payload[:hit] = false if payload
  save_block_result_to_cache(name, options) { |_name| yield _name }
end
</code>
<code>else</code> 的代码则表示，在缓存无命中时， <code>#fetch</code> 代码直接调用 <a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L585-L592"><code>#save_block_result_to_cache</code></a> 方法，并且向其传递了一个 block，这个 block 没有干别的事情，它只会执行我们传递给 <code>#fetch</code> 方法的 block，让我们接着往下看看相关的实现：</p>

<p>```ruby
def save_block_result_to_cache(name, options)
  result = instrument(:generate, name, options) do |payload|</p>

<pre><code>yield(name)
</code></pre>

<p>  end</p>

<p>  write(name, result, options)
  result
end
<code>``
可以看到，</code>#save_block_result_to_cache<code>方法首先执行传递进来的代码块，实际上也就是我们期待在缓存失效时执行的代码，而在获得执行结果</code>result<code>后，方法通过调用 [</code>#write<code>](https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L384-L391) 方法将结果写入缓存，最后将</code>result` 返回。</p>

<p>通过上面的源码分析，我们可以知道，当缓存失效时，<code>#fetch</code> 方法会直接将其代码块中的代码的返回值<strong>不加判断</strong>地写入缓存，并且返回该返回值。这里，或许我们可以做点什么，来实现我们想要支持 <code>:reject_nil</code> 的需求？</p>

<h3>支持 <code>:reject_nil</code> option</h3>

<p>为了支持 <code>:reject_nil</code>，我们只需要在写入缓存前判断是否真的需要 <code>nil</code> 值即可，于是我们只需要在 <code>#save_block_result_to_cache</code> 中加入 <code>#write</code> 的前置条件：</p>

<p>```ruby
def save_block_result_to_cache(name, options)
  result = instrument(:generate, name, options) do |payload|</p>

<pre><code>yield(name)
</code></pre>

<p>  end</p>

<p>  # options[:reject_nil] &amp;&amp; result.nil? 作为前置条件
  write(name, result, options) unless result.nil? &amp;&amp; options[:reject_nil]</p>

<p>  result
end
```</p>

<p>话不多说，让我们来重新试验一番：</p>

<p><code>ruby
[1] pry(main)&gt; require 'active_support'
=&gt; true
[2] pry(main)&gt; cache = ActiveSupport::Cache::MemoryStore.new
=&gt; &lt;#ActiveSupport::Cache::MemoryStore entries=0, size=0, options={}&gt;
[3] pry(main)&gt; cache.fetch :nil_key1 do
[3] pry(main)*   nil
[3] pry(main)* end
=&gt; nil
[4] pry(main)&gt; cache.exist? :nil_key1
=&gt; true
[5] pry(main)&gt; cache.fetch :nil_key2, reject_nil: true do
[5] pry(main)*   nil
[5] pry(main)* end
=&gt; nil
[6] pry(main)&gt; cache.exist? :nil_key2
=&gt; false
</code>
可以看到，当我们调用 <code>#fetch</code> 方法时，如果没有传递 <code>reject_nil: true</code>，则 <code>#fetch</code> 方法会默认缓存 <code>nil</code> 值；而如果我们设置 <code>reject_nil: true</code> 的话，则 <code>#fetch</code> 就会放弃写入 <code>nil</code> 值到缓存中。试验成功！！！</p>

<p>基于这样的实现，我的代码就又可以改为如下了：</p>

<p><code>``ruby
def read_external_service(params)
  # 所有改动只是加了一个</code>reject_nil: true`，多方便，妈妈再也不用担心我掉到坑里去了
  Rails.cache.fetch &lsquo;example_cache_key_here&rsquo;, expires_in: 7.days, reject_nil: true do</p>

<pre><code>response = HTTParty.get 'https://example.com/example/request/path'
JSON.parse(response.body)["data"]
</code></pre>

<p>  end
end
```</p>

<p>待会去给 Rails 提交 Pull Request 去 <strong>O(∩_∩)O~~</strong></p>

<h3>总结</h3>

<ul>
<li>缓存是好个东西，用得好能够让应用性能表现突飞猛进</li>
<li>要注意缓存写入的边界条件，要注意避免缓存了空值，但也并非所有空值都不能缓存（比如有些接口确实就是有可能返回空值嘛），具体看业务，没有绝对的要与不要，反正 <code>:reject_nil</code> 给你了，看你要不要</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解读Rails - 适配器模式]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/"/>
    <updated>2014-03-03T13:40:03+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;utm_medium=email">Reading Rails &ndash; The Adapter Pattern</a>，限于本人水平有限，翻译不当之处，敬请指教！</p>

<p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是<a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）</a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。</p>

<!-- MORE -->


<p>为了跟随本文的步骤，请使用<a href="https://github.com/adamsanderson/qwandry">qwandry</a>打开相关的代码库，或者直接在<a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github</a>上查看这些代码。</p>

<h3>适配器模式</h3>

<p><a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式</a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。</p>

<p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：
<code>ruby
def find_nearest_restaurant(locator)
  locator.nearest(:restaurant, self.lat, self.lon)
end
</code>
我们假设有一个针对<code>locator</code>的接口，但是如果我们想要<code>find_nearest_restaurant</code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：
``` ruby
def find_nearest_restaurant(locator)
  if locator.is_a? GeoFish</p>

<pre><code>locator.nearest(:restaurant, self.lat, self.lon)
</code></pre>

<p>  elsif locator.is_a? ActsAsFound</p>

<pre><code>locator.find_food(:lat =&gt; self.lat, :lon =&gt; self.lon)
</code></pre>

<p>  else</p>

<pre><code>raise NotImplementedError, "#{locator.class.name} is not supported."
</code></pre>

<p>  end
end
<code>``
这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许</code>find_nearest_restaurant<code>就是我们使用</code>locator`的唯一场景。</p>

<p>那假如你真的需要去支持一个新的<code>locator</code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现<code>find_nearest_hospital</code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。</p>

<p>在这个例子中，我们可以为<code>GeoFish</code>以及<code>ActsAsFound</code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：
``` ruby
def find_nearest_hospital(locator)
  locator.find :type => :hospital,</p>

<pre><code>           :lat =&gt; self.lat,
           :lon =&gt; self.lon
</code></pre>

<p>end</p>

<p>locator = GeoFishAdapter.new(geo_fish_locator)
find_nearest_hospital(locator)
```
特意假设的例子就到此为止，接下来让我们看看真实的代码。</p>

<h3>MultiJSON</h3>

<p><code>ActiveSupport</code>在做JSON格式的解码时，用到的是<code>MultiJSON</code>，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对<a href="https://github.com/ohler55/oj">oj</a>和<a href="https://github.com/brianmario/yajl-ruby">yajl</a>的适配器。
(<strong>提示</strong>: 可在命令行中输入<code>qw multi_json</code>查看源码。)
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Oj &lt; Adapter
  #...
  def load(string, options={})
    options[:symbol_keys] = options.delete(:symbolize_keys)
    ::Oj.load(string, options)
  end
  #...
</code></pre>

<p><code>
Oj的适配器修改了`options`哈希表，使用`Hash#delete`将`:symbolize_keys`项转换为Oj的`:symbol_keys`项：
</code> ruby
options = {:symbolize_keys => true}
options[:symbol_keys] = options.delete(:symbolize_keys) # => true
options                                                 # => {:symbol_keys=>true}
<code>``
接下来MultiJSON调用了</code>::Oj.load(string, options)<code>。MultiJSON适配后的API跟Oj原有的API非常相似，在此不必赘述。不过你是否注意到，Oj是如何引用的呢？</code>::Oj<code>引用了顶层的</code>Oj<code>类，而不是</code>MultiJson::Adapters::Oj`。</p>

<p>现在让我们看看MultiJSON又是如何适配Yajl库的：
``` ruby
module MultiJson
  module Adapters</p>

<pre><code>class Yajl &lt; Adapter
  #...
  def load(string, options={})
    ::Yajl::Parser.new(:symbolize_keys =&gt; options[:symbolize_keys]).parse(string)
  end
  #...
</code></pre>

<p><code>``
这个适配器从不同的方式实现了</code>load<code>方法。Yajl的方式是先创建一个解析器的实力，然后将传入的字符串</code>string<code>作为参数调用</code>Yajl::Parser#parse<code>方法。在</code>options<code>哈希表上的处理也略有不同。只有</code>:symbolize_keys`项被传递给了Yajl。</p>

<p>这些JSON的适配器看似微不足道，但是他们却可以让你随心所欲地在不同的库之间进行切换，而不需要在每一个解析JSON的地方更新代码。</p>

<h3>ActiveRecord</h3>

<p>很多JSON库往往都遵从相似的模式，这让适配工作变得相当轻松。但是如果你是在处理一些更加复杂的情况时，结果会是怎样？ActiveRecord包含了针对不同数据库的适配器。尽管PostgreSQL和MySQL都是SQL数据库，但是他们之间还是有很多不同之处，而ActiveRecord通过使用适配器模式屏蔽了这些不同。(<strong>提示</strong>: 命令行中输入<code>qw activerecord</code>查看ActiveRecord的代码)</p>

<p>打开ActiveRecord代码库中的<code>lib/connection_adapters</code>目录，里边会有针对PostgreSQL,MySQL以及SQLite的适配器。除此之外，还有一个名为<code>AbstractAdapter</code>的适配器，它作为每一个具体的适配器的基类。<code>AbstractAdapter</code>实现了在大部分数据库中常见的功能，这些功能在其子类比如<code>PostgreSQLAdapter</code>以及<code>AbstractMysqlAdapter</code>中被重新定制，而其中<code>AbstractMysqlAdapter</code>则是另外两个不同的MySQL适配器——MysqlAdapter以及Mysql2Adapter——的父类。让我们通过一些真实世界中的例子来看看他们是如何一起工作的。</p>

<p>PostgreSQL和MySQL在SQL方言的实现稍有不同。查询语句<code>SELECT * FROM users</code>在这两个数据库都可以正常执行，但是它们在一些类型的处理上会稍显不同。在MySQL和PostgreSQL中，时间格式就不尽相同。其中，PostgreSQL支持微秒级别的时间，而MySQL只是到了最近的一个稳定发布的版本中才支持。那这两个适配器又是如何处理这种差异的呢？</p>

<p>ActiveRecord通过被混入到<code>AbstractAdapter</code>的<code>ActiveRecord::ConnectionAdapters::Quoting</code>中的<code>quoted_date</code>引用日期。而<code>AbstractAdapter</code>中的实现仅仅只是格式化了日期：
<code>ruby
def quoted_date(value)
  #...
  value.to_s(:db)
end
</code>
Rails中的ActiveSupport扩展了<code>Time#to_s</code>，使其能够接收一个代表格式名的符号类型参数。<code>:db</code>所代表的格式就是<code>%Y-%m-%d %H:%M:%S</code>：
``` ruby</p>

<h1>Examples of common formats:</h1>

<p>Time.now.to_s(:db)      #=> &ldquo;2014-02-19 06:08:13&rdquo;
Time.now.to_s(:short)   #=> &ldquo;19 Feb 06:08&rdquo;
Time.now.to_s(:rfc822)  #=> &ldquo;Wed, 19 Feb 2014 06:08:13 +0000&rdquo;
<code>
MySQL的适配器都没有重写`quoted_date`方法，它们自然会继承这种行为。另一边，`PostgreSQLAdapter`则对日期的处理做了两个修改：
</code> ruby
def quoted_date(value)
  result = super
  if value.acts_like?(:time) &amp;&amp; value.respond_to?(:usec)</p>

<pre><code>result = "#{result}.#{sprintf("%06d", value.usec)}"
</code></pre>

<p>  end</p>

<p>  if value.year &lt; 0</p>

<pre><code>result = result.sub(/^-/, "") + " BC"
</code></pre>

<p>  end
  result
end
<code>``
它在一开始便调用</code>super<code>方法，所以它也会得到一个类似MySQL中格式化后的日期。接下来，它检测</code>value<code>是否像是一个具体时间。这是一个ActiveSupport中扩展的方法，当一个对象类似</code>Time<code>类型的实例时，它会返回</code>true<code>。这让它更容易表明各种对象已被假设为类似</code>Time<code>的对象。（**提示**: 对</code>acts_like?<code>方法感兴趣？请在命令行中执行</code>qw activesupport<code>，然后阅读</code>core_ext/object/acts_like.rb`）</p>

<p>第二部分的条件检查<code>value</code>是否有用于返回毫秒的<code>usec</code>方法。如果可以求得毫秒数，那么它将通过<code>sprintf</code>方法被追加到<code>result</code>字符串的末尾。跟很多时间格式一样，<code>sprintf</code>也有很多不同的方式用于格式化数字：
<code>ruby
sprintf("%06d", 32) #=&gt; "000032"
sprintf("%6d",  32) #=&gt; "    32"
sprintf("%d",   32) #=&gt; "32"
sprintf("%.2f", 32) #=&gt; "32.00"
</code>
最后，假如日期是一个负数，<code>PostgreSQLAdapter</code>就会通过加上"BC"去重新格式化日期，这是PostgreSQL数据库的实际要求：
<code>ruby
SELECT '2000-01-20'::timestamp;
-- 2000-01-20 00:00:00
SELECT '2000-01-20 BC'::timestamp;
-- 2000-01-20 00:00:00 BC
SELECT '-2000-01-20'::timestamp;
-- ERROR:  time zone displacement out of range: "-2000-01-20"
</code>
这只是ActiveRecord适配多个API时的一个极小的方式，但它却能帮助你免除由于不同数据库的细节所带来的差异和烦恼。</p>

<p>另一个体现SQL数据库的不同点是数据库表被创建的方式。MySQL以及PostgreSQL中对主键的处理各不相同：
``` ruby</p>

<h1>AbstractMysqlAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  :primary_key => &ldquo;int(11) DEFAULT NULL auto_increment PRIMARY KEY&rdquo;,
  #&hellip;
}</p>

<h1>PostgreSQLAdapter</h1>

<p>NATIVE_DATABASE_TYPES = {
  primary_key: &ldquo;serial primary key&rdquo;,
  #&hellip;
}
```
这两种适配器都能够明白ActiveRecord中的主键的表示方式，但是它们会在创建新表的时候将此翻译为不同的SQL语句。当你下次在编写一个migration或者执行一个查询的时候，思考一下ActiveRecord的适配器以及它们为你做的所有微小的事情。</p>

<h3>DateTime和Time</h3>

<p>当MultiJson以及ActiveRecord实现了传统的适配器的时候，Ruby的灵活性使得另一种解决方案成为可能。<code>DateTime</code>以及<code>Time</code>都用于表示时间，但是它们在内部的处理上是不同的。虽然有着这些细微的差异，但是它们所暴露出来的API却是极其类似的（<strong>提示</strong>：命令行中执行<code>qw activesupport</code>查看此处相关代码）：
``` ruby
t = Time.now
t.day     #=> 19         (Day of month)
t.wday    #=> 3          (Day of week)
t.usec    #=> 371552     (Microseconds)
t.to_i    #=> 1392871392 (Epoch secconds)</p>

<p>d = DateTime.now
d.day     #=> 19         (Day of month)
d.wday    #=> 3          (Day of week)
d.usec    #=> NoMethodError: undefined method <code>usec'
d.to_i    #=&gt; NoMethodError: undefined method</code>to_i'
<code>
ActiveSupport通过添加缺失的方法来直接修改`DateTime`和`Time`，进而抹平了两者之间的差异。从实例上看，这里就有一个例子演示了ActiveSupport如何定义`DateTime#to_i`：
</code> ruby
class DateTime
  def to_i</p>

<pre><code>seconds_since_unix_epoch.to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_unix_epoch</p>

<pre><code>(jd - 2440588) * 86400 - offset_in_seconds + seconds_since_midnight
</code></pre>

<p>  end</p>

<p>  def offset_in_seconds</p>

<pre><code>(offset * 86400).to_i
</code></pre>

<p>  end</p>

<p>  def seconds_since_midnight</p>

<pre><code>sec + (min * 60) + (hour * 3600)
</code></pre>

<p>  end
end
<code>``
每一个用于支持的方法，</code>seconds_since_unix_epoch<code>，</code>offset_in_seconds<code>，以及</code>seconds_since_midnight<code>都使用或者扩展了</code>DateTime<code>中已经存在的API去定义与</code>Time`中匹配的方法。</p>

<p>假如说我们前面所看到的适配器是相对于被适配对象的外部适配器，那么我们现在所看到的这个就可以被称之为内部适配器。与外部适配器不同的是，这种方法受限于已有的API，并且可能导致一些麻烦的矛盾问题。举例来说，<code>DateTime</code>和<code>Time</code>在一些特殊的场景下就有可能出现不一样的行为：
<code>ruby
datetime == time #=&gt; true
datetime + 1     #=&gt; 2014-02-26 07:32:39
time + 1         #=&gt; 2014-02-25 07:32:40
</code>
当加上1的时候，<code>DateTime</code>加上了一天，而<code>Time</code>则是加上了一秒。当你需要使用它们的时候，你要记住ActiveSupport基于这些不同，提供了诸如<code>change</code>和<code>Duration</code>等保证一致行为的方法或类。</p>

<p>这是一个好的模式吗？它理所当然是方便的，但是如你刚才所见，你仍旧需要注意其中的一些不同之处。</p>

<h3>总结</h3>

<p>设计模式不是只有Java才需要的。Rails通过使用设计模式以提供用于JSON解析以及数据库维护的统一接口。由于Ruby的灵活性，类似<code>DateTime</code>以及<code>Time</code>这样的类可以被直接地修改而提供相似的接口。Rails的源码就是一个可以让你挖掘真实世界中不同设计模式实例的天堂。</p>

<p>在这次的实践中，我们同时也发掘了一些有趣的代码：</p>

<ul>
<li><code>hash[:foo] = hash.delete(:bar)</code>是一个用于重命名哈希表中某一项的巧妙方法。</li>
<li>调用<code>::ClassName</code>会调用顶层的类。</li>
<li>ActiveSupport为<code>Time</code>、<code>Date</code>以及其他的类添加了一个可选的代表格式的参数<code>format</code>。</li>
<li><code>sprintf</code>可以用于格式化数字。</li>
</ul>


<p>想要探索更多的知识？回去看看MultiJson是如何处理以及解析格式的。仔细阅读你在你的数据库中所使用到的ActiveRecord的适配器的代码。浏览ActiveSupport中用于xml适配器的<code>XmlMini</code>，它跟MultiJson中的JSON适配器是类似的。在这些里面还会有很多可以学习的。</p>

<p>喜欢这篇文章？<br>
<a href="/blog/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读另外8篇</a>“解读Rails”中的文章。</p>
]]></content>
  </entry>
  
</feed>
