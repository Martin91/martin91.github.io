<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: hash | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/hash/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-15T15:52:54+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby中Hash的7个日常使用范例]]></title>
    <link href="http://Martin91.github.io/blog/articles/2014/03/25/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/"/>
    <updated>2014-03-25T20:05:56+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2014/03/25/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li</id>
    <content type="html"><![CDATA[<p>此文翻译自<a href="http://blog.8thcolor.com/en/2014/03/7-daily-use-cases-of-ruby-hash/?utm_source=rubyweekly&amp;utm_medium=email#json-to-hash">7 daily use cases of Ruby Hash</a>，限于本人水平，翻译不当之处，敬请指教！</p>

<p>每一天，你都需要跟Hash相处。创建一个新的Hash或者是通过它的某一个键去检索其中的元素这样的工作，都是常见也是非常简单的。但是当你需要合并两个嵌套的Hash或者是从某一个Hash里边过滤某些键，你可能需要考虑得多一点。通过完整的<a href="http://ruby-doc.org/">文档</a>，你可以找到对Hash中的每一个方法的充分解释。但是由于文档不是面向应用场景的，你可能没法很快找到你的解决方案。在下面，我分享了我日常中经常遇到的Hash中的7个常用场景，希望它们对你有用。</p>

<!-- More -->


<h2>1. 如何将一个JSON转换为一个Hash？</h2>

<p>假设你刚刚接收到一个用JSON表示的Twitter账号的资料信息：
<code>json
data = '{
  "name": "Aaron Patterson",
  "screen_name": "tenderlove",
  "location": "Seattle, WA"
}'
</code>
你希望能够将它转化为一个Hash,这样会更方便你进行对数据的操作：
``` ruby
require &lsquo;json&rsquo;</p>

<p>profile = JSON.parse(data)
<code>
** 在IRB中的输出结果：**
</code> ruby
=> {
  &ldquo;name&rdquo;=>&ldquo;Aaron Patterson&rdquo;,
  &ldquo;screen_name&rdquo;=>&ldquo;tenderlove&rdquo;,
  &ldquo;location&rdquo;=>&ldquo;Seattle, WA&rdquo;
}
```
查看文档：<a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-parse">JSON#parse</a></p>

<h2>2. 如何将一个Hash转换为一个JSON？</h2>

<p>在你的web应用程序中，你需要追踪当前星期每一天新注册用户的数量：
``` ruby
signups_of_the_week = {</p>

<pre><code>monday: 2,
tuesday: 3,
wednesday: 4,
thursday: 20,
friday: 5,
saturday: 2,
sunday: 5
</code></pre>

<p>}
<code>
你可以通过API的方式把它们以JSON格式提供给客户端：
</code> ruby
require &lsquo;json&rsquo;</p>

<p>signups_of_the_week.to_json
<code>
** 在IRB中的输出结果：**
</code> ruby
=> &ldquo;{\"monday\&rdquo;:2,\&ldquo;tuesday\&rdquo;:3,\&ldquo;wednesday\&rdquo;:4,\&ldquo;thursday\&rdquo;:20,\&ldquo;friday\&rdquo;:5,\&ldquo;saturday\&rdquo;:2,\&ldquo;sunday\&rdquo;:5}&ldquo;
```
查看文档：<a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-generate">JSON#generate</a>
边注：<a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-pretty_generate">JSON#pretty_generate</a>对于更好的打印以及调试非常有用。</p>

<h2>3. 如何为一个嵌套的Hash设置默认值？</h2>

<p>你有一个以name为索引的联系人的集合，也就是一个嵌套的Hash：
``` ruby
contacts = {
  &lsquo;John&rsquo; => {</p>

<pre><code>name: 'John',
email: 'john@doe.com'
</code></pre>

<p>  },
  &lsquo;Freddy&rsquo; => {</p>

<pre><code>name 'Freddy',
email: 'freddy@mercury.com'
</code></pre>

<p>  }
}
<code>
当你在处理单个联系人的时候，你不需要每一次都检查它是否存在。你只需要写：
</code> ruby
contacts[&lsquo;Jane&rsquo;][:email] = &lsquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x6a;&#97;&#110;&#x65;&#64;&#x64;&#111;&#x65;&#46;&#99;&#111;&#109;">&#x6a;&#97;&#110;&#101;&#64;&#x64;&#x6f;&#x65;&#x2e;&#x63;&#x6f;&#x6d;</a>&rsquo;
puts contacts[&lsquo;Jane&rsquo;]
<code>
** IRB输出 **:
</code> ruby
=> {:name=>&ldquo;Jane&rdquo;, :email=>&ldquo;<a href="&#109;&#x61;&#x69;&#108;&#x74;&#x6f;&#x3a;&#106;&#97;&#x6e;&#101;&#64;&#100;&#111;&#101;&#x2e;&#99;&#111;&#x6d;">&#x6a;&#97;&#x6e;&#101;&#64;&#x64;&#x6f;&#x65;&#46;&#99;&#x6f;&#109;</a>&rdquo;}
<code>
你可以在创建Hash的时候通过设置代码块来实现默认值：
</code> ruby
contacts = Hash.new do |hsh, key|
  hsh[key] = {</p>

<pre><code>name: key,
email: ''
</code></pre>

<p>  }
end
<code>
或者是使用：
</code> ruby
contacts.default_proc = Proc.new do |hsh, key|
  hsh[key] = {
    name: key,
    email: &lsquo;&rsquo;
  }
end
```
查看文档：<a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-c-new">Hash#new</a>, <a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-default_proc-3D">Hash#default_proc</a></p>

<h2>4. 如何合并两个嵌套的Hash？</h2>

<p>在一个在线商店里，你想要将一个心愿单与当前的购物篮进行合并，这两者都是以商品的id号作为索引：
<code>ruby
wish_list = {
  8 =&gt; {
    title: "The Color of Magic",
  },
  42 =&gt; {
    title: "The Hitch-Hiker's Guide to the Galaxy",
    price: 5
  }
}
 
basket = {
  8 =&gt; {
    price: 10
  },
  1729 =&gt; {
    title: "Ramanujan:  Twelve Lectures on Subjects Suggested by His Life and Work",
  price: 28
  }
}
</code>
借助于ActiveSupport,你可以简单地实现你的目标：
<code>ruby
require 'active_support/core_ext/hash' # not necessary if in Rails
 
basket.deep_merge(wish_list)
</code>
又或者，在没有ActiveSupport的情况下：
<code>ruby
def deep_merge(h1, h2)
  h1.merge(h2) { |key, h1_elem, h2_elem| deep_merge(h1_elem, h2_elem) }
end
 
deep_merge(basket, wish_list)
</code>
<strong> IRB输出: </strong>
<code>ruby
=&gt; {
  8=&gt;{:price=&gt;10, :title=&gt;"The Color of Magic"},
  1729=&gt;{:title=&gt;"Ramanujan:  Twelve Lectures on Subjects Suggested by His Life and Work", :price=&gt;28},
  42=&gt;{:title=&gt;"The Hitch-Hiker's Guide to the Galaxy", :price=&gt;5}
}
</code>
查看文档：<a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-merge">Hash#merge</a>, <a href="http://api.rubyonrails.org/classes/Hash.html#method-i-deep_merge">Hash#deep_merge</a></p>

<h2>5. 如何过滤掉一个Hash中的某些key？</h2>

<p>你已经创建了一个表示日销售额的矩形图，并且你将它以Hash的方式存储，每一天就是一个key：
<code>ruby
histogram = {
  monday: 5,
  tuesday: 7,
  wednesday: 10,
  thursday: 18,
  friday: 7,
  saturday: 2,
  sunday: 0
}
</code>
你想从中过滤掉Saturday以及Sunday。通过ActiveSupport，你可以像下面这样做：
<code>ruby
require 'active_support/core_ext/hash' # not necessary if Rails
 
histogram.except(:saturday, :sunday)
</code>
或者在没有ActiveSupport的情况下：
<code>ruby
def filter(hsh, *keys)
  hsh.dup.tap do |h|
    keys.each { |k| h.delete(k) }
  end
end
 
filter(histogram, :saturday, :sunday)
</code>
另一个简洁点实现则是基于<code>reject</code>方法的：
<code>ruby
def filter2(hsh, *keys)
  hsh.reject { |k, _| keys.include? k }
end
</code>
请注意，如果你正在处理一个比较大的集合，你最好是先衡量下你的实现，一次选择最好的其中一个实现。
<strong> IRB输出：</strong>
<code>ruby
=&gt; {:monday=&gt;5, :tuesday=&gt;7, :wednesday=&gt;10, :thursday=&gt;18, :friday=&gt;7}
</code>
查看文档：<a href="http://api.rubyonrails.org/classes/Hash.html#method-i-except">Hash#except</a>, <a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-delete">Hash#delete</a>, <a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-reject">Hash#reject</a>, <a href="http://www.ruby-doc.org/core-2.1.0/Object.html#method-i-dup">Object#dup</a>, <a href="http://www.ruby-doc.org/core-2.1.0/Object.html#method-i-tap">Object#tap</a></p>

<h2>6. 如何通过value对一个Hash进行“排序”？</h2>

<p>在一个骰子类游戏中，你在Hash中储存了每一个选手的得分：
<code>ruby
scores = {
  'The Lady' =&gt; 3,
  'Fate' =&gt; 2,
  'Death' =&gt; 10
}
</code>
你想要通过他们的得分对他们进行排序。你可以这样做：
<code>ruby
leaderboard = scores.sort_by { |_, score| -score }
</code>
<strong> IRB输出：</strong>
<code>ruby
=&gt; [["Death", 10], ["The Lady", 3], ["Fate", 2]]
</code>
查看文档：<a href="http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-sort_by">Enumerable#sort_by</a>
边注：Hash通过元素插入时的顺序去枚举它们的值。</p>

<h2>7. 如何找出两个Hash中的不同？</h2>

<p>假设你定期地从RSS订阅源中读取数据，并且将他们放在了一个Hash里边：
<code>ruby
entries = {
  1372284000 =&gt; "CVE-2013-4073",
  1368482400 =&gt; "CVE-2013-2065"
}
</code>
当你更新了之后，你可能得到另一个Hash：
<code>ruby
updated_entries = {
  1385074800 =&gt; "CVE-2013-4164",
  1372284000 =&gt; "CVE-2013-4073",
  1368482400 =&gt; "CVE-2013-2065"
}
</code>
你想要查找出哪一条记录才是新加的，这样你就可以通过email的方式将它们发送出去。最好的解决方案是：
<code>ruby
new_entries = updated_entries.reject { |k, _| entries.include? k }
</code>
<strong> IRB输出：</strong>
<code>ruby
=&gt; {1385074800=&gt;"CVE-2013-4164"}
</code>
查看文档：<a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-include-3F">Hash#include?</a></p>
]]></content>
  </entry>
  
</feed>
