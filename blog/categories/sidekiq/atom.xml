<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sidekiq | Martin]]></title>
  <link href="http://Martin91.github.io/blog/categories/sidekiq/atom.xml" rel="self"/>
  <link href="http://Martin91.github.io/"/>
  <updated>2017-10-19T07:58:44+08:00</updated>
  <id>http://Martin91.github.io/</id>
  <author>
    <name><![CDATA[Martin]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sidekiq 信号处理源码分析]]></title>
    <link href="http://Martin91.github.io/blog/articles/2016/11/20/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/"/>
    <updated>2016-11-20T10:08:07+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2016/11/20/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi</id>
    <content type="html"><![CDATA[<h3>引言</h3>

<p>在之前的文章<a href="/blog/articles/2016/10/29/sidekiqren-wu-diao-du-liu-cheng-fen-xi/">《Sidekiq任务调度流程分析》</a>中，我们一起仔细分析了 Sidekiq 是如何基于多线程完成队列任务处理以及调度的。我们在之前的分析里，看到了不管是 <code>Sidekiq::Scheduled::Poller</code> 还是 <code>Sidekiq::Processor</code> 的核心代码里，都会有一个由 <code>@done</code> 实例变量控制的循环体：</p>

<!-- More -->


<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73</a></h1>

<p>def start
  @thread ||= safe_thread(&ldquo;scheduler&rdquo;) do</p>

<pre><code>initial_wait

while !@done           # 这是 poller 的循环控制
  enqueue
  wait
end
Sidekiq.logger.info("Scheduler exiting...")
</code></pre>

<p>  end
end
```</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77</a></h1>

<p>def run
  begin</p>

<pre><code>while !@done           # 这是我们常说的 worker 循环控制
  process_one
end
@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Sidekiq::Shutdown</p>

<pre><code>@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Exception => ex</p>

<pre><code>@mgr.processor_died(self, ex)
</code></pre>

<p>  end
end
```</p>

<p>也就是说，这些 <code>@done</code> 实例变量决定了 <code>poller</code> 线程跟 <code>worker</code> 线程是否循环执行？一旦 <code>@done</code> 被改为 <code>true</code>，那循环体就不再执行，线程自然也就是退出了。于是，单从这些代码，我们可以断定， Sidekiq 就是通过设置 <code>@done</code> 的值来通知一个线程安全退出（graceful exit）的。我们也知道，生产环境中，我们是通过发送信号的方式来告诉 sidekiq 退出或者进入静默(quiet)状态的，那么，这里的 <code>@done</code> 是怎么跟信号处理联系起来的呢？这些就是今天这篇文章的重点了！</p>

<h3>注意</h3>

<ol>
<li>今天的分析所参考的 sidekiq 的源码对应版本是 4.2.3；</li>
<li>今天所讨论的内容，将主要围绕系统信号处理进行分析，无关细节将不赘述，如有需要，请自行翻阅 sidekiq 源码；</li>
<li>今天的文章跟上篇的《Sidekiq任务调度流程分析》紧密相关，上篇文章介绍的启动过程跟任务调度会帮助这篇文章的理解，如果还没有阅读上篇文章的，建议先阅读后再来阅读这一篇信号处理的文章。</li>
</ol>


<h3>你将了解到什么？</h3>

<ol>
<li>Sidekiq 信号处理机制；</li>
<li>为什么重启 Sidekiq 时，<code>USR1</code> 信号（即进入 <code>quiet</code> 模式）需要尽可能早，而进程的退出重启需要尽可能晚。</li>
</ol>


<h3>从头再来</h3>

<p>因为前一篇文章着眼于任务调度，所以略过了其他无关细节，包括信号处理，这篇文章则将镜头对准信号处理，所以让我们从头再来一遍，只是这一次，我们只关心与信号处理有关的代码。</p>

<p>依旧是从 <code>cli.rb</code> 文件开始，它是 Sidekiq 核心代码的生命起点，因为 Sidekiq 命令行启动后，它是第一个被执行的代码，Sidekiq 启动过程中调用了 <code>Sidekiq::CLI#run</code> 方法：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L49-L106">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L49-L106</a></h1>

<p>def run
  boot_system
  print_banner</p>

<p>  self_read, self_write = IO.pipe</p>

<p>  %w(INT TERM USR1 USR2 TTIN).each do |sig|</p>

<pre><code>begin
  trap sig do
    self_write.puts(sig)
  end
rescue ArgumentError
  puts "Signal #{sig} not supported"
end
</code></pre>

<p>  end</p>

<p>  # &hellip; other codes</p>

<p>  begin</p>

<pre><code>launcher.run

while readable_io = IO.select([self_read])
  signal = readable_io.first[0].gets.strip
  handle_signal(signal)
end
</code></pre>

<p>  rescue Interrupt</p>

<pre><code>logger.info 'Shutting down'
launcher.stop
# Explicitly exit so busy Processor threads can't block
# process shutdown.
logger.info "Bye!"
exit(0)
</code></pre>

<p>  end
<code>``
以上的代码就是整个 Sidekiq 最顶层的信号处理的核心代码了，让我们慢慢分析！
首先，</code>self_read, self_write = IO.pipe<code>创建了一个模拟管道的 IO 对象，并且同时返回这个 管道的一个写端以及一个读端，通过这两端，就可以实现对管道的读写了。需要注意的是，</code>IO.pipe<code>创建的读端在读的时候不会自动生成</code>EOF<code>符，所以这就要求读时，写端是关闭的，而写时，读端是关闭的，一句话说，就是这样的管道不允许读写端同时打开。关于</code>IO.pipe` 还有挺多细节跟需要注意的点，如果还需要了解，请阅读<a href="https://ruby-doc.org/core-2.3.1/IO.html#method-c-pipe">官方文档</a>。</p>

<p>上面说的管道本质上只是一个 IO 对象而已，暂时不用纠结太多，让我们接着往下读：
```ruby
%w(INT TERM USR1 USR2 TTIN).each do |sig|
  begin</p>

<pre><code>trap sig do
  self_write.puts(sig)
end
</code></pre>

<p>  rescue ArgumentError</p>

<pre><code>puts "Signal #{sig} not supported"
</code></pre>

<p>  end
end
<code>``
这段代码就比较有意思了，最外层遍历了一个系统信号的数组，然后逐个信号进行监听（trap，或者叫捕捉？）。让我们聚焦在</code>trap<code>方法的调用跟其 block 上，查阅 [Ruby 文档](https://ruby-doc.org/core-2.2.0/Signal.html#method-c-trap)，发现</code>trap<code>是</code>Signal<code>模块下的一个方法，</code>Signal<code>主要是处理与系统信号有关的任务，然后</code>trap` 的作用是：</p>

<blockquote><p>Specifies the handling of signals. The first parameter is a signal name (a string such as “SIGALRM”, “SIGUSR1”, and so on) or a signal number&hellip;</p></blockquote>

<p>所以，前面的那段代码的意思就很容易理解了，Sidekiq 注册了对 <code>INT</code>、<code>TERM</code>、<code>USR1</code>、<code>USR2</code>以及<code>TTIN</code>等系统信号的处理，而在进程收到这些信号时，就会执行 <code>self_write.puts(sig)</code>，也就是将收到的信号通过之前介绍的管道写端 <code>self_write</code> 记录下来。什么？只记录下来，那还得处理啊？！</p>

<p>稍安勿躁，让我们接着往下分析 <code>Sidekiq::CLI#run</code> 方法末尾的代码：</p>

<p>```ruby
begin
  launcher.run</p>

<p>  while readable_io = IO.select([self_read])</p>

<pre><code>signal = readable_io.first[0].gets.strip
handle_signal(signal)
</code></pre>

<p>  end
rescue Interrupt
  logger.info &lsquo;Shutting down&rsquo;
  launcher.stop
  # Explicitly exit so busy Processor threads can&rsquo;t block
  # process shutdown.
  logger.info &ldquo;Bye!&rdquo;
  exit(0)
end
<code>``
看到没有，这里有个循环，循环控制条件里，</code>readable_io = IO.select([self_read])<code>是从前面的管道的读端</code>self_read<code>阻塞地等待信号的到达。对于</code>IO.select`，<a href="https://ruby-doc.org/core-2.3.1/IO.html#method-c-select">Ruby 官方文档</a>介绍如下：</p>

<blockquote><p>Calls select(2) system call. It monitors given arrays of IO objects, waits until one or more of IO objects are ready for reading, are ready for writing, and have pending exceptions respectively, and returns an array that contains arrays of those IO objects.</p></blockquote>

<p>所以这里就是说 Sidekiq 主线程首先负责执行完其他初始化工作，最后阻塞在信号等待以及处理。在其等到新的信号之后，进入上面代码展示的循环体：</p>

<p><code>ruby
signal = readable_io.first[0].gets.strip
handle_signal(signal)
</code>
这里语法细节先不深究，我们看下这两行代码第一行是从前面说的管道中读取信号，并且将信号传递给 <code>handle_signal</code> 方法，让我们接着往下看 <code>handle_signal</code> 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L125-L153">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L125-L153</a></h1>

<p>def handle_signal(sig)
  Sidekiq.logger.debug &ldquo;Got #{sig} signal&rdquo;
  case sig
  when &lsquo;INT&rsquo;</p>

<pre><code># Handle Ctrl-C in JRuby like MRI
# http://jira.codehaus.org/browse/JRUBY-4637
raise Interrupt
</code></pre>

<p>  when &lsquo;TERM&rsquo;</p>

<pre><code># Heroku sends TERM and then waits 10 seconds for process to exit.
raise Interrupt
</code></pre>

<p>  when &lsquo;USR1&rsquo;</p>

<pre><code>Sidekiq.logger.info "Received USR1, no longer accepting new work"
launcher.quiet
</code></pre>

<p>  when &lsquo;USR2&rsquo;</p>

<pre><code>if Sidekiq.options[:logfile]
  Sidekiq.logger.info "Received USR2, reopening log file"
  Sidekiq::Logging.reopen_logs
end
</code></pre>

<p>  when &lsquo;TTIN&rsquo;</p>

<pre><code>Thread.list.each do |thread|
  Sidekiq.logger.warn "Thread TID-#{thread.object_id.to_s(36)} #{thread['label']}"
  if thread.backtrace
    Sidekiq.logger.warn thread.backtrace.join("\n")
  else
    Sidekiq.logger.warn "&lt;no backtrace available&gt;"
  end
end
</code></pre>

<p>  end
end
```
这里的代码挺长，但是一点都不难理解，我简单解释下就够了。当进程：</p>

<ol>
<li>收到 <code>TERM</code> 或者 <code>INT</code>信号时，直接抛出 <code>Interrupt</code> 中断；</li>
<li>收到 <code>USR1</code> 信号时，则通知 <code>launcher</code> 执行 <code>.quiet</code> 方法，Sidekiq 在这里进入 Quiet 模式（怎么进入？）；</li>
<li>收到 <code>USR2</code> 信号时，重新打开日志；</li>
<li>收到 <code>TTIN</code> 信号时，打印所有线程当前正在执行的代码列表。</li>
</ol>


<p>到此，一个信号从收到被存下，到被取出处理的大致过程就是这样的，至于具体的处理方式，我们下个章节详细展开。现在有一点需要补充的是，上面讲当 Sidekiq 收到 <code>TERM</code> 或者 <code>INT</code> 信号时，都会抛出 <code>Interrupt</code> 中断异常，那这个异常又是如何处理的呢？我们回过头去看刚才最开始的 <code>Sidekiq::CLI#run</code> 方法末尾的代码：</p>

<p>```ruby
begin
  launcher.run</p>

<p>  while readable_io = IO.select([self_read])</p>

<pre><code>signal = readable_io.first[0].gets.strip
handle_signal(signal)
</code></pre>

<p>  end
rescue Interrupt
  logger.info &lsquo;Shutting down&rsquo;
  launcher.stop
  # Explicitly exit so busy Processor threads can&rsquo;t block
  # process shutdown.
  logger.info &ldquo;Bye!&rdquo;
  exit(0)
end
<code>``
原来是</code>run<code>方法在处理信号时，声明了</code>rescue Interrupt<code>，捕捉了</code>Interrupt<code>中断异常，并且在异常处理时打印必要日志，同时执行</code>launcher.stop<code>通知各个线程停止工作，最后调用</code>exit<code>方法强制退出进程，到此，一个 Sidekiq 进程就彻底退出了。
但是问题又来了，信号处理的大致过程我是知道了，但是具体的</code>launcher.quiet<code>跟</code>launcher.stop` 都干了些什么呢？</p>

<h3>Sidekiq::Launcher#quiet 源码探索</h3>

<p>老规矩，先上代码：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L32-L36">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L32-L36</a></h1>

<p>def quiet
  @done = true
  @manager.quiet
  @poller.terminate
end
<code>``
代码只有短短三行。 Launcher 对象首先设置自己的实例变量</code>@done<code>的值为</code>true<code>，接着执行</code>@manager.quiet<code>以及</code>@poller.terminate<code>。看方法命名上理解，应该是 Luancher 对象又将 quiet 的消息传递给了</code>@manager<code>即</code>Sidekiq::Manager<code>对象，同时通知</code>@poller<code>即</code>Sidekiq::Scheduled::Poller` 对象结束工作。那到底是不是真的这样呢？让我们继续深挖！</p>

<h4>Sidekiq::Manager#quiet</h4>

<p>让我们来看看 <code>Sidekiq::Manager#quiet</code> 方法的代码</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L51-L58">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L51-L58</a></h1>

<p>def quiet
  return if @done
  @done = true</p>

<p>  logger.info { &ldquo;Terminating quiet workers&rdquo; }
  @workers.each { |x| x.terminate }
  fire_event(:quiet, true)
end
<code>``
上面的代码也很短，首先将</code>Sidekiq::Manager<code>对象自身的</code>@done<code>实例变量的值设置为</code>true<code>，接着对其所管理的每一个 worker，都发出一个</code>terminate<code>消息。让我们接着往下看 worker 对象（</code>Sidekiq::Processor<code>对象）的</code>#terminate` 方法定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L42-L46">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L42-L46</a></h1>

<p>def terminate(wait=false)
  @done = true
  return if !@thread
  @thread.value if wait
end
<code>``
这里的代码依然保持了精短的特点！跟上一层逻辑一样，worker 在处理</code>terminate<code>时，同样设置自己的</code>@done<code>实例变量为</code>true<code>后返回，但是，如果其参数</code>wait<code>为</code>true<code>，则会保持主线程等待，直到</code>@thread<code>线程退出（</code>@thread.value<code>相当于执行</code>@thread.join`并且返回线程的返回值，可参考 <a href="https://ruby-doc.org/core-2.2.0/Thread.html#method-i-value">Ruby 文档</a>）。</p>

<p>那么，这里就要问了，worker 设置 <code>@done</code> 为 true 是要干嘛？这里好像也没有做什么特别的事啊？！勿急，还记得上篇文章介绍 worker 运行时的核心代码吗？</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77</a></h1>

<p>def run
  begin</p>

<pre><code>while !@done
  process_one
end
@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Sidekiq::Shutdown</p>

<pre><code>@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Exception => ex</p>

<pre><code>@mgr.processor_died(self, ex)
</code></pre>

<p>  end
end
<code>``
看到了吧，</code>@done<code>变量可是一个重要的开关，当</code>@done<code>为</code>false<code>时，worker 一直周而复始地从队列中取任务并且老老实实干活；而当</code>@done<code>为</code>true<code>时，worker 在处理完当前的任务之后，便不再执行新的任务，执行</code>@msg.processor_stopped(self)<code>通知 worker 管理器自己已经退出工作，最终</code>#run<code>方法返回。由于</code>#run<code>方法是在独立线程里执行的，所以当</code>#run` 方法返回时，其所在的线程自然也就退出了。</p>

<p>那关于 worker 的 quiet 模式进入过程就是这么简单，通过一个共享变量 <code>@done</code> 便实现了对工作线程的控制。</p>

<h4>Sidekiq::Scheduled::Poller#terminate</h4>

<p>前面说到 <code>Sidekiq::Launcher#quiet</code> 执行时，先将消息传递给了 worker 管理器，随后执行了 <code>@poller.terminate</code>，那我们来看看 <code>#terminate</code> 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L53-L61">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L53-L61</a></h1>

<p>def terminate
  @done = true
  if @thread</p>

<pre><code>t = @thread
@thread = nil
@sleeper &lt;&lt; 0
t.value
</code></pre>

<p>  end
end
<code>``
又是如此简短的代码。poller 退出的逻辑跟 worker 退出的逻辑非常一致，都是同样先设置自己的</code>@done<code>实例变量的值为</code>true<code>，接着等待线程</code>@thread` 退出，最后 poller 返回。</p>

<p>那么，poller 的 <code>@done</code> 是不是也是用来控制线程退出呢？答案是肯定的！</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73</a></h1>

<p>def start
  @thread ||= safe_thread(&ldquo;scheduler&rdquo;) do</p>

<pre><code>initial_wait

while !@done
  enqueue
  wait
end
Sidekiq.logger.info("Scheduler exiting...")
</code></pre>

<p>  end
end
<code>``
还记得上面这段代码吗？ poller 在每次将定时任务压回任务队列之后，等待一定时间，然后重新检查</code>@done<code>的值，如果为</code>true<code>，则 poller 直接返回退出，因为</code>#start` 方法里的循环体在新线程中执行，当循环结束时，线程自然也退出了。</p>

<h4>小结</h4>

<ol>
<li>当 Sidekiq 收到 <code>USR1</code> 系统信号时，Sidekiq 主线程向 <code>@launcher</code> 发送 <code>quiet</code> 消息，<code>@launcher</code> 又将消息传递给 <code>@manager</code> ，同时向 <code>@poller</code> 发出 <code>terminate</code> 消息；</li>
<li><code>@manager</code> 在收到 <code>quiet</code> 消息时，逐一对运行中的 worker 发送 <code>terminate</code> 消息，worker 收到消息后，设置自己的 <code>@done</code> 为 <code>true</code>，标识不再处理新任务，当前任务处理完成后退出线程；</li>
<li><code>@poller</code> 在收到 <code>terminate</code> 消息后，也是设置自己的 <code>@done</code> 为 <code>true</code>，在本次任务执行完毕后，线程也退出；</li>
<li>Sidekiq 进入 quiet 模式之后，所有未处理任务以及新任务都不再处理，直到 sidekiq 的下一次重启。</li>
</ol>


<h3>Sidekiq::Launcher#stop 源码探索</h3>

<p>前面介绍的是 Sidekiq 进入 quiet 模式的过程，那 Sidekiq 的停止过程又是怎样的呢？</p>

<p>让我们从 <code>Sidekiq::Launcher#stop</code> 方法开始寻找答案：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L41-L56">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L41-L56</a></h1>

<p>def stop
  deadline = Time.now + @options[:timeout]</p>

<p>  @done = true
  @manager.quiet
  @poller.terminate</p>

<p>  @manager.stop(deadline)</p>

<p>  # Requeue everything in case there was a worker who grabbed work while stopped
  # This call is a no-op in Sidekiq but necessary for Sidekiq Pro.
  strategy = (@options[:fetch] || Sidekiq::BasicFetch)
  strategy.bulk_requeue([], @options)</p>

<p>  clear_heartbeat
end
<code>``
首先，</code>Sidekiq::Launcher<code>对象设定了一个强制退出的</code>deadline<code>，时间是以当前时间加上配置的</code>timeout`，这个时间<a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L23">默认是 8 秒</a>。</p>

<p>接着，设定对象本身的 <code>@done</code> 变量的值为 <code>true</code>，然后分别对 <code>@manager</code> 和 <code>@poller</code> 发送 <code>quiet</code> 和 <code>terminate</code> 消息，这个过程就是我们上面说的 <code>Sidekiq::Launcher#quiet</code> 的过程，所以，这里的代码主要是 Sidekiq 要确保退出前已经通知各个线程准备退出。</p>

<p>接下来的代码就比较重要了，我们先看这一行：</p>

<p><code>ruby
@manager.stop(deadline)
</code>
在通知完 <code>@manager</code> 进入 quiet 模式之后，launcher 向 <code>@manager</code> 发送了 <code>stop</code> 消息，并且同时传递了 <code>deadline</code> 参数。让我们接着继续往下看：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L61-L83">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L61-L83</a></h1>

<p>PAUSE_TIME = STDOUT.tty? ? 0.1 : 0.5</p>

<p>def stop(deadline)
  quiet
  fire_event(:shutdown, true)</p>

<p>  # some of the shutdown events can be async,
  # we don&rsquo;t have any way to know when they&rsquo;re done but
  # give them a little time to take effect
  sleep PAUSE_TIME
  return if @workers.empty?</p>

<p>  logger.info { &ldquo;Pausing to allow workers to finish&hellip;&rdquo; }
  remaining = deadline &ndash; Time.now
  while remaining > PAUSE_TIME</p>

<pre><code>return if @workers.empty?
sleep PAUSE_TIME
remaining = deadline - Time.now
</code></pre>

<p>  end
  return if @workers.empty?</p>

<p>  hard_shutdown
end
```</p>

<p>上面的代码，manager 首先调用了自身的 <code>quiet</code> 方法（这里就真的多此一举了，因为外层的 launcher 已经调用过一次了），然后 manager 执行 <code>sleep</code> 系统调用进入休眠，持续时间为 0.5 秒，休眠结束后检查所有 worker 是否已经都退出，如果退出，则直接返回，任务提前结束；如果仍有 worker 未退出，则检查当前时间是否接近强制退出的 deadline，如果不是，则重复“检查所有 worker 退出 &ndash; 休眠” 的过程，直到 deadline 来临，或者 worker 线程都已经全部退出。如果最后到达 deadline，仍有 worker 线程未退出，则最后执行 <code>hard_shutdown</code>。</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L108-L135">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L108-L135</a></h1>

<p>def hard_shutdown
  cleanup = nil
  @plock.synchronize do</p>

<pre><code>cleanup = @workers.dup
</code></pre>

<p>  end</p>

<p>  if cleanup.size > 0</p>

<pre><code>jobs = cleanup.map {|p| p.job }.compact

# ... other codes

strategy = (@options[:fetch] || Sidekiq::BasicFetch)
strategy.bulk_requeue(jobs, @options)
</code></pre>

<p>  end</p>

<p>  cleanup.each do |processor|</p>

<pre><code>processor.kill
</code></pre>

<p>  end
end
<code>``
这里</code>hard_shutdown<code>方法在执行时，首先克隆了当前仍未退出的</code>@workers<code>列表，接着获取每个 worker 当前正在处理的任务，将这些正在执行中的任务数据通过</code>strategy.bulk_requeue(jobs, @options)<code>重新写回队列，而最后对每一个 worker 发送</code>kill` 消息：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L48-L58">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L48-L58</a></h1>

<p>def kill(wait=false)
  @done = true
  return if !@thread</p>

<p>  @thread.raise ::Sidekiq::Shutdown
  @thread.value if wait
end
<code>``
worker 在收到</code>kill<code>消息时，首先设置自己的</code>@done<code>为</code>true<code>，最后向 worker 所关联的线程抛出</code>::Sidekiq::Shutdown` 异常。让我们看看 worker 的线程又是如何处理异常的：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77</a></h1>

<p>def run
  begin</p>

<pre><code>while !@done
  process_one
end
@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Sidekiq::Shutdown</p>

<pre><code>@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Exception => ex</p>

<pre><code>@mgr.processor_died(self, ex)
</code></pre>

<p>  end
end
<code>``
又回到 worker 的</code>run<code>方法这里，可以看到，</code>run<code>方法捕捉了</code>Sidekiq::Shutdown<code>异常，并且在处理异常时，只是执行</code>@mgr.processor_stopped(self)<code>，通知 manager 自己已经退出，由于已经跳出正常流程，worker 的</code>run` 方法返回，线程也因此得以退出。至此，worker 也都正常退出了。</p>

<h4>小结</h4>

<ol>
<li>launcher 在执行退出时，首先按照 quiet 的流程先通知各个线程准备退出；</li>
<li>接着 launcher 向 manager 下达 <code>stop</code> 指令，并且给出最后期限（<code>deadline</code>）；</li>
<li>manager 在给定的限时内，尽可能等待所有 worker 执行完自己退出，对于到达限时仍未退出的 worker，manager 备份了每个 worker 的当前任务，重新加入队列，确保任务至少完整执行一次，然后通过向线程抛出异常的方式，迫使 worker 的线程被动退出。</li>
</ol>


<h3>总结</h3>

<ol>
<li>Sidekiq 简单高效利用了系统信号，并且有比较清晰明了的信号处理过程；</li>
<li>Sidekiq 在信号处理的过程中，各个组件协调很有条理，消息逐级传递，而且对被强制停止的任务也有备份方案；</li>
<li>我们可以从 Sidekiq 的系统信号处理机制上借鉴不少东西，比如常用系统信号的分类处理等；</li>
<li>对于多线程的控制，通过共享变量以及异常的方式做到 <code>graceful</code> 以及 <code>hard</code> 两种方式的退出处理。</li>
<li>还有很多，一百个人心中有一百个哈姆莱特，同样一份代码，不同的人学习阅读，肯定收获不同，你可以在评论区留下你的感悟，跟看到这篇文章的人一起分享！</li>
</ol>


<h3>问题思考</h3>

<ol>
<li>为了尽可能确保所有 Sidekiq 的任务能够正常主动退出，所以在部署脚本中，都会尽可能早地让 Sidekiq 进入 quiet 模式，但是 Sidekiq 的 quiet 是不可逆的，所以一旦部署脚本中途失败，Sidekiq 得不到重启，将会一直保持 quiet 状态，如果长时间未重启，任务就会积压。所以，一般我都会在部署脚本中，额外捕捉部署脚本失败异常，然后主动执行 sidekiq 的重启。<strong>如果你的部署脚本中有涉及 Sidekiq 的，一定要注意检查部署失败是否会影响 Sidekiq 的状态</strong></li>
<li>虽然 Sidekiq 在强制退出当前长时间未退出的任务时，会将 job 的数据写回队列，等待重启后重新执行，那么这里就有个细节需要注意了，就是你的 job 必须是幂等的，否则就不能允许重新执行了。所以，请注意，<strong>如果你有需要长时间运行的 job，请注意检查其幂等性</strong>。</li>
</ol>


<p>好了，今天就写到这吧！仍然挺长一篇，啰嗦了。感谢看到这里！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[sidekiq任务调度流程分析]]></title>
    <link href="http://Martin91.github.io/blog/articles/2016/10/29/sidekiqren-wu-diao-du-liu-cheng-fen-xi/"/>
    <updated>2016-10-29T16:32:28+08:00</updated>
    <id>http://Martin91.github.io/blog/articles/2016/10/29/sidekiqren-wu-diao-du-liu-cheng-fen-xi</id>
    <content type="html"><![CDATA[<p><a href="http://sidekiq.org/">sidekiq</a>是 Ruby 中一个非常优秀而且可靠的后台任务处理软件，其依赖 Redis 实现队列任务的增加、重试以及调度等。而 sidekiq 从启动到开始不断处理任务、定时任务以及失败任务的重试，都是如何调度的呢？遇到问题的时候，又该如何调优呢？</p>

<!-- MORE -->


<h3>注意</h3>

<ol>
<li>今天的分析所参考的 sidekiq 的源码对应版本是 4.2.3；</li>
<li>今天所讨论的内容，将主要围绕任务调度过程进行分析，无关细节将不赘述，如有需要，请自行翻阅 sidekiq 源码；</li>
<li>文章内容真的很长，请做好心理准备。<br/>
<img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/0fc8f347a4c7cba67066b2527bdb8f94.png!large" alt="" /></li>
</ol>


<h3>你将了解到什么？</h3>

<ol>
<li>sidekiq 的任务调度机制：定时任务、重试任务的检查机制，队列任务的排队以及队列权重对处理优先级的影响；</li>
<li>sidekiq 的中间件机制以及在此基础上实现的任务重试机制。</li>
</ol>


<h2>先抛结论</h2>

<h3>时序图</h3>

<p>对于复杂的调用关系，我习惯用时序图帮助我理解其中各部分代码之间相互协作的关系（注意：为了避免太多细节造成阅读负担，我将参数传递以及返回值等冗杂过程去除了，只保留与任务调度相关的关键调用）：
<img src="/images/medias/sidekiq%20job%20dispatcher.png" alt="sidekiq 任务调度时序图" /></p>

<h3>人话</h3>

<p>Sidekiq 整个任务调度过程中依赖几个不同角色的代码共同协作，其分工如下：
<img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/fe43bace416ba3bb7f7d77b397683bf4.png!large" alt="" /></p>

<h2>源码之旅 —— 启动</h2>

<p>当我们在执行 <code>sidekiq</code> 时，源码中的 <code>bin/sidekiq.rb</code> 文件便是第一个开始执行的文件，让我们看看<a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12">里边的主要代码</a>：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12</a></h1>

<p>begin
  cli = Sidekiq::CLI.instance
  cli.parse
  cli.run # &lt;===== 这边走</p>

<h1>&hellip;</h1>

<p><code>``
紧靠</code>begin<code>后边的两行代码首先创建</code>Sidekiq::CLI<code>类的一个实例，接着调用实例方法</code>#parse<code>解析 sidekiq 的配置参数，其中包括队列的配置、worker 数量的配置等，在此不展开了。接着实例方法</code>#run<code>将带着我们继续往下走，让我们继续看</code>lib/sidekiq/cli.rb` 里边的代码：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L46-L106">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L46-L106</a></h1>

<p>def run
  # 这里打印控制台欢迎信息、打印日志以及运行环境（不同 Rails 版本）加载等</p>

<p>  require &lsquo;sidekiq/launcher&rsquo;
  @launcher = Sidekiq::Launcher.new(options)</p>

<p>  begin</p>

<pre><code>launcher.run # &lt;===== 这边走
</code></pre>

<p>  # 进程接收到的信号处理以及退出处理
end
<code>``
上面的代码主要是实例化了一个</code>Sidekiq::Launcher<code>的对象，紧随其后又调用了实例方法</code>#run<code>，所以让我们继续顺藤摸瓜，看看</code>Sidekiq::Launcher#run` 方法到底做了哪些事情？</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L24-L28">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L24-L28</a></h1>

<p>def run
  @thread = safe_thread(&ldquo;heartbeat&rdquo;, &amp;method(:start_heartbeat))
  @poller.start
  @manager.start
end
<code>``
</code>#run<code>方法首先通过</code>safe_thread<code>创建了一个新的线程，线程主要负责执行</code>start_heartbeat` 方法的代码，从方法名称上，我们猜测其主要是心跳代码，负责定时检查 sidekiq 健康状态，跟之前一样，这里不往下挖，我们继续看后边的两行代码：</p>

<p><code>ruby
@poller.start
@manager.start
</code>
这里的 <code>@poller</code> 跟 <code>@manager</code> 都是什么呢？让我们回头看一下，前面讲到 <code>lib/cli.rb</code> 的 <code>#run</code> 方法会负责创建 <code>Sidekiq::Launcher</code> 的实例，那让我们看下后者的 <code>initialize</code> 方法定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L17-L22">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L17-L22</a></h1>

<p>def initialize(options)
  @manager = Sidekiq::Manager.new(options)
  @poller = Sidekiq::Scheduled::Poller.new
  @done = false
  @options = options
end
<code>``
可以看到，实际上，</code>@manager<code>是在创建</code>Sidekiq::Launcher<code>实例的过程中同步创建的</code>Sidekiq::Manager<code>的实例，同理，</code>@poller<code>是同步创建的</code>Sidekiq::Scheduled::Poller<code>的实例。那我们按照代码执行顺序，先看下</code>@poller.start<code>也就是</code>Sidekiq::Scheduled::Poller#start` 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73</a></h1>

<p>def start
  @thread ||= safe_thread(&ldquo;scheduler&rdquo;) do</p>

<pre><code>initial_wait

while !@done
  enqueue
  wait
end
Sidekiq.logger.info("Scheduler exiting...")
</code></pre>

<p>  end
end
<code>``
这里看到，</code>#start<code>方法也创建了一个线程，在线程里执行了两个部分代码：1. 初始化等待；2. 循环里的</code>enqueue<code>与</code>wait`。这都是什么呢？</p>

<p><strong>注意</strong>: <code>#start</code> 方法在线程创建完成后就立刻返回了，至于 <code>#start</code> 方法里的逻辑，请移步后面章节“继续深挖 Sidekiq::Scheduled::Poller#start”作更深一步分析。这里，我们先继续接着看看 <code>#start</code> 方法返回后接下来执行的 <code>@manager.start</code> 方法又做了什么：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L45-L49">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L45-L49</a></h1>

<p>def start
  @workers.each do |x|</p>

<pre><code>x.start
</code></pre>

<p>  end
end
<code>``
这里的</code>@workers<code>又是什么？一个数组？怎样的数组？我们回顾下，前面说在创建</code>Sidekiq::Launcher<code>实例的过程中同步创建了</code>Sidekiq::Manager<code>的实例，让我们就看看</code>Sidekiq::Manager<code>的</code>#initialize` 方法：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L31-L43">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L31-L43</a></h1>

<p>def initialize(options={})
  logger.debug { options.inspect }
  @options = options
  @count = options[:concurrency] || 25
  raise ArgumentError, &ldquo;Concurrency of #{@count} is not supported&rdquo; if @count &lt; 1</p>

<p>  @done = false
  @workers = Set.new
  @count.times do</p>

<pre><code>@workers &lt;&lt; Processor.new(self)
</code></pre>

<p>  end
  @plock = Mutex.new
end
<code>``
可以看到，在创建了</code>Sidekiq::Manager<code>的实例之后，又同步创建了多个</code>Sidekiq::Processor<code>的实例，实例的个数取决于</code>options[:concurrency] || 25<code>，也就是配置的</code>:concurrency<code>的值，缺省值为</code>25<code>。至此，我们知道，sidekiq 中的 worker 的数量就是在此其作用的，</code>Sidekiq::Manager<code>按照配置的数量创建指定数量的 worker。
往回看刚才的</code>#start` 方法中：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L46-L48">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L46-L48</a></h1>

<p>@workers.each do |x|
  x.start
end
<code>``
简言之，就是</code>Sidekiq::Manager<code>在</code>start<code>的时候只做一件事：分别调用其管理的所有 worker 的</code>#start<code>方法，也就是</code>Sidekiq::Processor#start`。继续往下走：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L60-L62">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L60-L62</a></h1>

<p>def start
  @thread ||= safe_thread(&ldquo;processor&rdquo;, &amp;method(:run))
end
<code>``
又是我们熟悉的</code>safe_thread<code>方法，同样是创建了一个新的线程，意味着每一个 worker 都是基于自己的一个新线程的，而这个线程里执行的代码是私有方法</code>#run` 里的代码：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77</a></h1>

<p>def run
  begin</p>

<pre><code>while !@done
  process_one
end
@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Sidekiq::Shutdown</p>

<pre><code>@mgr.processor_stopped(self)
</code></pre>

<p>  rescue Exception => ex</p>

<pre><code>@mgr.processor_died(self, ex)
</code></pre>

<p>  end
end
<code>``
可以发现，又是一个 while 循环！而这个循环体里只调用了一个</code>#process_one<code>实例方法，顾名思义，这里是说每个 worker 在没被结束之前，都重复每次处理一个新的任务，那这个</code>#process_one` 里又做了什么呢？怎么决定该先做哪个任务呢？别急，请看后面章节“继续深挖 Sidekiq::Processor#process_one”。</p>

<h3>小结</h3>

<p>sidekiq 在启动后（此处可借文章开头的时序图辅助理解）：</p>

<ol>
<li>首先创建了 <code>Sidekiq::CLI</code> 的实例，并调用其 <code>run</code> 方法；</li>
<li><code>Sidekiq::CLI</code> 的实例在 <code>#run</code> 的过程中，创建了 <code>Sidekiq::Launcher</code> 的实例，并调用其 <code>run</code> 方法；</li>
<li><code>Sidekiq::Launcher</code> 的实例在创建后，同步创建了一个 <code>Sidekiq::Scheduled::Poller</code> 的实例以及 <code>Sidekiq::Manager</code> 的实例，而在其执行 <code>#run</code> 的过程中，则分别调用了这两个实例的 <code>start</code> 方法；</li>
<li><code>Sidekiq::Scheduled::Poller</code> 的实例在执行 <code>start</code> 过程中，创建了一个内部循环执行的线程，周而复始地执行 <code>enqueue</code> &ndash;> <code>wait</code>；</li>
<li><code>Sidekiq::Manager</code> 的实例在创建后，同步创建若干个指定的 worker，也就是 <code>Sidekiq::Processor</code> 的实例，并在执行 <code>start</code> 方法的过程中对每一个 worker 发起 <code>start</code> 调用；</li>
<li><code>Sidekiq::Processor</code> 实例在执行 <code>start</code> 方法的过程中创建了一个新的线程，新的线程里同样有一个 <code>while</code> 循环，反复执行 <code>process_one</code>。</li>
</ol>


<p>以上就是 Sidekiq 的主要启动过程，以下分别针对 <code>Sidekiq::Scheduled::Poller</code> 以及 <code>Sidekiq::Manager</code> 展开源码分析。</p>

<h2>定时任务拉取器的工作 Sidekiq::Scheduled::Poller#start</h2>

<p>经过前面较表层的代码分析，我们接下来继续展开 <code>Sidekiq::Scheduled::Poller#start</code> 方法的探索之旅，首先重温下其代码定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73</a></h1>

<p>def start
  @thread ||= safe_thread(&ldquo;scheduler&rdquo;) do</p>

<pre><code>initial_wait

while !@done
  enqueue
  wait
end
Sidekiq.logger.info("Scheduler exiting...")
</code></pre>

<p>  end
end
<code>``
可以看到，</code>#start<code>方法的核心就是中间的</code>while<code>循环，在循环前面，执行了</code>#initial_wait` 方法，让我们先看看这个方法到底是干些什么的：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L133-L143">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L133-L143</a></h1>

<p>def initial_wait
  # Have all processes sleep between 5-15 seconds.  10 seconds
  # to give time for the heartbeat to register (if the poll interval is going to be calculated by the number
  # of workers), and 5 random seconds to ensure they don&rsquo;t all hit Redis at the same time.
  total = 0
  total += INITIAL_WAIT unless Sidekiq.options[:poll_interval_average]
  total += (5 * rand)</p>

<p>  @sleeper.pop(total)
rescue Timeout::Error
end
<code>``
结合注释理解，原来私有方法</code>#initial_wait` 只是为了避免所有进程在后续逻辑中同时触发 Redis IO 而做的设计，如果对大型系统有过架构经验的童鞋就会明白，这里其实就是为了防止类似雪崩之类的系统故障出现。让当前进程随机等待一定范围的时间，从而就可以跟其他进程错开了。</p>

<p>在理解完 <code>initial_wait</code> 之后，我们接着看到循环体里的代码：
```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L68-L69">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L68-L69</a></h1>

<p>enqueue
wait
```</p>

<p><code>enqueue</code>？干嘛呢？为什么是入队列呢？带着疑问往下看：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L75-L86">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L75-L86</a></h1>

<p>def enqueue
  begin</p>

<pre><code>@enq.enqueue_jobs
</code></pre>

<p>  rescue => ex</p>

<pre><code># ...
</code></pre>

<p>  end
end
<code>``
这里看到</code>#enqueue<code>代码非常简单，只是调用了实例变量</code>@enq<code>的</code>#enqueue_jobs<code>方法而已，那么，</code>@enq<code>是什么类型的实例呢？它的</code>#enqueue_jobs<code>方法又做了什么呢？让我们回过头来看一遍</code>Sidekiq::Scheduled::Poller<code>的</code>#initialize` 方法：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L45-L50">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L45-L50</a></h1>

<p>def initialize
  @enq = (Sidekiq.options[:scheduled_enq] || Sidekiq::Scheduled::Enq).new
  @sleeper = ConnectionPool::TimedStack.new
  # &hellip;
end
<code>``
原来缺省情况下，</code>@enq<code>就是</code>Sidekiq::Scheduled::Enq<code>的实例。而代码上看的话，sidekiq 支持用户通过</code>:scheduled_enq<code>配置项自定义</code>@enq<code>的类型，但是官方文档未对此参数提及以及说明，这里其实是一种策略模式的实现，用户自定义的类型必须实现</code>enqueue_jobs` 方法。我估计，是 sidekiq pro 里边才会用到的配置项吧。</p>

<p>知道了 <code>@enq</code> 的类型后，让我们继续看下 <code>Sidekiq::Scheduled::Enq#enqueue_jobs</code> 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L11-L33">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L11-L33</a></h1>

<p>def enqueue_jobs(now=Time.now.to_f.to_s, sorted_sets=SETS)
  # A job&rsquo;s &ldquo;score&rdquo; in Redis is the time at which it should be processed.
  # Just check Redis for the set of jobs with a timestamp before now.
  Sidekiq.redis do |conn|</p>

<pre><code>sorted_sets.each do |sorted_set|
  # Get the next item in the queue if it's score (time to execute) is &lt;= now.
  # We need to go through the list one at a time to reduce the risk of something
  # going wrong between the time jobs are popped from the scheduled queue and when
  # they are pushed onto a work queue and losing the jobs.
  while job = conn.zrangebyscore(sorted_set, '-inf'.freeze, now, :limit =&gt; [0, 1]).first do

    # Pop item off the queue and add it to the work queue. If the job can't be popped from
    # the queue, it's because another process already popped it so we can move on to the
    # next one.
    if conn.zrem(sorted_set, job)
      Sidekiq::Client.push(Sidekiq.load_json(job))
      Sidekiq::Logging.logger.debug { "enqueued #{sorted_set}: #{job}" }
    end
  end
end
</code></pre>

<p>  end
<code>``
其实这里这个方法的寓意，通过代码里的注释都已经很明晰了，不过我觉得还是有几个点需要强调下。
首先，在无参数调用</code>#enqueue_jobs<code>方法时，定义中的参数</code>now<code>缺省为当前时间，而</code>sorted_sets<code>缺省为</code>Sidekiq::Scheduled::SETS` 的值，其值定义为：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L8">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L8</a></h1>

<p>SETS = %w(retry schedule)
<code>``
也就是数组</code>[&ldquo;retry&rdquo;, &ldquo;schedule&rdquo;]`，而这两个队列名称所对应的队列就是 sidekiq 的重试以及定时任务队列，在 sidekiq 里边，重试任务以及定时任务本质上都是 scheduled jobs，这两个队列使用了特殊的 Redis 的数据结构，进入队列的任务以其执行时间作为数据的 score，写入 Redis 之后按照 score 排序，也就是按任务的计划时间排序。</p>

<p>接着往下看：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L14-L30">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L14-L30</a></h1>

<p>Sidekiq.redis do |conn|
  sorted_sets.each do |sorted_set|</p>

<pre><code>while job = conn.zrangebyscore(sorted_set, '-inf'.freeze, now, :limit =&gt; [0, 1]).first do
  if conn.zrem(sorted_set, job)
    Sidekiq::Client.push(Sidekiq.load_json(job))
    Sidekiq::Logging.logger.debug { "enqueued #{sorted_set}: #{job}" }
  end
end
</code></pre>

<p>  end
end
<code>``
可以看到，sidekiq 分别针对</code>&ldquo;retry&rdquo;<code>和</code>&ldquo;schedule&rdquo;<code>队列做了一个循环，循环体里每次通过 Redis 的 [</code>ZRANGEBYSCORE<code>](http://redis.io/commands/ZRANGEBYSCORE)命令取出一个计划时间小于等于当前时间的任务，并且调用</code>Sidekiq::Client<code>的</code>.push<code>方法将此任务加到指定队列中（job 中包含队列名称等信息，在此不展开，有兴趣的同学请自行阅读</code>Sidekiq::Client` 的代码）。</p>

<p>至此，可以明白，<code>enqueue_jobs</code> 就是分别从 <code>"retry"</code> 和 <code>"schedule"</code> 队列中取出已经到达计划时间的任务，将其一一加入原来队列。注意，定时任务以及重试任务的计划时间只是计划加进执行中队列的时间，并非执行时间，执行的时间就只能取决于队列的长度以及队列执行速度了。</p>

<p>接着往回点，继续看 <code>enqueue_jobs</code> 之后的 <code>wait</code> 方法：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L90-L100">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L90-L100</a></h1>

<p>def wait
  @sleeper.pop(random_poll_interval)
rescue Timeout::Error
  # expected
rescue => ex
  #&hellip;
end
<code>``
这里的</code>wait<code>方法只是做一个休眠，休眠的实现依赖于</code>@sleeper<code>的</code>#pop<code>方法调用，回顾</code>Sidekiq::Scheduled::Poller<code>的</code>#initialize<code>方法的实现可以确认</code>@sleeper<code>是</code>ConnectionPool::TimedStack<code>的实例，而后者是 Ruby gem [connection_pool](https://github.com/mperham/connection_pool/blob/master/lib/connection_pool/timed_stack.rb) 里的实现，其</code>pop<code>方法会阻塞当前代码的执行，直到有值返回或者到达指定的超时时间，这里 sidekiq 利用了其阻塞的特性，作为</code>wait` 方法休眠器的实现。</p>

<p>而代码里的休眠时间则不是固定的，依赖 <code>#random_poll_interval</code> 方法的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L103-L105">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L103-L105</a></h1>

<h1>Calculates a random interval that is ±50% the desired average.</h1>

<p>def random_poll_interval
  poll_interval_average * rand + poll_interval_average.to_f / 2
end
<code>``
其实现依赖一个</code>#poll_interval_average` 方法的返回值，顾名思义，这个方法将决定定时任务定期检查的平均时间周期。让我们继续深挖下去：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L107-L122">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L107-L122</a></h1>

<h1>We do our best to tune the poll interval to the size of the active Sidekiq</h1>

<h1>cluster.  If you have 30 processes and poll every 15 seconds, that means one</h1>

<h1>Sidekiq is checking Redis every 0.5 seconds &ndash; way too often for most people</h1>

<h1>and really bad if the retry or scheduled sets are large.</h1>

<p>#</p>

<h1>Instead try to avoid polling more than once every 15 seconds.  If you have</h1>

<h1>30 Sidekiq processes, we&rsquo;ll poll every 30 * 15 or 450 seconds.</h1>

<h1>To keep things statistically random, we&rsquo;ll sleep a random amount between</h1>

<h1>225 and 675 seconds for each poll or 450 seconds on average.  Otherwise restarting</h1>

<h1>all your Sidekiq processes at the same time will lead to them all polling at</h1>

<h1>the same time: the thundering herd problem.</h1>

<p>#</p>

<h1>We only do this if poll_interval_average is unset (the default).</h1>

<p>def poll_interval_average
  Sidekiq.options[:poll_interval_average] ||= scaled_poll_interval
end
<code>``
这个方法的重要性通过其几倍于代码的注释就可以看出来，大概意思是，sidekiq 为了避免在进程重启后，有大量的进程同时密集地访问 redis，所以设计了这个机制，就是每个进程对定时任务的检查都是按照一个公式来计算的，保证每个进程两次检查之间的平均休眠时间能够在一个范围内动态变化，从而将所有进程的 Redis IO 均匀错开。
从代码上看，sidekiq 的这个平均拉取时间支持配置项配置，但是目前也并没有在 wiki 上有所提及。而缺省情况下，其值由方法</code>#scaled_poll_interval` 决定：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L124-L131">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L124-L131</a></h1>

<p>def scaled_poll_interval
  pcount = Sidekiq::ProcessSet.new.size
  pcount = 1 if pcount == 0
  pcount * Sidekiq.options[:average_scheduled_poll_interval]
end
```
正如前面一段代码的注释所说，缺省情况下，sidekiq 认为定时任务拉取器的平均休眠时间正是：</p>

<p><code>
sidekiq 进程数量 x 平均拉取时间 average_scheduled_poll_interval
</code>
而 <code>:average_scheduled_poll_interval</code> 的缺省配置是 15 秒：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/master/lib/sidekiq.rb#L25">https://github.com/mperham/sidekiq/blob/master/lib/sidekiq.rb#L25</a></h1>

<p>DEFAULTS = {
  # &hellip;
  average_scheduled_poll_interval: 15,
  # &hellip;
<code>``
所以回过头来，在没有相关自定义配置的情况下，假设你只开启了一个 sidekiq 进程，那么 sidekiq 的定时任务拉取器的拉取时间平均间隔为 1 x 15 = 15 秒，那按照上面的</code>#random_poll_interval` 方法的定义，则实际每次拉取的时间间隔则是在 7.5 秒到 22.5 秒之间！</p>

<h3>小结</h3>

<p>从这个章节的分析，我们可以明白 Sidekiq 对定时任务和重试任务是一视同仁的，其处理流程都是：</p>

<ol>
<li>所有定时任务（包括重试任务，本质上重试任务也是定时的，后边会单独讲解）以其计划时间为 score，加入特殊的 <code>"retry"</code> 或 <code>"schedule"</code> 有序队列中；</li>
<li>sidekiq 的定时任务拉取器从 <code>"retry"</code> 和 <code>"schedule"</code> 队列中一一取出已到达计划时间的任务，将其加入该任务计划的队列中，后续的执行则跟其他普通队列中的任务一致；</li>
<li>拉取器休眠一定时间（<code>random_poll_interval</code>）后，从步骤 2 重新开始，周而复始。</li>
</ol>


<p>所以，定时任务的计划时间不是确切的任务时间！只是允许加回队列的时间，具体执行时间还得另外看队列长度以及队列处理速度！</p>

<h2>Sidekie worker 的秘密： Sidekiq::Processor#process_one</h2>

<p>前面我们分析过 sidekiq 的 worker 的核心代码就是在线程里循环执行 <code>#process_one</code> 方法，那么这个方法到底做了些什么啊？别急，现在就来一探究竟：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83</a></h1>

<p>def process_one
  @job = fetch
  process(@job) if @job
  @job = nil
end
```</p>

<p>代码中，<code>#process_one</code> 先通过 <code>#fetch</code> 方法获取一个任务，当任务获取成功后，就将其作为参数调用 <code>#process</code> 方法，完成对任务的处理；如果没有获取到任务，则直接重新尝试获取新的任务。</p>

<p>首先让我们看看 <code>#fetch</code> 方法的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L96-L104">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L96-L104</a></h1>

<p>def fetch
  j = get_one         # 吐槽一下这个 <code>j</code> 变量，命名真的不敢恭维，这个库就这里写得不雅
  if j &amp;&amp; @done</p>

<pre><code>j.requeue
nil
</code></pre>

<p>  else</p>

<pre><code>j
</code></pre>

<p>  end
end
<code>``
</code>#fetch<code>方法通过</code>#get_one<code>方法从队列中获取任务，当获取到任务后，判断当前 worker 是否已经停止(</code>@done<code>为</code>true`)，是则将任务重新压回队列。</p>

<p>让我们接着看 <code>#get_one</code> 方法的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L85-L94">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L85-L94</a></h1>

<p>def get_one
  begin</p>

<pre><code>work = @strategy.retrieve_work
(logger.info { "Redis is online, #{Time.now - @down} sec downtime" }; @down = nil) if @down
work
</code></pre>

<p>  rescue Sidekiq::Shutdown
  rescue => ex</p>

<pre><code>handle_fetch_exception(ex)
</code></pre>

<p>  end
end
```</p>

<p>核心代码则是 <code>work = @strategy.retrieve_work</code>，为了了解 <code>@strategy</code>，我们仍旧往回看<code>#initialize</code> 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L32-L40">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L32-L40</a></h1>

<p>def initialize(mgr)
  # &hellip;
  @strategy = (mgr.options[:fetch] || Sidekiq::BasicFetch).new(mgr.options)
  # &hellip;
end
<code>``
又是一个策略模式，缺省下，使用了</code>Sidekiq::BasicFetch<code>生成实例，并且通过实例变量</code>@strategy` 引用。</p>

<p>回到前面的 <code>@strategy.retrieve_work</code>，让我们继续看看 <code>Sidekiq::BasicFetch#retrieve_work</code> 的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L35-L38">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L35-L38</a></h1>

<p>def retrieve_work
  work = Sidekiq.redis { |conn| conn.brpop(<em>queues_cmd) }
  UnitOfWork.new(</em>work) if work
end
```</p>

<p>通过上面的代码，可以知道 <code>Sidekiq::BasicFetch</code> 的取任务逻辑比较直接，是通过 Redis 的 <a href="http://redis.io/commands/brpop"><code>BRPOP</code> 命令</a>从“所有队列”中阻塞地取出第一个任务：</p>

<blockquote><p>BRPOP is a blocking list pop primitive. It is the blocking version of RPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given.</p></blockquote>

<p>所以，理解了 <code>BRPOP</code> 命令的工作细节之后，我们把注意力缩放到 <code>#queues_cmd</code> 方法上：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L40-L53">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L40-L53</a></h1>

<p>def queues_cmd
  if @strictly_ordered_queues</p>

<pre><code>@queues
</code></pre>

<p>  else</p>

<pre><code>queues = @queues.shuffle.uniq
queues &lt;&lt; TIMEOUT
queues
</code></pre>

<p>  end
end
```</p>

<p>首先，代码中检查了 <code>@strictly_ordered_queues</code> 这个实例变量的值，让我们回头看下这个变量的值的来源，也就是 <code>#initialize</code> 方法的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/d8f11c26518dbe967880f76fd23bb99e9d2411d5/lib/sidekiq/fetch.rb#L26-L33">https://github.com/mperham/sidekiq/blob/d8f11c26518dbe967880f76fd23bb99e9d2411d5/lib/sidekiq/fetch.rb#L26-L33</a></h1>

<p>def initialize(options)
  @strictly_ordered_queues = !!options[:strict]
  @queues = options[:queues].map { |q| &ldquo;queue:#{q}&rdquo; }</p>

<pre><code>if @strictly_ordered_queues
  @queues = @queues.uniq
  @queues &lt;&lt; TIMEOUT
end
</code></pre>

<p>  end
end
<code>``
缺省情况下，此值为</code>false<code>。所以让我们看</code>#queues_cmd<code>方法的</code>else` 分支里的代码：</p>

<p><code>ruby
queues = @queues.shuffle.uniq
</code>
而这里的 <code>@queues</code> 就是来自 <code>options[:queues]</code> 中的配置： <code>options[:queues].map { |q| "queue:#{q}" }</code>。那么，这个 <code>options[:queues]</code> 的值又是什么呢？
让我们一步一步沿着调用链上参数往回走：</p>

<ol>
<li><code>Sidekiq::BasicFetch.new</code> 的参数 <code>options</code> 来自 worker 在 <code>Sidekiq::Processor#initialize</code> 方法中的参数 <code>mgr</code> 的 <code>options</code> 属性；</li>
<li>worker 的 mgr 参数正是 <code>Sidekiq::Manager</code> 的实例，其 <code>options</code> 属性则是 <code>Sidekiq::Launcher</code> 创建 <code>Sidekiq::Manager</code> 实例时传入的 <code>options</code> 变量；</li>
<li>而 <code>Sidekiq::Launcher#initialize</code> 接收到的 <code>options</code> 变量则是更外层的 <code>Sidekiq::CLI</code> 的实例方法 <code>options</code> 的值；</li>
<li>而 <code>Sidekiq::CLI</code> 的实例的 <code>options</code> 则是在其接收到 <code>#parse</code> 调用时设置的。
为了节省篇幅，省略这里其中的太多调用栈，我们直接看最根源代码：</li>
</ol>


<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L389-L399">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L389-L399</a></h1>

<p>def parse_queues(opts, queues_and_weights)
  queues_and_weights.each { |queue_and_weight| parse_queue(opts, *queue_and_weight) }
end</p>

<p>def parse_queue(opts, q, weight=nil)
  [weight.to_i, 1].max.times do
   (opts[:queues] ||= []) &lt;&lt; q
  end
  opts[:strict] = false if weight.to_i > 0
end
<code>``
可以看到，sidekiq 在解析</code>:queues` 的相关配置时，按照每个队列以及其权重，生成了一个重复次数等于队列权重的队列的新数组，假设用户提供如下配置：</p>

<p><code>yaml
:queues:
  - default
  - [myqueue, 2]
</code>
则此处生成的 <code>options[:queues]</code> 则为 <code>["default", "myqueue", "myqueue"]</code>。所以，这里权重主要用于后边确定各个不同队列被处理到的优先权的比重。</p>

<p>了解了 <code>@queues</code> 的来源之后，我们回到最开始讨论的地方：</p>

<p><code>ruby
queues = @queues.shuffle.uniq
</code>
也就是说，每次 worker 在请求新的任务时，sidekiq 都按照原来的 <code>@queues</code> 执行 <code>shuffle</code> 方法，而 <code>shuffle</code> 则表示将数组元素重新随机排序，亦即“洗牌”。结合前面的权重，那么每个队列洗牌后排在第一位的概率与其权重挂钩。最后的 <code>#uniq</code> 方法确保队列名称没有重复，避免 Redis 在执行 <code>BRPOP</code> 命令时重复检查同一队列。这里使用 <code>BRPOP</code> 还有个好处就是，加入当前面优先的队列里边没有任务时，可以依次将机会让给后面的队列。</p>

<p>而后边的：</p>

<p><code>ruby
queues &lt;&lt; TIMEOUT
</code>
则是在命令末尾追加超时设定，即 Redis 的 <code>BRPOP</code> 命令最多阻塞 2 秒，超时则直接放弃。</p>

<p>了解了任务的获取之后，我们接着看 sidekiq 如何处理获取到的任务，回到 <code>retrieve_work</code> 的代码：
```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L36-L37">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L36-L37</a></h1>

<p>work = Sidekiq.redis { |conn| conn.brpop(<em>queues_cmd) }
UnitOfWork.new(</em>work) if work
<code>``
看到在获取到任务之后，任务通过</code>Sidekiq::BasicFetch::UnitOfWork` 结构体实例化后返回给调用方。</p>

<p>直接回到 <code>Sidekiq::Processor#process_one</code>:</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83</a></h1>

<p>def process_one
  @job = fetch
  process(@job) if @job
  @job = nil
end
<code>``
可以明白，@job 就是返回的</code>UnitOfWork<code>实例，那么</code>process(@job)` 会做些什么呢？</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L118-L152">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L118-L152</a></h1>

<p>def process(work)
  jobstr = work.job
  queue = work.queue_name</p>

<p>  @reloader.call do</p>

<pre><code>ack = false
begin
  job = Sidekiq.load_json(jobstr)
  klass  = job['class'.freeze].constantize
  worker = klass.new
  worker.jid = job['jid'.freeze]

  stats(worker, job, queue) do
    Sidekiq.server_middleware.invoke(worker, job, queue) do
      # Only ack if we either attempted to start this job or
      # successfully completed it. This prevents us from
      # losing jobs if a middleware raises an exception before yielding
      ack = true
      execute_job(worker, cloned(job['args'.freeze]))
    end
  end
</code></pre>

<p>  # &hellip;
```</p>

<p>上面代码中，sidekiq 从 <code>work</code> 中获取任务的相关信息，包括队列名称，任务对应的类型（<code>job['class'.freeze]</code>）、任务调用所需的参数等，根据这些信息重新实例化任务对象，并且将实例化的任务对象 <code>worker</code> 以及任务参数都传递给对 <code>execute_job</code> 的调用。让我们看看 <code>#execute_job</code> 的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L154-L156">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L154-L156</a></h1>

<p>def execute_job(worker, cloned_args)
  worker.perform(*cloned_args)
end
<code>``
看到了吧？我们最熟悉的</code>#perform` 方法！这下知道我们为什么需要在每个 sidekiq Worker 或者 ActiveJob 的 Job 类中定义这个方法了吧？因为这个方法就是最终任务执行时所需调用的方法，这就是约定！</p>

<p>至此，任务的调度过程就到此为止了，剩下的就是周而复始的重复了。</p>

<h3>小结</h3>

<p>经过上面的分析，我们可以明白 sidekiq 中 worker 的工作流程：
1. 按照所有队列以及其权重，每次重新排列待处理队列顺序，高权重的队列有更高的优先级；
2. 将重新排好的队列顺序传递给 Redis 的 BRPOP 命令，同时设置 2 秒超时；
3. sidekiq 将从队列中获取到的任务实例化，并且根据携带的参数调用了任务的 <code>#perform</code> 方法。</p>

<p>等等，上面都只是正常流程，那如果任务执行过程中出错了怎么办？？？重试的机制是如何运转的呢？</p>

<h2>重试机制：基于中间件的实现</h2>

<p><strong>注意：</strong>阅读本章节前，建议先阅读官方 Wiki 的 <a href="https://github.com/mperham/sidekiq/wiki/Error-Handling">Error Handling</a>。</p>

<p>细心的童鞋肯定发现了上面的 <code>Sidekiq::Processor#process</code> 方法中有个关键的代码：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L131-L137">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L131-L137</a></h1>

<p>Sidekiq.server_middleware.invoke(worker, job, queue) do
  # &hellip;
  execute_job(worker, cloned(job[&lsquo;args&rsquo;.freeze]))
end
<code>``
这个</code>server_middleware` 是什么呢？让我们来简单过一下吧：</p>

<p>全局搜索了代码，发现 <code>Sidekiq.server_middleware</code> 的来源是：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L140-L144">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L140-L144</a></h1>

<p>def self.server_middleware
  @server_chain ||= default_server_middleware
  yield @server_chain if block_given?
  @server_chain
end
<code>``
缺省情况下，</code>.server_middleware<code>依赖</code>.default_server_middleware` 的实现：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L146-L154">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L146-L154</a></h1>

<p>def self.default_server_middleware
  #&hellip;</p>

<p>  Middleware::Chain.new do |m|</p>

<pre><code>m.add Middleware::Server::Logging
m.add Middleware::Server::RetryJobs
</code></pre>

<p>  end
end
<code>``
可以明白</code>Sidekiq.default_server_middleware<code>返回一个</code>Middleware::Chain<code>实例，并且调用了其</code>#add<code>方法将</code>Middleware::Server::Logging<code>以及</code>Middleware::Server::RetryJobs<code>两个中间件加到中间件的 Chain 上。此中间件的实现以及实现类似 rackup，有兴趣的童鞋自行[阅读源码](https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/chain.rb)，在此不展开，让我们直接跳到</code>Middleware::Server::RetryJobs<code>的</code>call` 方法中：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L73-L84">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L73-L84</a></h1>

<p>def call(worker, msg, queue)
  yield
rescue Sidekiq::Shutdown
  # ignore, will be pushed back onto queue during hard_shutdown
  raise
rescue Exception => e
  # ignore, will be pushed back onto queue during hard_shutdown
  raise Sidekiq::Shutdown if exception_caused_by_shutdown?(e)</p>

<p>  raise e unless msg[&lsquo;retry&rsquo;]
  attempt_retry(worker, msg, queue, e)
end
```</p>

<p>让我们聚焦方法的最后一行代码 <code>attempt_retry(worker, msg, queue, e)</code>，此处表示当执行中的任务出现异常时，除去停机的因素以及禁用了重试机制后，尝试进行下次重试运行：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L88-L137">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L88-L137</a></h1>

<p>def attempt_retry(worker, msg, queue, exception)
  max_retry_attempts = retry_attempts_from(msg[&lsquo;retry&rsquo;], @max_retries)
  # &hellip;</p>

<p>  count = if msg[&lsquo;retry_count&rsquo;]</p>

<pre><code>msg['retried_at'] = Time.now.to_f
msg['retry_count'] += 1
</code></pre>

<p>  else</p>

<pre><code>msg['failed_at'] = Time.now.to_f
msg['retry_count'] = 0
</code></pre>

<p>  end</p>

<p>  # &hellip;
  if count &lt; max_retry_attempts</p>

<pre><code>delay = delay_for(worker, count, exception)
logger.debug { "Failure! Retry #{count} in #{delay} seconds" }
retry_at = Time.now.to_f + delay
payload = Sidekiq.dump_json(msg)
Sidekiq.redis do |conn|
  conn.zadd('retry', retry_at.to_s, payload)
end
</code></pre>

<p>  else</p>

<pre><code># Goodbye dear message, you (re)tried your best I'm sure.
retries_exhausted(worker, msg, exception)
</code></pre>

<p>  end</p>

<p>  raise exception
end
```</p>

<p>从上面的代码中看出，sidekiq 在捕捉到异常后，首先检查此任务此前是否已经重试过，是的话，则在重试累计次数上加 1，更新最后重试时间；否则初始化重试累计次数为 0，设定初次失败时间。接着，sidekiq 检查重试累计次数是否超过限定最大重试次数，是的话则放弃重试，任务从此不再重试，进入 Dead 状态，sidekiq 抛出异常；否则计算任务下次重试时间，将任务按照计划的下次重试时间加到 <code>retry</code> 有序队列中，最后抛出异常。关于重试任务的检查跟执行，请阅读前面的相关章节，接下来我们主要分析 sidekiq 如何计算任务的下次重试时间 <code>delay</code>。</p>

<p>让我们展开对 <code>#delay_for</code> 方法的探索：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L172-L174">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L172-L174</a></h1>

<p>def delay_for(worker, count, exception)
  worker.sidekiq_retry_in_block? &amp;&amp; retry_in(worker, count, exception) || seconds_to_delay(count)
end
```</p>

<p>首先了解下 <code>worker.sidekiq_retry_in_block?</code> 的定义：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L32">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L32</a></h1>

<p>base.class_attribute :sidekiq_retry_in_block
<code>``
其定义了每个 Worker 类的</code>sidekiq_retry_in_block<code>属性，而其又可以通过 Worker 类的</code>#sidekiq_retry_in` 方法完成赋值：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L96-L98">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L96-L98</a></h1>

<p>def sidekiq_retry_in(&amp;block)
  self.sidekiq_retry_in_block = block
end
```</p>

<p>回过头来，前面的</p>

<p><code>ruby
worker.sidekiq_retry_in_block? &amp;&amp; retry_in(worker, count, exception) || seconds_to_delay(count)
</code>
表示当具体的 Worker 配置了 <code>:sidekiq_retry_in_block</code> 时，则直接使用这个配置的 block 执行的值作为失败任务下次重试的时间间隔；否则使用缺省的计算公式：</p>

<p>```ruby</p>

<h1><a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L177-L179">https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L177-L179</a></h1>

<p>def seconds_to_delay(count)
  (count <em>* 4) + 15 + (rand(30)</em>(count+1))
end
```</p>

<p>其中 <code>count</code> 为任务累计重试次数，从公式上看，随着失败重试次数的累计增加，任务的下次重试时间间隔也会指数式增长，按照官方文档说法：</p>

<blockquote><p>Sidekiq will retry failures with an exponential backoff using the formula (retry_count ** 4) + 15 + (rand(30) * (retry_count + 1)) (i.e. 15, 16, 31, 96, 271, &hellip; seconds + a random amount of time). It will perform 25 retries over approximately 21 days.</p></blockquote>

<p>更多失败任务重试的相关配置请看文档：<a href="https://github.com/mperham/sidekiq/wiki/Error-Handling#configuration">Error Handling: Configuration</a>。</p>

<h3>小结</h3>

<ol>
<li>sidekiq 在执行任务时，通过自行实现的中间件架构以及对应的简单的中间件，及时捕捉失败的任务，针对允许再次重试的任务，按失败次数计算新的重试时间，缺省为指数增长的时间间隔；</li>
<li>用户可以通过配置修改缺省的公式，也可以指定最大重试次数等。</li>
</ol>


<p><strong>注意</strong>：结合失败任务捕捉处理以及重试任务的检查，缺省情况下，一个首次失败任务下次重回队列（不是执行）的理论最大时间间隔大概是 67.5 秒！（固定的 15 秒 + 最大随机时间 30 秒 + 最大理论检查时间 22.5 秒）。所以，如果你的任务很重要，又需要尽快重试，就需要对几部分时间的相关配置参数进行调优了哦！在我自己的工作中，我针对某个队列任务设置的 <code>sidekiq_retry_in</code> 公式为线性时间，即1s、2s、&hellip;50s，然后在重试检查那里设置了 <code>:poll_interval_average</code> 为 5 秒，新的下次执行时间理论最大时间间隔就是 8.5 秒！不过这些配置需要慎重调整，综合考虑业务以及业务量，既要尽可能保证任务尽早处理完，又得保证 Redis 没被 IO 压垮。</p>

<h2>总结</h2>

<h3>关于 sidekiq 项目代码</h3>

<ol>
<li>sidekiq 的源码比较简洁，很少看到长方法定义，大部分方法都在几行之内，读的过程中非常舒服；</li>
<li>sidekiq 的注释也很充足，比较重要又比较核心的代码都有大量详细的注释跟例子，除此之外大部分重点在 Wiki 中都有提及，非常好的一份代码库；</li>
<li>sidekiq 将 Redis 的各种数据结构用得都恰到好处，可以通过 sidekiq 加深对 Redis 的印象以及学习到如何恰当高效地结合 Redis 实现业务逻辑；</li>
<li>正是因为 sidekiq 将 Redis 充分利用以及高度结合，我终于理解 sidekiq 的作者为什么表示 sidekiq 不考虑其他数据库了；</li>
<li>sidekiq 的代码没有太多花俏的代码，非常推荐各位童鞋仔细研读。</li>
</ol>


<h3>关于源码阅读</h3>

<ol>
<li>带着问题去阅读，效率通常很高；</li>
<li>读的过程中适当放弃无关细节，只追击与问题相关的线索；</li>
<li>有些文档中没有提及的配置项，往往都藏匿在代码之中；</li>
<li>只有充分了解了工具的运行机制，在遇到问题调优的时候才能得心应手。</li>
</ol>


<h3>最后</h3>

<p>如果你能从头看到这里，那么非常感谢你的时间，毕竟这篇文章确实不短，尽管我已经尽量去除无用的部分，一些代码也直接跳过了，但是系统得了解一个框架或者一个软件，确实也是很多细节。</p>

<p>这是今年第二篇博客，今年的产出远不比去年，然而去年的产出远不比千年，所以，可能这篇也是今年最后一篇了。洋洋洒洒几万字，从下午两三点写到现在，七个多小时，难得可以静下心来写这么多，哎，这两年心态太浮躁，技术路上，还是继续保持“stay foolish, stay hungry”的好。</p>
]]></content>
  </entry>
  
</feed>
