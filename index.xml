<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Hackerpie</title><link>https://blog.hackerpie.com/</link><description>Recent content on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 18 Dec 2022 19:03:20 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/index.xml" rel="self" type="application/rss+xml"/><item><title>Allure 测试报告可视化工具入门</title><link>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide/</link><pubDate>Sun, 18 Dec 2022 19:03:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>10月份在公司内部的开源协同项目上认领了一个 issue，任务是为内部测试框架实现一个测试报告可视化工具，当时对接人提供了 Allure 作为选型参考，最后经过一番摸索也终于实现了既定效果。因为 Allure 展现效果确实还不错，但是官方没有底层 schema 的详细说明，所以实现过程也有一些摸索，这里记录下，或许会有人遇到类似的问题。&lt;/p>
&lt;h1 id="什么是-allure-框架">什么是 Allure 框架？&lt;/h1>
&lt;p>&lt;a href="https://qameta.io/allure-report/">Allure&lt;/a>，全称 Allure Report，是一个跨编程语言的测试报告工具，通过定义统一的底层 Schema，官方提供了多个编程语言版本的适配实现，目前主要有 Java、JavaScript、Python、Ruby、PHP、Kotlin、.Net 以及 Go。&lt;/p>
&lt;p>Allure 可以生成比较简洁的测试报告，报告划分“Overview”、“Categories”、“Suites”、“Graphs”、“Timeline”、“Behaviors”以及“Packages”几大板块，可以访问&lt;a href="https://allure-framework.github.io/allure-demo">Allure demo&lt;/a> 查看示例效果。如果需要了解更多不同的测试集展示的效果，可以访问 &lt;a href="http://betty.us.es/restest-showcase-demo/">RESTest showcase&lt;/a> 浏览。&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure_Report.png" alt="">
&lt;figcaption>allure demo&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>除此之外，Allure 也支持多语言切换，目前官方示例包含英语、中文、德语等在内的 12 种语言。&lt;/p>
&lt;p>Allure 框架在各个编程语言之上构建实现了整个测试报告的生态：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-architecture.jpg" alt="">
&lt;figcaption>allure architecture&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="allure-schema">Allure Schema&lt;/h1>
&lt;p>Allure 的跨编程语言特性得益于一套基于 JSON 格式的 Schema，官方在其各个编程语言版本的源码都有相关的定义，比如 Python 版的可以查看 &lt;a href="https://github.com/allure-framework/allure-python/blob/master/allure-python-commons/src/model2.py">allure-python-commons/src/model2.py&lt;/a>。&lt;/p>
&lt;p>但是官方对具体的 Schema 没有文字性的文档，所以 Schema 定义和最终生成报告中的效果的关联，没有确切的说明。我经过摸索和尝试，整理了 Schema 中各个模型的关系：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-models.jpg" alt="">
&lt;figcaption>allure models&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>为了直观对比 Schema 和最后生成的报告效果，可以查看这段 allure 的测试用例报告代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;test_shell_testcase_failed32&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;failed&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例结果，在上图中对应 `Status` 枚举值定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;steps&amp;#34;&lt;/span>: [ &lt;span style="font-style:italic">// 测试步骤，在测试报告中展示在面板右下角的 Test body 里
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:17:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:28:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:39:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;1665562034999&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例开始时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;stop&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;1665562053613&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例结束时间，和开始时间一起确定本用例的耗时，这里是 18s 614ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;uuid&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;test_python_testcase-result-37&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// uuid，这个可以由库代码自动生成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;testCaseId&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;20220411-152848-724647399&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 同样可以由库代码自动生成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;labels&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;suite&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 这是一个特殊的 label，当为 suite 时，value 表明当前用例对应的测试集名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tst_suite_common2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// tag 是普通的标签，显示在报告中的用例详情中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;feature&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;medium priority&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;level:3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;type:feature&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上 schema 对应的测试报告如图：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-report-example.png" alt="">
&lt;figcaption>allure 对照示例&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="如何基于官方库实现标准的-schema-生成">如何基于官方库实现标准的 schema 生成？&lt;/h1>
&lt;p>以 python 为例，可以使用官方代码库 &lt;code>allure-python-commons&lt;/code> 中的 &lt;a href="https://github.com/allure-framework/allure-python/blob/master/allure-python-commons/src/logger.py">&lt;code>AllureFileLogger&lt;/code>&lt;/a>。&lt;/p>
&lt;p>一个极简的例子是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">allure_commons.logger&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> AllureFileLogger
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">allure_commons.model2&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> TestResult, Status, Label, Link
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">allure_commons.types&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> LinkType
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">allure_commons.utils&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> now, uuid4
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> __name__ == &lt;span style="font-style:italic">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger = AllureFileLogger(report_dir=&lt;span style="font-style:italic">&amp;#34;tmp/logger_reports/&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = TestResult(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name=&lt;span style="font-style:italic">&amp;#34;test case&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status=Status.PASSED,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># statusDetails=&amp;#34;test passed&amp;#34;,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stage=&lt;span style="font-style:italic">&amp;#34;local test&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> description=&lt;span style="font-style:italic">&amp;#34;simulation test&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> descriptionHtml=&lt;span style="font-style:italic">&amp;#34;&amp;lt;h1&amp;gt;simulation test&amp;lt;/h1&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> start=now()-3000,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stop=now(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> uuid=uuid4(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> historyId=uuid4(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testCaseId=uuid4(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fullName=&lt;span style="font-style:italic">&amp;#34;a fake test case demo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> labels=[Label(name=&lt;span style="font-style:italic">&amp;#34;owner&amp;#34;&lt;/span>, value=&lt;span style="font-style:italic">&amp;#34;martinhong&amp;#34;&lt;/span>), Label(name=&lt;span style="font-style:italic">&amp;#34;weight&amp;#34;&lt;/span>, value=&lt;span style="font-style:italic">&amp;#34;highest&amp;#34;&lt;/span>)],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> links=[Link(type=LinkType.ISSUE,url=&lt;span style="font-style:italic">&amp;#34;https://google.com.hk&amp;#34;&lt;/span>,name=&lt;span style="font-style:italic">&amp;#34;fake link&amp;#34;&lt;/span>)])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.report_result(result)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行以上的代码，生成的 allure schema 代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;test case&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;stage&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;local test&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;description&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;simulation test&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;descriptionHtml&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;&amp;lt;h1&amp;gt;simulation test&amp;lt;/h1&amp;gt;&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;start&amp;#34;&lt;/span>: 1664635107494,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;stop&amp;#34;&lt;/span>: 1664635110494,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;uuid&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;083c72da-668c-406c-a258-ba61f2eec2f2&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;historyId&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;c665bc04-9b63-426f-a7ce-b1981853d775&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;testCaseId&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;2b53d7b0-2127-46ab-8c72-ec2e5c97b759&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;fullName&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;a fake test case demo&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;labels&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;owner&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;martinhong&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;weight&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;highest&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;links&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;issue&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;url&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;https://google.com.hk&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;fake link&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的可视化报告为：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure_simple_case.png" alt="">
&lt;figcaption>allure 简单示例&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://qameta.io/allure-report/">Allure Report&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>How to enable automated captions in zoom.us</title><link>https://blog.hackerpie.com/posts/skills/zoomus-how-to-enable-automated-captions/</link><pubDate>Tue, 16 Aug 2022 10:12:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/zoomus-how-to-enable-automated-captions/</guid><description>&lt;p>There are some times you may need to generate automated captions in zoom.us online meetings, and zoom.us also officially support this amazing feature. However, it is default to disabled so you need to manually enable it firstly. The below are steps to enable it quickly:&lt;/p>
&lt;p>Step 1: Login to &lt;a href="https://zoom.us">https://zoom.us&lt;/a> and then navigate your profile settings page, or you can click &lt;a href="https://zoom.us/profile/setting">this link&lt;/a> directly.&lt;/p>
&lt;p>Step 2: Scroll down your page until the In Meeting (Advanced) section, you can see there are two settings, one is Manual captions and the other is Automated captions, enable both of them like my screenshot.
&lt;img src="https://blog.hackerpie.com/images/posts/zoom-automated-captions/enable-automated-captions.png" alt="Enable automated captions">
&lt;/p>
&lt;p>Step 3(Optional): If you have been in a meeting, quit it and then join or start a new meeting, you should see there is a CC tool now.
&lt;img src="https://blog.hackerpie.com/images/posts/zoom-automated-captions/cc-captions.png" alt="CC tool">
&lt;/p>
&lt;p>Step 4: Click &amp;ldquo;Show Captions&amp;rdquo;, it should display a captions board:
&lt;img src="https://blog.hackerpie.com/images/posts/zoom-automated-captions/captions-board.png" alt="captions board">
&lt;/p>
&lt;p>That&amp;rsquo;s all! You can begin your speech and it will recognize your voice and transform to live captions automatically! So cool!&lt;/p>
&lt;h1 id="references">References&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://support.zoom.us/hc/en-us/articles/8158289360141">Enabling automated captions&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>stimulus.js 初体验</title><link>https://blog.hackerpie.com/posts/frontend/stimulus-js-early-experience/</link><pubDate>Sun, 31 Jul 2022 09:46:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/frontend/stimulus-js-early-experience/</guid><description>&lt;p>&lt;code>stimulus.js&lt;/code> 框架是一个轻量的 JavaScript 框架，由大名鼎鼎的 Basecamp 公司开发，也就是 Ruby on Rails 框架核心开发团队所在的公司。老早就听说了 stimulus.js 框架，但是没有实际使用过。最近刚好在自己的一个小项目中有了实践的机会，有了一些心得体会，总结分享一下。&lt;/p>
&lt;p>提醒：如果想快速体验 stimulus.js 做出来的 demo，可以看看这个 &lt;a href="https://github.com/chloerei/todomvc-stimulus">todomvc-stimulus&lt;/a>。&lt;/p>
&lt;h1 id="一个克制的前端-javascript-框架">一个克制的前端 JavaScript 框架&lt;/h1>
&lt;p>谈起对 &lt;code>stimulus.js&lt;/code> 框架总的印象，我觉得这是一个非常克制的前端 JavaScript 框架。它聚焦于&lt;strong>在 HTML 元素与 JavaScript 对象的绑定&lt;/strong>这件事情上，并且这种绑定是单向的，不是前端开发中早已非常普遍的双向绑定。除此之外，它没有提供其他额外的功能。&lt;/p>
&lt;p>由于它的克制，&lt;strong>轻量&lt;/strong>是它必然而然的第一个优点。其次，配合其所设计的 &lt;code>controller&lt;/code> 的概念，可以实现交互逻辑里状态的隔离与解耦。最后，它在 &lt;code>controller&lt;/code> 代码的组织上，也让熟悉 Rails 开发的人感到亲切：&lt;strong>约定大于配置&lt;/strong>。每个 &lt;code>controller&lt;/code> 的定义，都需要按照约定，一个 &lt;code>controller&lt;/code> 对应一个文件，放在 &lt;code>controllers&lt;/code> 目录下，且文件名与 &lt;code>controller&lt;/code> 的名字一致。&lt;/p>
&lt;h2 id="stimulusjs-的轻量">&lt;code>Stimulus.js&lt;/code> 的轻量&lt;/h2>
&lt;p>&lt;code>Stimulus.js&lt;/code> 的核心概念非常少，想要上手 &lt;code>stimulus.js&lt;/code> 框架的使用，只有 4 个核心概念是需要了解的。&lt;/p>
&lt;h3 id="controllers">&lt;code>Controllers&lt;/code>&lt;/h3>
&lt;p>&lt;code>Controllers&lt;/code> 是声明了诸如 &lt;code>data-controller=&amp;quot;todos&amp;quot;&lt;/code> 这样的 data 属性的 HTML 元素所绑定的 JavaScript 对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">div&lt;/span> data-controller=&lt;span style="font-style:italic">&amp;#34;todos&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="font-weight:bold">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>stimulus.js&lt;/code> 会自动为所有此类元素实例化对应的 controller，每个此类元素各自绑定一个实例。以上述例子来说，&lt;code>stimulus.js&lt;/code> 会自动查找位于 &lt;code>app/javascript/controllers/todos_controller.js&lt;/code> 的文件，并且导入其中导出的默认类，这是一个经典的&lt;strong>约定大于配置&lt;/strong>的做法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// app/javascript/controllers/todos_controller.js
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> { Controller } from &lt;span style="font-style:italic">&amp;#39;stimulus&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">export&lt;/span> &lt;span style="font-weight:bold">default&lt;/span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">extends&lt;/span> Controller {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> connect() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当然，如果不想使用或者无法使用约定的形式，也可以通过 &lt;code>stimulus.js&lt;/code> 提供的函数进行 controller 的显式注册：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>application.register(&lt;span style="font-style:italic">&amp;#34;todos&amp;#34;&lt;/span>, TodosController)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这类元素以及其子孙元素，都是元素绑定的 controller 的可见范围。也就是说，在 &lt;code>stimulus.js&lt;/code> 框架中，controller 的各种操作，只能作用于 controller 绑定的元素以及此元素的子孙元素。这个原则同样适用于嵌套 Controllers 的情况下。&lt;/p>
&lt;p>Controllers 之间可以通过事件的方式相互协作，这个会在后面讲 Actions 的时候再补充讲一下。&lt;/p>
&lt;h3 id="targets">&lt;code>Targets&lt;/code>&lt;/h3>
&lt;p>&lt;code>Targets&lt;/code> 是另一种在 HTML 元素与 JavaScript 对象之间实现绑定的方法，但是它作用于具体的 Controller 之下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">div&lt;/span> data-controller=&lt;span style="font-style:italic">&amp;#34;todos&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;lt;!-- ... --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="font-weight:bold">button&lt;/span> data-todos-target=&lt;span style="font-style:italic">&amp;#34;addBtn&amp;#34;&lt;/span>&amp;gt;Add&amp;lt;/&lt;span style="font-weight:bold">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="font-weight:bold">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>声明 target 的规则是 &lt;code>data-&amp;lt;controller&amp;gt;-target=&amp;lt;target-name&amp;gt;&lt;/code>，相应的，需要在 controller 声明绑定的对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// app/javascript/controllers/todos_controller.js
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> { Controller } from &lt;span style="font-style:italic">&amp;#39;stimulus&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">export&lt;/span> &lt;span style="font-weight:bold">default&lt;/span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">extends&lt;/span> Controller {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stitic target = [&lt;span style="font-style:italic">&amp;#34;addBtn&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成了 target 的绑定之后，就可以按照 stimulus.js 对 targets 的约定，在 controllers 方法中使用类似 &lt;code>this.addBtnTarget&lt;/code> 或者 &lt;code>this.addBtnTargets&lt;/code> （针对有多个 HTML 元素绑定了同一个 Target 的情况）来访问这些绑定的 HTML 元素了。&lt;/p>
&lt;h3 id="controllers-和-targets-的生命周期回调">&lt;code>Controllers 和 Targets 的生命周期回调&lt;/code>&lt;/h3>
&lt;p>上面说的 Controllers 和 Targets，都是 HTML 元素和 JavaScript 对象之间的绑定功能，因为 HTML 元素随着浏览器的加载以及后续的 DOM 操作，就带来了一个问题，这些对象的生命周期是怎样的？&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-plantuml" data-lang="plantuml">@startuml
(*) --&amp;gt; &amp;#34;initialize()&amp;#34;
--&amp;gt; &amp;#34;[name]TargetConnected(target: Element)&amp;#34;
--&amp;gt; &amp;#34;connect()&amp;#34;
--&amp;gt; &amp;#34;[name]TargetDisconnected(target: Element)&amp;#34;
--&amp;gt; &amp;#34;disconnect()&amp;#34;
@enduml
&lt;/code>&lt;/pre>&lt;p>这几个生命周期的回调函数都与 DOM 的变化紧密相关，一般来说看这几个条件：&lt;/p>
&lt;ul>
&lt;li>元素是否存在？&lt;/li>
&lt;li>绑定的标识是否存在元素的属性列表中，比如 &lt;code>data-controller&lt;/code> 或者 &lt;code>data-&amp;lt;controller&amp;gt;-target&lt;/code>？&lt;/li>
&lt;/ul>
&lt;p>当条件从部分或者全部不满足变为满足时，则 connect 类型的回调函数被调用；相反，如果由于 DOM 的一些操作导致不再满足全部条件时，disconnect 类事件的回调函数被调用。&lt;/p>
&lt;p>controllers 可以在 &lt;code>connect()&lt;/code> 回调中定义初始化的工作，比如 controller 的一些状态的初始化，相应的，&lt;code>[name]TargetConnected&lt;/code> 也可以用于某个 target 的初始化。&lt;/p>
&lt;h3 id="actions">&lt;code>Actions&lt;/code>&lt;/h3>
&lt;p>Actions 是 &lt;code>stimulus.js&lt;/code> 中的事件回调机制，类似 HTML 中 &lt;code>onclick&lt;/code>、&lt;code>onchange&lt;/code> 一类的语法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">div&lt;/span> data-controller=&lt;span style="font-style:italic">&amp;#34;todos&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;lt;!-- ... --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="font-weight:bold">button&lt;/span> data-todos-target=&lt;span style="font-style:italic">&amp;#34;addBtn&amp;#34;&lt;/span> data-action=&lt;span style="font-style:italic">&amp;#34;click-&amp;gt;todos#add&amp;#34;&lt;/span>&amp;gt;Add&amp;lt;/&lt;span style="font-weight:bold">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="font-weight:bold">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Actions 支持多个事件回调声明，这样同时也方便了实现 Controllers 之间的协作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">div&lt;/span> data-controller=&lt;span style="font-style:italic">&amp;#34;todos submitter&amp;#34;&lt;/span>&amp;gt; &lt;span style="font-style:italic">&amp;lt;!-- 注意，这里使用了多个 controller 绑定 --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;lt;!-- ... --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;lt;&lt;span style="font-weight:bold">button&lt;/span> data-todos-target=&lt;span style="font-style:italic">&amp;#34;addBtn&amp;#34;&lt;/span> data-action=&lt;span style="font-style:italic">&amp;#34;click-&amp;gt;todos#add todos:added-&amp;gt;submitter#submit&amp;#34;&lt;/span>&amp;gt;Add&amp;lt;/&lt;span style="font-weight:bold">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="font-weight:bold">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// app/javascript/controllers/todos_controller.js
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">import&lt;/span> { Controller } from &lt;span style="font-style:italic">&amp;#39;stimulus&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">export&lt;/span> &lt;span style="font-weight:bold">default&lt;/span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">extends&lt;/span> Controller {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// do something to maintain the status of todos controller
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">this&lt;/span>.dispatch(&lt;span style="font-style:italic">&amp;#34;added&amp;#34;&lt;/span>, {detail: {todos: [xxxx]}}}})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// app/javascript/controllers/submitter_controller.js
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">import&lt;/span> { Controller } from &lt;span style="font-style:italic">&amp;#39;stimulus&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">export&lt;/span> &lt;span style="font-weight:bold">default&lt;/span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">extends&lt;/span> Controller {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> submit(event) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">const&lt;/span> todos = event.detail.todos; &lt;span style="font-style:italic">// extract event data
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// do something else
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以这个例子来说，程序执行的流程是这样的：&lt;/p>
&lt;ol>
&lt;li>用户点击 Add 按钮后，按钮触发的 &lt;code>click&lt;/code> 事件触发了对 &lt;code>todos&lt;/code> controller 的 &lt;code>added&lt;/code> 的方法的回调；&lt;/li>
&lt;li>&lt;code>added&lt;/code> 方法执行完自身的核心逻辑后，通过调用 &lt;code>this.dispatch&lt;/code> 方法触发 &lt;code>todos:added&lt;/code> 事件，注意这里的 &lt;code>todos:&lt;/code> 前缀是框架自动加上的；&lt;/li>
&lt;li>&lt;code>todos:added&lt;/code> 事件的产生，触发了对 &lt;code>submitter&lt;/code> controller 的 &lt;code>submit&lt;/code> 方法的回调。&lt;/li>
&lt;/ol>
&lt;p>就这样，通过抽象出不同的 controllers，实现逻辑的分离和解耦，再通过事件机制，将逻辑实现拼装和编排。&lt;/p>
&lt;p>理解了上面这 4 个核心概念，就足以使用 &lt;code>stimulus.js&lt;/code> 开发出一个交互相对简单的前端逻辑了。当然，&lt;code>stimulus.js&lt;/code> 还有其他几个概念，但是在我看来只是一些锦上添花的功能，这里就没必要赘述了。&lt;/p>
&lt;h1 id="也谈谈-stimulusjs-不适合的场景">也谈谈 &lt;code>stimulus.js&lt;/code> 不适合的场景&lt;/h1>
&lt;p>尽管是一个小项目，但是在使用 &lt;code>stimulus.js&lt;/code> 的过程中，也遇到了一些觉得比较繁琐的问题，这些问题体现在：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>缺乏 DOM 操作的封装&lt;/strong>：因为 &lt;code>stimulus.js&lt;/code> 只提供 HTML 元素与 JavaScript 对象之间的绑定，并没有提供对 DOM 操作的封装，所以在需要操作 DOM 的时候，就会经常需要直接使用原生 DOM 对象的操作，比如 &lt;code>Element.classList.add()&lt;/code> 一类，如果是在早期的浏览器中，还需要担心兼容性问题等，但是好在现在的浏览器兼容性问题已经少了很多，这倒不是太大的问题；&lt;/li>
&lt;li>&lt;strong>缺乏前端渲染的支持&lt;/strong>：因为 &lt;code>stimulus.js&lt;/code> 中的绑定并非双向绑定，在一些需要根据 JavaScript 对象渲染不同页面内容或者视觉效果的情况下，如果不借助其他框架的支持，就只能编写各种字符串插值，以及 &lt;code>Element.innerHTML = xxxx&lt;/code> 的代码，同样效率比较低。&lt;/li>
&lt;/ol>
&lt;p>所以，总结来说，如果你的前端页面是一个重交互的页面，可能只使用 &lt;code>stimulus.js&lt;/code> 并不是一个明智之选。以我自己来选择的话，如果是一些内容类的轻交互场景，比如博客或者论坛，一般需要交互的就是评论区，简单的文本输入以及追加展示等，我觉得用 &lt;code>stimulus.js&lt;/code> 会比较舒服，轻量，又是原汁原味的 DOM；但是其他情况下，我可能会直接上 &lt;code>vue.js&lt;/code> 之类功能更全面的框架，最大程度减少在页面与逻辑之间状态同步的代码。&lt;/p>
&lt;h1 id="使用-stimulusjs-踩过的坑">使用 &lt;code>stimulus.js&lt;/code> 踩过的坑&lt;/h1>
&lt;ol>
&lt;li>&lt;strong>在 Controllers scope 之外的 action 无法回调到 Controller 的方法&lt;/strong>&lt;br>
这个问题最开始排查了一些时间，一直没想明白为什么，后来才顿悟，原来是因为踩了 Controller scope 的坑。因为我的 action 声明需要回调的 controller 在当前 DOM 中不在可见范围，于是触发回调失败。&lt;/li>
&lt;li>&lt;strong>先于 controller 初始化前触发的 action 无法回调到 Controller 的方法&lt;/strong>
这个问题是因为我在代码中声明了一个 action，并且在 controller 中也执行了 &lt;code>dispatch&lt;/code>，但是此时因为目标的 controller 还没有初始化，导致看似代码没有任何语法或者使用错误，但是 action 无可能触发回调成功。&lt;/li>
&lt;/ol>
&lt;h1 id="相关资料链接">相关资料链接&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://stimulus.hotwired.dev/">stimulus.js&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/chloerei/todomvc-stimulus">todomvc-stimulus&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://bundlephobia.com/package/stimulus@3.1.0">bundlephobia:stimulus@3.1.0&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Golang 错误处理和日志打印的 5 点建议</title><link>https://blog.hackerpie.com/posts/programming-paradigm/golang-error-logs/</link><pubDate>Sun, 12 Jun 2022 14:49:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/programming-paradigm/golang-error-logs/</guid><description>&lt;p>Golang 语言语法中，错误处理机制是一个非常有特色的设计，它是基于&lt;a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B">防御性编程&lt;/a>思想的设计。不过今天这篇文章不讨论 Golang 错误处理的语法设计问题，相反，今天想思考的是，Golang 里的错误日志应该怎样处理以及打印比较好。&lt;/p>
&lt;h1 id="golang-中错误处理和日志打印的-5-点建议">Golang 中错误处理和日志打印的 5 点建议&lt;/h1>
&lt;ol>
&lt;li>使用错误栈的方式；&lt;/li>
&lt;li>使用逻辑栈信息，而非代码调用栈；&lt;/li>
&lt;li>使用 &lt;code>fmt.Errorf&lt;/code>，不用 &lt;code>pkg/errors&lt;/code> 第三方模块；&lt;/li>
&lt;li>避免使用依赖标准库 &lt;code>fmt&lt;/code> 格式化字符串的日志方法；&lt;/li>
&lt;li>转换外部错误，基于内部错误类型判断。&lt;/li>
&lt;/ol>
&lt;h1 id="使用错误栈的方式">使用错误栈的方式&lt;/h1>
&lt;p>我从转 Golang 开发以来，从看过的 Golang 代码以及自己的实践来说，大概会有以下几种个人认为不是太合理的错误日志打印方式：&lt;/p>
&lt;ol>
&lt;li>每一个函数调用处在发现错误时都打印错误信息；&lt;/li>
&lt;li>约定只在最里层或者最外层函数调用处发现错误时打印错误信息，进一步细分的话，还区分是否会在错误里携带调用栈信息；&lt;/li>
&lt;li>没有明确规范，在整个调用链的任何一处或者多处调用发现错误时都有可能打印错误信息。&lt;/li>
&lt;/ol>
&lt;p>第一种方式，好处是不会遗漏调用链路上的所有调用节点信息，但是在实际应用场景里，服务的线程是并发执行的，不同线程打印的日志行之间相互交错，这种方式打印的同一个链路上的日志非常散乱，导致尽管日志里有全部错误相关的日志，但是却难以简单快速过滤出相关而非干扰的日志行，所谓的好处名存实亡，还占据大量磁盘空间。&lt;/p>
&lt;p>第二种方式，最大的问题是可能缺失对于错误排查所需的一些上下文信息。大多数函数调用都发生在跨层代码逻辑的调用上，如果只在最里层调用处打印错误，则一般缺少最外层请求的大多数参数信息，想象一个存储层代码调用的例子。而另外一种思路是通过记录代码调用栈，可以帮助开发人员还原程序执行路径，进而通过阅读源码以及推理还原请求的上下文信息，这种方式确实能够提高问题排查处理的效率。但是只是纯粹代码调用栈信息的话，一方面会有大量业务无关的代码栈信息可能被记录到日志造成存储空间浪费，另一方面是仍旧可能缺失一些关键的上下文信息，这些信息可能也是问题定位的必要元素。&lt;/p>
&lt;p>第三种方式，本质上是开发者对错误处理本身缺乏思考以及团队缺乏相关的编码规范，看起来这种问题挺低级，但是并不少见。这种自然是最应该避免的。我在此之前，自己也没有好好思考过这个问题。&lt;/p>
&lt;p>第一第二种方式，想要有效定位错误根源，本质上都是需要记录错误发生时的调用栈信息，以便我们知道错误是怎么一路出现的，所以我们得到第一个共识：&lt;strong>错误需要携带调用栈信息&lt;/strong>。&lt;/p>
&lt;h1 id="使用逻辑栈信息而非代码调用栈">使用逻辑栈信息，而非代码调用栈&lt;/h1>
&lt;p>顺着第一点，我们明白了调用栈信息的重要性。关于调用栈，一种最直观的方式就是程序的函数调用栈，这种方式一定程度上并不是面向人的，尽管它详细记录了每个调用栈所在的源代码文件以及行数。比如 Golang 程序在遇到 panic 中打印的调用栈信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>panic: a problem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goroutine 1 [running]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>main.main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> /tmp/sandbox4213436970/prog.&lt;span style="font-weight:bold">go&lt;/span>:15 +0x27
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Program exited.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式看起来，往往只是一堆文件名和函数名的栈信息，避免不了需要回到源码中进行阅读，如果不是熟悉业务的开发人员，则可能难以快速理解问题产生的原因。&lt;/p>
&lt;p>在我看来，另外一种思路是，如果我可以人为地在代码中主动记录错误发现时所在的位置以及参数等，不也是一种调用栈的思想吗？而且，这种方式下，我还可以额外增加必要的上下文信息。比如我期待拥有类似这样的日志来回溯错误发生的过程，它最大的优点是面向开发人员友好以及偏业务描述的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>handle upload failed, caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parse file failed, format: JSON,caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> open file failed, caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file not found, path: /path/to/file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种日志下，信息是偏向于开发者易于理解的，阅读下来，很容易理解程序的目的以及所遇到的异常情况。日志里的“handle upload failed” 等是一种逻辑上的调用链路，而“format: JSON”以及“path: /path/to/file” 则是必要的上下文信息。&lt;/p>
&lt;p>具体到 Golang 的设计的考虑，如果需要在错误中获取被调函数的调用栈信息，则需要依赖 Golang 的运行时实现，这将会导致程序比较明显的性能开销。&lt;/p>
&lt;p>所以，综合考虑错误信息的引导性以及对程序的性能友好，&lt;strong>应该使用逻辑栈信息，而避免使用代码调用栈&lt;/strong>。&lt;/p>
&lt;h1 id="使用-fmterrorf不用-pkgerrors-第三方模块">使用 &lt;code>fmt.Errorf&lt;/code>，不用 &lt;code>pkg/errors&lt;/code> 第三方模块&lt;/h1>
&lt;p>这一点是第2点的延伸。&lt;/p>
&lt;p>在早期的 Golang 版本中，标准库中并没有对于错误栈信息的支持，从 Golang 1.13 开始，Golang 在 &lt;code>fmt.Errorf&lt;/code> 标准库函数中增加了一个新的格式化占位符 &lt;code>%w&lt;/code> 的支持，&lt;code>w&lt;/code> 是 Wrap 的缩写，意即对原始错误对象进行一层包装。比如为了实现上节的逻辑栈，代码类似：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cause := errors.New(&lt;span style="font-style:italic">&amp;#34;file not found, path: /path/to/file&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := fmt.Errorf(&lt;span style="font-style:italic">&amp;#34;open file failed, %w&amp;#34;&lt;/span>, cause)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = fmt.Errorf(&lt;span style="font-style:italic">&amp;#34;parse file failed, format: JSON, %w&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = fmt.Errorf(&lt;span style="font-style:italic">&amp;#34;handle upload failed, %w&amp;#34;&lt;/span>, err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(err) &lt;span style="font-style:italic">// output: handle upload failed, parse file failed, format: JSON, open file failed, file not found, path: /path/to/file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Golang 1.13 除了 &lt;code>fmt.Errorf&lt;/code> 的这个新功能，相应地在 &lt;code>errors&lt;/code> 标准库中也增加了 &lt;code>errors.Is&lt;/code> 以及 &lt;code>errors.As&lt;/code> 两个新函数，前者用于判断制定错误的错误链上是否存在特定的错误值，而后者用于尝试将 &lt;code>error&lt;/code> 值转换为具体的错误值。在此不展开，有兴趣的朋友可以点击&lt;a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html">《Go语言(golang)新发布的1.13中的Error Wrapping深度分析》&lt;/a>一文了解更多用法。&lt;/p>
&lt;p>值得一提的是，Golang 1.13 的这个新特性，应该是源自 &lt;a href="github.com/pkg/errors">pkg/errors&lt;/a> 这个第三方包的设计，所以早期大家可能会使用其实现上面的错误栈：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cause := errors.New(&lt;span style="font-style:italic">&amp;#34;file not found, path: /path/to/file&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err := errors.WithMessage(cause, &lt;span style="font-style:italic">&amp;#34;open file failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = errors.WithMessage(err, &lt;span style="font-style:italic">&amp;#34;parse file failed, format: JSON&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err = errors.WithMessage(err, &lt;span style="font-style:italic">&amp;#34;handle upload failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(err) &lt;span style="font-style:italic">// output: handle upload failed: parse file failed, format: JSON: open file failed: file not found, path: /path/to/file
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>但是由于 Golang 已经实现这个错误栈的功能，&lt;code>pkg/errors&lt;/code> 已经将项目归档，并且建议开发人员使用 Golang 官方实现的版本，这也是为了应用程序本身更好的向前兼容 Golang 2.0。&lt;/p>
&lt;h1 id="避免使用依赖标准库-fmt-格式化字符串的日志方法">避免使用依赖标准库 &lt;code>fmt&lt;/code> 格式化字符串的日志方法&lt;/h1>
&lt;p>在标准库的日志功能实现中，其基于 &lt;code>fmt&lt;/code> 标准库实现，而后者又重度依赖于反射的工作，这些都导致了比较高的 CPU 开销以及细碎的内存分配，前者通过挤占 CPU 时间片直接影响程序性能，而后者因为加大了运行时垃圾回收工作负担间接影响程序性能。&lt;/p>
&lt;p>那怎么办好呢？可以考虑类似 &lt;a href="https://github.com/uber-go/zap">uber-go/zap&lt;/a> 这类针对性能优化的第三方日志库。zap 主要通过几个角度优化性能：&lt;/p>
&lt;ol>
&lt;li>使用延迟加载机制避免不必要的计算，比如有些日志需要 Debug 日志级别才需打印，那在以 Info 日志级别启动的程序中，这部分日志其实是不打印的，不打印也就没有计算的需要，所以延迟加载有助于在高级别日志场景下直接省略格式化日志的工作；&lt;/li>
&lt;li>使用显式的 Fields 机制，zap 可以避免大量的反射需求，另外结合零分配的 JSON 序列化编码器，提高了性能。&lt;/li>
&lt;/ol>
&lt;h1 id="转换外部错误基于内部错误类型判断">转换外部错误，基于内部错误类型判断&lt;/h1>
&lt;p>所谓外部错误，是指由自身应用程序源代码之外所定义的错误，比如系统调用的错误、rpc 服务返回的错误以及数据库读写操作错误等。应用程序设计讲究分层与解耦，如果没有对底层函数调用遇到的外部错误进行转换，则意味着上层逻辑与下层实现的耦合，破坏了低耦合性。比如，对于一个业务逻辑层的代码来说，它所依赖的数据库层函数应该给它统一的内部错误，比如 &lt;code>DBConnectFailed&lt;/code>，而不是后者依赖某个 SDK 所定义的 &lt;code>MySQLError&lt;/code> 或者 &lt;code>PGError&lt;/code> 这类错误。&lt;/p>
&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B">防御性编程&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html">Go语言(golang)新发布的1.13中的Error Wrapping深度分析&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/uber-go/zap/blob/master/README.md">uber-go/zap: README&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>保持高效与专注的 5 个习惯</title><link>https://blog.hackerpie.com/posts/work-efficiency/5-ways-to-keep-high-efficiency-and-focus/</link><pubDate>Sun, 22 May 2022 11:07:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/work-efficiency/5-ways-to-keep-high-efficiency-and-focus/</guid><description>&lt;p>日常工作中，可能由于各种各样的信息干扰和诱惑，人在保持高效工作与专注上要面对的挑战其实不小。回顾我自己的一些工作经验和体会，我总结了 5 个能帮助我保持专注和高效的习惯：&lt;/p>
&lt;ol>
&lt;li>拒绝注意力迷宫——不要在电脑上登录微信等常用的 IM 工具，关闭手机通知提醒&lt;/li>
&lt;li>异步沟通——直接留言与文档协作&lt;/li>
&lt;li>延迟学习——意外的发现放进 Todo list&lt;/li>
&lt;li>劳逸结合——让身体舒展，让脑子清理&lt;/li>
&lt;li>佩戴耳机，聆听音乐&lt;/li>
&lt;/ol>
&lt;h1 id="1-拒绝注意力迷宫不要在电脑上登录微信等常用的-im-工具关闭手机通知提醒">1. 拒绝注意力迷宫——不要在电脑上登录微信等常用的 IM 工具，关闭手机通知提醒&lt;/h1>
&lt;p>微信等常用社交软件就像一个黑洞，吞噬人的大量时间。只是由于一条新的消息到达加上你想要消灭小红点的强迫症，你自己很快就陷入各种信息的诱惑之中了，看看这种可能的注意力转移路径：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/lost.jpg" alt="">
&lt;figcaption>图1：注意力迷宫&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>而成功逃出迷宫可能得是一段可观的时间之后的事情了。&lt;strong>我不得不尝试关闭手机上的各种社交软件的通知，这样很大程度降低了我拿起手机查看的频率&lt;/strong>。但是慢慢地，桌面端的微信客户端功能越来越多，先是可以查看朋友圈了，后来又可以刷视频号了……于是我又开始发现，桌面版的微信同样会让我很容易走神，我就开始不在上班时间登录桌面版微信，这同样能够帮助我专注于每天的工作。&lt;/p>
&lt;p>屏蔽了手机通知，主动不去在电脑上登录微信，看似我跟不上很多信息了，但是至少我专注了，而且事实是，现在互联网上的很多信息同质化严重，真假难辨，你没有必要跟上。&lt;/p>
&lt;h1 id="2-异步沟通直接留言与文档协作">2. 异步沟通——直接留言与文档协作&lt;/h1>
&lt;p>异步沟通是沟通双方不需要对收到的消息立马进行回应，而是等到自己某个空档或者习惯的时间窗口再统一进行消息阅读和回复等，比如电子邮件天然就是一种异步沟通的典范，只是国人大都不习惯邮件沟通的这种方式。&lt;/p>
&lt;p>之所以提倡异步沟通，对我个人而言，主要是两方面的需要：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降低思维上下文切换的开销&lt;/strong>：因为人在切换要做的事情的时候，是需要回想事情的缘由、进度以及既定思路的，这些就是开销；&lt;/li>
&lt;li>&lt;strong>降低焦虑&lt;/strong>：焦虑是因为容易纠结别人消息一直未读、已读不回等，仿佛对方不回复，自己就没法继续工作了。想要不焦虑，只能调整自己的预期，预期大家都是异步沟通，也就平和了。&lt;/li>
&lt;/ul>
&lt;p>怎么做呢？常见分两种吧。&lt;/p>
&lt;p>&lt;strong>第一种，有一个零碎的事情需要别人帮忙提供意见或者决策，直接留言&lt;/strong>。以前我总是觉得有什么事情等到对方有空了再说，但是这样事情可能就拖过头了。现在的我会倾向于：&lt;strong>想要沟通的事情，如果不是太复杂，一两句话就能说清楚的，那我就直接在 IM 软件里给对方留言&lt;/strong>，之后这个事情我也就不用担心自己会忘了，同时我也可以放心去做其他事情了，至于他是即时回复还是晚点回复，对我都不是问题，因为我一定是晚点才会回来看消息的。这里其实还有个好处，我总觉得我自己多少有些拖延症，但是通过这种有事早点留言的方式，我就不得不在更快的时间内处理完这个事情，因为一旦对方回复了我，我真的就不好意思拖着了。&lt;/p>
&lt;p>&lt;strong>第二种，涉及团队间沟通等复杂问题的，以协作文档形式沟通&lt;/strong>。最近我负责的业务需要接入另一个中台团队他们的服务，但是因为只有一份简单的文档，又缺少很多上下文，所以很多东西看不明白。在架构师同事帮忙拉了群之后，我先是很认真地整理了一份问题清单，上面写清楚每一个问题的背景（e.g. 我想要用他们的服务做什么事），以及我参考的他们的文档的出处（e.g. 我理解的某个接口是我可以用来完成我想做的事），以及我的具体问题是什么（e.g. 有些地方跟我的需求有出入），同时尽可能以我自己的理解复述了一边，在文档上请求对方给予确认。到了第二个工作日的时候，很让我惊讶的是，同事在看到文档后，并没有在文档上直接回复，而是复制了问题再逐个发回群里逐个回复。后来我将他的回复拷贝回文档上，而他可能也意识到了我的用意，才开始在文档上直接回复。就这样，一次基于文档的异步沟通就这么完成，而且信息很聚焦，对于一个问题，沟通过程和结论都在一份文档里。&lt;strong>文档沟通的形式，一个是便于异步沟通，双方不用反复翻看聊天记录寻找上下文；另一个是帮我自己理清楚真正的问题，以及问题的条理表达，这既是对对方时间的尊重，也是确保沟通高效的方式。&lt;/strong>&lt;/p>
&lt;h1 id="3-延迟学习意外的发现放进-todo-list">3. 延迟学习——意外的发现放进 Todo list&lt;/h1>
&lt;p>刚开始入行工作没多久的时候，我就养成了一种至今都在使用的习惯：延迟学习。这种延迟学习不是指什么知识的学习都要延迟，而是指一些与当前需要优先完成的事情无关的有趣的东西都可以放进 Todo list，可以等业余时间再去学习研究，享受知识的快乐。&lt;/p>
&lt;p>举个稍微具体的例子，程序员写代码的时候，为了解决一个问题，都会尝试在搜索引擎上寻找答案或者灵感，往往在这个时候会发现一些自己从来都不知道的技术，这些技术或者有趣或者酷炫，&lt;/p>
&lt;blockquote>
&lt;p>“哇！&lt;code>(✧◡✧)&lt;/code>好想赶紧学会掌握住啊！”&lt;/p>
&lt;/blockquote>
&lt;p>就像一个沙漠里寻找水源的人突然发现了一箱金子，这个意外发现很让人激动，但是容易让人忘了目标。而我在工作过程中也确实因为各种意外收获的技术思路而拓展了很多技术视野，当然，都是在没有影响本职工作的前提下，怎么做的呢？用 Todo list！&lt;/p>
&lt;p>最开始的时候我使用了 Trello 来分门别类管理我想延后完成的一些技术学习：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/my-trello-boards.png" alt="">
&lt;figcaption>图2：我的 Trello 看板&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>Blog：是我一些已经基本掌握的知识，我想要在业余时间整理分享的内容&lt;/li>
&lt;li>labs：是我一些临时想到的技术上想要折腾的点子，放在心里手会发痒，所以先写下来，就不会总惦记着了&lt;/li>
&lt;li>Topics：是我一些想要在一些技术分享会上交流的想法，可能会整理成幻灯片等&lt;/li>
&lt;/ul>
&lt;p>比如，我的 Blog 看板下就有这些：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/Blog-board.png" alt="">
&lt;figcaption>图3：我的 Blog 看板&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>有些点子放了好几年，也都一直没去写，也有些点子很快就放弃了，也有一些干一半，还有一些真的就去写了，都很正常。有些想法当时很冲动，之后再去看一眼，就觉得实在没必要，所以延后是一种验证自己是否只是三分钟热度的好办法，真正的热爱会在之后依旧充满干劲。&lt;/p>
&lt;p>除了记录点子，我也会把过程中想到的、看到的相关片段记录到对应卡片上，比如一些截图、日志或者自己给自己留的问题：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/card-example.png" alt="">
&lt;figcaption>图4：一个记录过程中零碎信息的示例&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>而现在，因为喜欢使用 Notion，我在 Notion 记录了很多类似的东西，一旦后续整理完写成博客后，就会将其从Notion上删除：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/notion-list.png" alt="">
&lt;figcaption>图5：我在 Notion 上记录的东西&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>在日常中，将这些意外的惊喜都放进一个延迟处理的地方，会让我自己不至于偏离方向，更好地回归目标本身。就像是那个意外发现金子的寻水人，最好还是先做了个记号，然后要先找到水活下去，最后有可能的话，再回去带走金子。&lt;/p>
&lt;h1 id="4-劳逸结合让身体舒展让脑子清理">4. 劳逸结合——让身体舒展，让脑子清理&lt;/h1>
&lt;p>保持高效工作的其中一个好方法，其实是适当停下工作。以我自己为例，过去我以像一头牛一样埋头苦干为荣，所以可能一埋头就是一整个半天，但是往往过程中不胜困顿，写着代码快睡着的体验也是常有的。最糟糕的是，可能干完才发现自己干错方向了，犁了半天的田，犁到别人家的田里去了。后来也是无意间发现，反倒是时不时停下来休息一下，当场回顾自己的工作，更能发现潜在的问题，更早纠正错误的方向。&lt;/p>
&lt;p>在这点上，我的个人实践是使用 &lt;a href="https://hovancik.net/stretchly/">Stretchly&lt;/a> 这个软件，它可以帮助用户在设定的时间间隔里弹出全屏的休息提醒，让你记得休息和调整。我的个人习惯是每 55 分钟休息 5 分钟，在这 5 分钟里，我会走动一下，扭扭腰，远眺一下，上个洗手间，吃个水果啥的，这样既可以避免自己长时间保持一个姿势，也可以让自己恢复几分清醒，我个人是好几次在这个过程突然发现自己技术方案上的缺陷。&lt;/p>
&lt;p>对了，我一般也会在这几分钟里查看手机，回复重要消息等。&lt;/p>
&lt;h1 id="5-佩戴耳机聆听音乐">5. 佩戴耳机，聆听音乐&lt;/h1>
&lt;p>佩戴耳机也是一个老生常谈的方法，但是其实我并不提倡长时间佩戴耳机，除了开会，我自己会在两种情况下佩戴耳机：&lt;/p>
&lt;ol>
&lt;li>环境嘈杂：比如周围很多人在讨论；&lt;/li>
&lt;li>我自己很兴奋：比如我很期待接下来的工作内容，我想要有个音乐来助助兴。&lt;/li>
&lt;/ol>
&lt;p>对于听什么，最好是轻音乐或者自己听不懂的音乐，比如韩语歌曲，当然我是轻音乐最多，因为能够安抚内心，让自己平静一些。
&lt;strong>佩戴耳机的另一个好处是，能够帮你屏蔽掉一些不必要的打扰&lt;/strong>，比如有些人看到你戴着耳机，那他可能就会多评估下一个事情是否真的需要当面跟你沟通，也许一些不必要的当面沟通也就这样省略了。&lt;/p>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>工作的高效，一方面是专业技能的得心应手，另一方面是控制自己的注意力不被各种形形色色的东西所分散。上面总结的 5 个习惯：&lt;/p>
&lt;ul>
&lt;li>屏蔽微信等让我减少走神的机会；&lt;/li>
&lt;li>异步沟通让我灵活工作，减少焦虑；&lt;/li>
&lt;li>延迟学习让我聚焦目标，不受突如其来的诱惑控制，但是也不耽误我多学习新的技能；&lt;/li>
&lt;li>劳逸结合让我更注重工作的策略性；&lt;/li>
&lt;li>适度使用耳机可以帮助我静心工作，同时减少干扰。&lt;/li>
&lt;/ul>
&lt;p>诚然，我没有100%的时间里都做到这些，但是总体上我自己是有很大受益的，所以希望能够分享出来，或许能够给其他人提供灵感。&lt;/p></description></item><item><title>多时钟解决雪花算法的时间回拨问题</title><link>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</link><pubDate>Sun, 27 Mar 2022 16:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</guid><description>&lt;p>分布式 ID 生成算法用于在分布式系统中生成全局唯一的 ID 标识，而 twitter 提出的雪花算法便是其中一种知名的算法，其每次会生成一个 64 位的全局唯一整数，算法的基本思想非常巧妙：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> 0 1010......101 1010101010 101010101010
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">\&lt;/span>_/ &lt;span style="">\&lt;/span>___________/ &lt;span style="">\&lt;/span>________/ &lt;span style="">\&lt;/span>__________/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">第&lt;/span>1&lt;span style="">位不使用&lt;/span> 41&lt;span style="">位毫秒时间戳&lt;/span> 10&lt;span style="">位机器&lt;/span>ID 12&lt;span style="">位序列号&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了开头的第 1 位不使用，接下来的 41 位时间戳是从指定的起始时间到当前时间所经历的毫秒数，比如设定系统起始时间为 2022 年 3 月 15 日 0 点整，则在 2022 年 4 月 1 日中午 12:00:00.123 时，此时间戳的值应该为 &lt;code>1,512,000,123&lt;/code>，整个时间戳片段，支持最多 &lt;code>69.7&lt;/code> 年，这显然也超出了绝大多数 IT 系统的存活年限。&lt;/p>
&lt;p>而 10 位机器 ID，对应最多容纳一个 1024 个 ID 生成器实例的分布式集群，12 位序列号从 0 到 4095 周而复始连续递增，可以支持单个实例每毫秒 4096 次 ID 生成请求，意味着整个 ID 生成器实例的集群，理论上每毫秒便可以支持最多 &lt;code>4194304&lt;/code> 个 ID 生成，效率非常高。&lt;/p>
&lt;p>雪花算法生成的 ID 的全局唯一的理论基础是全局唯一性与单实例唯一性的结合，全局唯一性由唯一的机器 ID 保证，不同的机器ID保证不同实例生成的 ID 必然不会一致，而单实例唯一由同一毫秒结合不同的序列号来保证，这里的序列号只能做到理论上限，即理论上一毫秒内不会有超过 4096 次的请求。&lt;/p>
&lt;h2 id="雪花算法的时间回拨问题">雪花算法的时间回拨问题&lt;/h2>
&lt;p>时间回拨问题是指系统在运行过程中，可能由于网络时间校准或者人工设置，导致系统时间主动或被动地跳回到过去的某个时间：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/snowflake/time-back.png" alt="时间回拨">
&lt;figcaption>时间回拨&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>由于雪花算法重度依赖机器的当前时间，所以一旦发生时间回拨，将有可能导致生成的 ID 可能与此前已经生成的某个 ID 重复（&lt;strong>前提是刚好在同一毫秒生成 ID 时序列号也刚好一致&lt;/strong>），这就是雪花算法最经常讨论的问题——时间回拨。在雪花算法原本的实现中，针对这种问题，算法本身只是返回错误，由应用另行决定处理逻辑，如果是在一个并发不高或者请求量不大的业务系统中，错误等待或者重试的策略问题不大，但是如果是在一个高并发的系统中，这种策略显得过于粗暴。&lt;/p>
&lt;h2 id="解决雪花算法的时间回拨问题的一种思路多时钟">解决雪花算法的时间回拨问题的一种思路——多时钟&lt;/h2>
&lt;p>网上有很多对于解决雪花算法的时间回拨问题的思路和讨论，我这里介绍的是一种基于扩展位的思路，但是为了便于理解，我自己取名为多时钟的雪花算法。&lt;/p>
&lt;p>算法的思路也比较简单，既然时间回拨问题的本质上是时间回到了“过去”，那么哪怕回到了过去，只要实现“此时间非彼时间”不就实现时间唯一了？顺着这个思路想的话，一种直观的思路是：&lt;strong>既然我已经发现了时间回拨，那我就认为原先的“时钟”已经不可用，使用一个新的“时钟”即可&lt;/strong>，并将新的当前时间仍为是新时钟的时间。&lt;/p>
&lt;h3 id="算法描述">算法描述&lt;/h3>
&lt;p>类似经典的雪花算法，基于多时钟改进的雪花算法需要占用少量的位用于存储时钟 ID，所需的位数只能从原有的时间戳、机器ID或者序列号中分割，具体业务实现中需要结合业务的并发量、集群规模等综合考虑，这里为了讨论方便，假设从机器 ID 以及序列号中各取 2 位，用于 1 个 4 位的时钟 ID：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> 0 1010......101 0001 10101010 1010101010
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">\&lt;/span>_/ &lt;span style="">\&lt;/span>___________/ &lt;span style="">\&lt;/span>__/ &lt;span style="">\&lt;/span>______/ &lt;span style="">\&lt;/span>________/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">第&lt;/span>1&lt;span style="">位不使用&lt;/span> 41&lt;span style="">位毫秒时间戳&lt;/span> 4&lt;span style="">位时钟&lt;/span>ID 8&lt;span style="">位机器&lt;/span>ID 10&lt;span style="">位序列号&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>于是，新的算法理论上：&lt;/p>
&lt;ul>
&lt;li>还是支持最长 69 年多的运行时间；&lt;/li>
&lt;li>分布式实例规模缩小到 256；&lt;/li>
&lt;li>单实例每毫秒支持最多 1024 次请求；&lt;/li>
&lt;li>单实例支持最多 16 次回拨同一时间范围（如果时间回拨发生在互不交叠的时间段，则理论上可以完美解决时间回拨问题）；&lt;/li>
&lt;/ul>
&lt;p>在具体的实现逻辑上，主要是在每次发现时间回拨（即之前最后一次生成 ID 的时间戳小于等于当前时间戳）的时候，便将时钟 ID 加 1，类似序列号，周而复始。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>timeNow := &lt;span style="">当前系统时间&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> last_time &amp;gt;= timeNow: &lt;span style="font-style:italic">// 时钟回拨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> clock_id = (clock_id + 1) &amp;amp; (1&amp;lt;&amp;lt;4-1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>last_time = timeNow
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>seq := &lt;span style="">下一个序列号&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">return&lt;/span> encode(timeNow, machineID, seq, clock_id)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="场景分析">场景分析&lt;/h3>
&lt;p>还是上面图片中的例子，假如在某一时刻，系统生成 ID，此时时间为 10:15:00，之后系统经历 5 秒后，在另一时刻 10:15:05，系统再次生成 ID，在这段时间里，系统一直使用的时钟为 &lt;code>1&lt;/code>。在下一次生成 ID 时，系统发现 &lt;code>lastTime&lt;/code> 为 &lt;code>10:15:05&lt;/code>，而系统查询机器当前时间为 &lt;code>10:15:00&lt;/code>，判定时间回拨，于是切换时钟为 &lt;code>2&lt;/code>，此时生成的 ID 即会对应于 2 号时钟的 &lt;code>10:15:00&lt;/code>，与此前时钟 1 的 &lt;code>10:15:00&lt;/code> 在逻辑上已经是两个不同的时间，于是生成的 ID 自然不同。&lt;/p>
&lt;h3 id="极端场景进程重启时间回拨">极端场景：进程重启+时间回拨&lt;/h3>
&lt;p>上面的算法，能够很好应对运行过程中的时间回拨问题，但是如果非常不巧，在进程刚好遇到崩溃重启的过程中，系统又正好完成了时间回拨，这个时候，如何保证不会因为使用了相同的时钟而可能产生一样的 ID 呢？一种继续改进的思路是在 ID 生成器初始化的时候，尝试从本地磁盘文件中获取重启前的时钟 ID，并且加 1，意味着每次重启一定不会使用进程退出前的时钟，而在运行过程中，每次切换了时钟之后，都应该把新的时钟 ID 写入磁盘，考虑到性能友好，这个操作尽可能异步完成。&lt;/p>
&lt;h3 id="高并发优化思路时钟-id-复用">高并发优化思路：时钟 ID 复用&lt;/h3>
&lt;p>这个基于多时钟的优化算法，由于需要额外的比特位来存储时钟 ID，而占用了用于控制并发的序列号的比特位，假如系统确实有较高的并发，这里可以考虑的优化是复用时钟 ID：每次在当前时钟下，&lt;strong>一旦当前序列号达到上限重置时，都切换到下一个时钟&lt;/strong>，这样的话，理论上同一毫秒里，并发规模可以达到 2^14，也即是 &lt;code>16384&lt;/code>。大多数情况下，时钟回拨应该是个极少发生的现象，这种复用时钟 ID 的方法，能够更充分地利用好时钟 ID 的 4 个比特位。&lt;/p>
&lt;h2 id="多时钟雪花算法的一些问题">多时钟雪花算法的一些问题&lt;/h2>
&lt;p>当然，这个算法并不完美的，它基于一些假设，同时使用前需要认真考虑一些它仍无法避免的问题：&lt;/p>
&lt;ul>
&lt;li>时间回拨不会频繁发生在同一个时间段（在上面举例中，时间回拨不会在同一时间段上重复发生超过 16 次）；&lt;/li>
&lt;li>递增问题：当时间回拨时，ID 递增性会被破坏，对于需要严格递增的场景，需要考虑其他解决方案，比如基于“历史时间”的改进算法；&lt;/li>
&lt;li>机器ID和序列号空间的评估：如何保证获得全局唯一的机器 ID，也是一个复杂的问题，另外时钟 ID 的引入，会占用额外的比特位，需要综合考虑从哪些比特片段中腾出这些需要留给时钟 ID 的比特位；&lt;/li>
&lt;li>多时钟雪花算法只是缓解了时钟回拨问题，但是不能完全解决时间回拨问题，所以仍然需要考虑一种极端情况下的容错方案，不过既然是极端场景，采用类似错误重试之类的简单方案足矣。&lt;/li>
&lt;/ul>
&lt;h2 id="解决雪花算法时间回拨问题的其他思路">解决雪花算法时间回拨问题的其他思路&lt;/h2>
&lt;ul>
&lt;li>采用历史时间：详见 &lt;a href="https://cloud.tencent.com/developer/news/678423">彻底解决雪花算法时间回拨问题新方案&lt;/a>&lt;/li>
&lt;li>等待时钟校正&lt;/li>
&lt;li>时间追赶&lt;/li>
&lt;li>错误重试&lt;/li>
&lt;/ul>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>通过引入多时钟来实现时间回拨场景下的时间唯一性，理想场景下可无限次应对时间回拨&lt;/li>
&lt;li>多时钟雪花算法可以通过复用时钟ID来优化比特位的利用效率&lt;/li>
&lt;li>多时钟雪花算法也需要结合其他容错处理来应对极端场景下的时间回拨问题&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/news/678423">彻底解决雪花算法时间回拨问题新方案&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1772047">分布式唯一ID解决方案-雪花算法&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>数据库数据加密的 4 种常见思路的对比</title><link>https://blog.hackerpie.com/posts/architecture/data-encrpytion/</link><pubDate>Sun, 20 Mar 2022 13:53:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/architecture/data-encrpytion/</guid><description>&lt;p>最近由于工作需要，我对欧洲的通用数据保护条例做了调研和学习，其中有非常重要的一点，也是常识性的一条，就是需要对用户的个人隐私数据做好加密存储，避免用户隐私明文数据泄露。&lt;/p>
&lt;h1 id="方案分析">方案分析&lt;/h1>
&lt;p>思考如何对用户隐私数据做好加密处理，可以先从分析典型的数据读写链路开始：&lt;/p>
&lt;pre tabindex="0">&lt;code> _________ query _________ read _________
| | ----------------&amp;gt; | | ----------------&amp;gt; | |
| 应用 | | DB | | Disk |
| | &amp;lt;================ | | &amp;lt;================ | |
--------- rows --------- data page ---------
&lt;/code>&lt;/pre>&lt;p>按照此链路分析，可以按照数据加密的着手点，划分数据加密的 4 类解决方案：&lt;/p>
&lt;ul>
&lt;li>应用层加解密：由应用程序自行负责数据的加解密，这是最自由，但也是最繁琐的一种方案；&lt;/li>
&lt;li>DB 前置处理：在数据库服务器开始服务之前嵌入加密逻辑，典型代表是数据库代理服务；&lt;/li>
&lt;li>磁盘存取环节：这种方案的基本思路则是绕到数据库的身后，在文件系统中注入钩子进程，这样可以在磁盘数据读写之前嵌入加密逻辑，一般&lt;/li>
&lt;li>DB 后置处理：在数据库服务之后嵌入加密逻辑，依赖数据库提供的触发器以及函数定制功能等。&lt;/li>
&lt;/ul>
&lt;p>下面就这几类方案展开分析。&lt;/p>
&lt;h2 id="应用层加解密方案">应用层加解密方案&lt;/h2>
&lt;p>采用这种方案的话，数据加解密对数据库无感知，由应用在存入数据前完成加密，在读取数据后完成解密。这种方案的优点是：&lt;/p>
&lt;ul>
&lt;li>迁移性好：因为不依赖任何数据库特性或者操作系统特性，只需要部署代码即可运行；&lt;/li>
&lt;li>实现灵活：逻辑放在应用层，各种定制或者扩展都非常方便进行，可以轻松实现按表/按列的加密存储。&lt;/li>
&lt;/ul>
&lt;p>当时，缺点也非常明显：&lt;/p>
&lt;ul>
&lt;li>影响使用数据库高级特性：比如数据库索引以及执行计划等;&lt;/li>
&lt;li>大幅影响数据库查询性能：比如 Like 的前缀查询以及 Where 的范围查询等，都会因为数据加密后而只能全表扫描；&lt;/li>
&lt;li>开发维护成本高：每次新增需要加解密数据时都需要对应完成开发调试与测试，开发人员在应用里既要关注核心业务逻辑，还要关注大量的数据加解密的逻辑，当有多个应用或者系统需要集成加解密功能时，每个应用或者系统都需要重复建设此能力。&lt;/li>
&lt;/ul>
&lt;p>在应用层实现加解密方案的话，实现上可以考虑结合各类 orm 的回调函数机制，如 golang 中流行的 ORM 框架 gorm 所提供的 Callbacks 机制，又或者是 Ruby on Rails 框架中 Active Record 的 Callbacks 机制，这些机制都能有效帮助我们将业务代码和控制代码进行相互隔离。&lt;/p>
&lt;h2 id="数据库前置处理方案">数据库前置处理方案&lt;/h2>
&lt;p>采用数据库前置处理方案，算是对应用层加解密方案的优化，本质思想是将加解密的关注点独立，从应用内部完全抽离，独立服务，同时实现加解密逻辑的复用性。&lt;/p>
&lt;p>使用数据库前置处理，能够集成应用层加密方案的一些优点，同时解决了后者存在的一些问题：&lt;/p>
&lt;ol>
&lt;li>灵活性：数据库代理同样具备较好的灵活性，可以实现列级的加解密；&lt;/li>
&lt;li>复用性较好：多个应用或者系统不再需要重复建设，使用独立维护服务的数据库代理，能够实现快速的加解密功能的接入；&lt;/li>
&lt;li>较高的透明度：应用开发人员无需在自身内部关注加解密逻辑，但是由于数据库代理的 SQL 兼容性下降，应用开发过程中不得不保持对 SQL 兼容性的理解。&lt;/li>
&lt;/ol>
&lt;p>数据库前置处理方案也有自身的一些缺陷：&lt;/p>
&lt;ol>
&lt;li>稳定性下降，加大运维负担：因为整体架构引入了额外的服务节点，会给整体的服务成本以及问题排障场景增加负担，在遇到数据处理问题时，需要卷入数据库代理服务的维护人员一起排查故障；&lt;/li>
&lt;li>无法利用数据库高级特性：和应用层数据加解密方案类似，此方案下，由于数据加密后经由数据库存储和索引，在查询场景中，涉及范围类型的数据检索都会导致扫表；&lt;/li>
&lt;li>一致性问题：由于需要在数据库代理中维护业务数据表/或列的元信息，引入了代理层的配置信息和业务数据库设计的一致性问题。&lt;/li>
&lt;/ol>
&lt;h2 id="磁盘存取环节透明数据加密">磁盘存取环节：透明数据加密&lt;/h2>
&lt;p>目前各家云服务厂商基本都提供了这个方案的服务，简称透明数据加密（TDE）。这个方案的实现原理比较巧妙，它工作于操作系统层面，作用于数据库数据文件，通过 i/o 的钩子进程，在数据库存储引擎读写数据到文件系统的时候嵌入加解密逻辑，在写入数据前完成加密，而在数据读取后要返回给存储引擎进程之前执行解密，而整个过程对数据库存储引擎是完全透明的。&lt;/p>
&lt;p>这个方案的优点诱人得多：&lt;/p>
&lt;ul>
&lt;li>透明性：因为方案在数据库服务器上发挥作用，所以对应用完全透明，应用仍旧直连数据库，而且完全不用担心 SQL 兼容性问题等；&lt;/li>
&lt;li>支持所有数据库高级特性：由于这套方案同时也是对数据库引擎完全透明，在数据库视角，是否加解密在数据检索逻辑以及执行计划优化、事务管理等各个方面都没有区别，所以这种方案能够完美保留数据库的高级特性；&lt;/li>
&lt;/ul>
&lt;p>当然，没有完美的方案，这个方案存在一定限制：&lt;/p>
&lt;ul>
&lt;li>仅能表级加密：由于这个方案是对数据文件进行的无感加解密，所以它最大的限制是无法实现指定数据表中部分列的加密，当然，如果你的业务里，能够设计出刚好全表或者几乎全部列需要加密的结构，这种限制完全不是问题；&lt;/li>
&lt;li>平台兼容性问题：由于依赖了操作系统层面的设计，所以这套方案可能只能运行于特定的平台之上；另外如果是云场景之下，还需要考虑不同公有云所提供的方案差异，特别是使用方式上的细节差异，这些都可能导致同一套系统在云厂商之间迁移时出现水土不服的问题。&lt;/li>
&lt;/ul>
&lt;p>在我自己的业务系统的设计方案中，我们引入了用户隐私域的概念，在设计上会将用户隐私数据和业务流程数据分离，天然实现用户隐私数据的集中存储，于是全表数据加密对我们是最合适的选择。&lt;/p>
&lt;h2 id="db-后置处理">DB 后置处理&lt;/h2>
&lt;p>DB 后置处理是基于数据库的触发器和自定义函数功能等，在数据库服务器执行查询过程中触发自定义加解密逻辑的执行。这种方案可以说是解决了前面几个方案存在问题：&lt;/p>
&lt;ul>
&lt;li>透明性：DB 后置处理，对应用完全透明；&lt;/li>
&lt;li>数据库高级特性：完全兼容；&lt;/li>
&lt;li>灵活性：可以灵活实现列级数据加密等。&lt;/li>
&lt;/ul>
&lt;p>尽管这个方案看起来也很美，但是它依然不完美：&lt;/p>
&lt;ul>
&lt;li>反模式：我个人一直抗拒在数据库服务器上管理函数或者触发器等，因为这些东西都不易于管理，更不用说实现版本管理等；&lt;/li>
&lt;li>数据库兼容性问题：由于依赖数据库提供的特性，在不得不更换数据库等场景下，这套方案基本无法实现快速迁移。&lt;/li>
&lt;/ul>
&lt;h1 id="汇总对比">汇总对比&lt;/h1>
&lt;p>说了这么多，对比下几套方案的差异：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方案序号&lt;/th>
&lt;th>加密所在环节&lt;/th>
&lt;th>方案简介&lt;/th>
&lt;th>方案案例&lt;/th>
&lt;th>优点&lt;/th>
&lt;th>限制&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>应用&lt;/td>
&lt;td>由应用在存储前自行加密，在检索后自行解密&lt;/td>
&lt;td>orm+各类钩子实现&lt;/td>
&lt;td>灵活/粒度细/兼容性强&lt;/td>
&lt;td>无法对应用透明，增加开发负担/额外的秘钥管理负担&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>数据库前置代理&lt;/td>
&lt;td>在应用和数据库之间加入一层代理服务，由代理服务负责加解密&lt;/td>
&lt;td>腾讯云 CASB&lt;/td>
&lt;td>对应用高程度透明，无开发负担/支持列级别加密&lt;/td>
&lt;td>SQL 语法兼容性下降，对开发不是完全透明/数据库的优化处理、事务处理、并发处理等特性都无法使用/引入额外的环节，性能以及潜在排障负担/数据膨胀厉害，~4.5倍空间膨胀&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>数据库数据文件&lt;/td>
&lt;td>工作在文件系统层面，引擎持久化存储前完成加密，数据文件加载到内存中前解密，内存中保留明文数据&lt;/td>
&lt;td>腾讯云透明数据加密（TDE）&lt;/td>
&lt;td>对应用完全透明/云数据库内置支持，兼容数据库高级特性&lt;/td>
&lt;td>表空间加密，不支持字段级别加密/无法规避 SQL 注入带来的拖库风险&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>数据库后置处理&lt;/td>
&lt;td>使用“视图”+“触发器”+“扩展索引”+“外部调用”的方式实现数据加密，同时保证应用完全透明。&lt;/td>
&lt;td>&amp;ndash;&lt;/td>
&lt;td>对应用完全透明/数据库高级特性兼容性/支持列级别加密&lt;/td>
&lt;td>需要较强运维，没有云原生支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h1 id="几种方案共存的问题">几种方案共存的问题&lt;/h1>
&lt;p>前面分析中始终没有去讨论的问题，是不管哪种方案都无法绕开的问题：&lt;/p>
&lt;ul>
&lt;li>性能开销：数据加解密过程的额外开销，数据加解密需要大量的计算过程，这个会带来不容忽视的性能开销，在加解密算法的选择上，需要在确保数据安全性的前提下，尽可能选择尽可能高效的加密算法；&lt;/li>
&lt;li>空间膨胀：除了性能开销会影响加密算法的选择，加密算法可能还会带来空间膨胀的问题，也就是密文比明文变长的问题，如果是空间膨胀，数据库列在各类长度的设计上还需要额外考虑列数据膨胀后的长度。我了解了下，AES 加密算法的 CTR 模式则能实现密文和明文长度一致；&lt;/li>
&lt;li>密钥管理问题：不管哪种加密方案，都需要想好密钥的私密存储以及定期轮换问题等，否则一旦密钥泄露，加密得再好的数据也可能被一锅端了。&lt;/li>
&lt;/ul>
&lt;h1 id="总结">总结&lt;/h1>
&lt;p>数据存储安全是一个越来越重要，也是应用系统设计阶段必须提前考虑好的问题，因为它涉及的是服务质量和成本平衡的复杂问题。数据加密在业务合规以及隐私保护中正在逐步扮演常识性的地位，如同大家如今都知道密码不能明文存储一样，未来各类个人隐私数据加密也应该会成为系统中的标配设计。&lt;/p></description></item><item><title>Funny Pieces of Codes Make Weekend Happier</title><link>https://blog.hackerpie.com/posts/others/funny-code-pieces/</link><pubDate>Sun, 13 Mar 2022 16:10:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/others/funny-code-pieces/</guid><description>&lt;p>Sunny weekends make me cheerful always, and there are also some funny pieces of codes make it greater. Hope the following codes make you smile, too.&lt;/p>
&lt;p>Although I hardly use Ruby programming language for a long time, I still remember a piece of code from Sidekiq, which is a asynchronous jobs framework for Ruby:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L51-L53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Sidekiq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> self.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aha! It is a unused method of which the name is a emoticon, and seems that the author of the code is annoying while he or she was writing it. However, there is also a corresponding and serious unit test for it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>describe &lt;span style="font-style:italic">&amp;#34;❨╯°□°❩╯︵┻━┻&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before { $stdout = StringIO.new }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> after { $stdout = STDOUT }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="font-style:italic">&amp;#34;allows angry developers to express their emotional constitution and remedies it&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_equal &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>, $stdout.string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>According some online discussion, I finally aware that the reason why the code is present is that the author was expecting to ensure that the code works normally with UTF-8 encoding.&lt;/p>
&lt;p>Beyond this funny example from Sidekiq, I searched some other examples by the way, they all make people laugh out loud.&lt;/p>
&lt;h2 id="time-for-funny-codes">Time for funny codes&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Exception up = &lt;span style="font-weight:bold">new&lt;/span> Exception(&lt;span style="font-style:italic">&amp;#34;Something is really wrong.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">throw&lt;/span> up; &lt;span style="font-style:italic">//ha ha
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What the hell does this guy lack of compassion? Why does he or she is able to smile after the program encountered something incorrect? Alright, I can only appreciate his optimism.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//When I wrote this, only God and I understood what I was doing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//Now, God only knows
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aha, it is a truth could not be more real. Not only the author of the code has this kind of trouble, but do I.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// drunk, fix later
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What a conscientious programmer! How dangerous drunk coding is! Maybe it deserve considering punching somebody write codes after drinking.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="">#define TRUE FALSE
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Oh no! I hardly imagine what will happen once this line of code has been merged and deployed. How terrible if your world is reversed, you are wrong if you think you are right, and you are right if you think you are wrong. Stop it please, I get goose bumps all over now!&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">return&lt;/span> 1; &lt;span style="font-style:italic"># returns 1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>What a nonsense comment! But it is understandable if your boss pays you for the number of characters in your code.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Catch (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">//who cares?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Alright, you are so proud. ╭(╯^╰)╮&lt;/p>
&lt;p>I am not able to assert all people who care, but I can tell that your boss absolutely cares.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// I am not responsible of this code.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>o(╯□╰)o Ok, but why you wanna left a footmark?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// it was hard to write
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// so it should be hard to read
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It looks like a impregnable argument. Who wanna challenge?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// I have to find a better job
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Wait, if you really find a better job, could you take me with you? (&lt;em>^▽^&lt;/em>)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// If this code works, it was written by Paul DiLascia. If not, I don&amp;#39;t know
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// who wrote it
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>I only write excellent codes, and ugly codes are all out of thin air.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Linux Sex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ date ; unzip ; strip ; touch ; grep ; finger ; mount ; fsck ; more ; yes ; umount ; sleep
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Em&amp;hellip; I don&amp;rsquo;t know it is, I am still a child and hiding my eyes from it.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="">long&lt;/span> &lt;span style="">long&lt;/span> ago; &lt;span style="font-style:italic">/* in a galaxy far far away */&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Are you telling a story?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> * Always returns true.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">public&lt;/span> boolean isAvailable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>How dare you lie?! But which part is really wrong? The comment, or the function body?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Dear maintainer:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Once you are done trying to &amp;#39;optimize&amp;#39; this routine,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// and have realized what a terrible mistake that was,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// please increment the following counter as a warning
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// to the next guy:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// total_hours_wasted_here = 42
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It was clear that here is a victims alliance.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">return&lt;/span> true; &lt;span style="font-style:italic">//true my ass! this doesn&amp;#39;t work
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>How shall I put it? Fairy tales are lying.&lt;/p>
&lt;h2 id="for-more-funny-codes">For more funny codes&lt;/h2>
&lt;p>The above funny codes are all included in these articles, just click the links if you feel unsatisfied.&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://fuzzzyblog.blogspot.hk/2014/09/40-most-funny-code-comments.html">Fuzzzy blog: 40 most funny code comments ever&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.quora.com/What-are-some-of-the-funniest-comments-in-source-code">What are some of the funniest comments in source code?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Golang 编写易于单元测试的代码</title><link>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</link><pubDate>Sun, 06 Mar 2022 17:40:19 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</guid><description>&lt;h2 id="聊聊单测这个事">聊聊单测这个事&lt;/h2>
&lt;p>单元测试一直是大家老生长谈的话题之一，尽管各种测试方法论和测试工具集层层出不穷，但是实际上，在我所工作过的公司中，还没有见过能把单测坚持好的团队。单测的概念不复杂，单测的重要性大家也都是认同的，但是是什么造成单测没有执行下来呢？我觉得主要是两类原因吧：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>开发工期太赶&lt;/strong>：时间只够写功能性代码，测试代码只能舍弃，系统功能依赖不可重复的人力操作&lt;/li>
&lt;li>&lt;strong>项目设计问题&lt;/strong>：项目代码结构设计不良，导致单测代码难以编写，或者运行需要过多复杂的依赖，加上项目已存在大量代码，不敢重构&lt;/li>
&lt;/ul>
&lt;p>第一个原因见仁见智，也不是我想聊的重点。我最近更多的实践和感悟是，如果一个项目从一开始就没有考虑好单测的需要，等到后期就几乎难以改造成易于单元测试执行的结构了。而另一方面，我也是最近才对单测这个事情有一种顿悟的感觉。所以，下面也是想通过一个小 demo 项目，来总结如何设计在 golang 里编写易于单测展开的代码。&lt;/p>
&lt;p>项目设计问题导致的单测难以展开，一般都是因为代码组件之间形成了静态的依赖关系，比如对数据库的依赖，对外部服务的依赖，等等。这些依赖，可能是直接的，也可能是依赖的依赖，也就是间接的。而按照单测的定义，一个足够小的代码单元的测试，应该只关注这个单元的输入和输出即可，外加足以驱动单测执行的最小依赖集合，而不应该担心除此之外的其他一切东西。实际项目中，我们也会将代码进行分层设计，按照职责划分不同的代码模块，但是由于依赖管理的设计意识不足，常会发现模块之间形成了静态的依赖关系，导致编写单测时，不得不去关注各种间接的依赖，这就好比一个芯片在生产阶段就已经焊死在了主板之上，以至于如果我们需要对芯片的功能进行验证的话，就只能将整个主板制作完整之后，才能通过启动主板来检查芯片的功能，想想这有多离谱。&lt;/p>
&lt;h3 id="说明">说明&lt;/h3>
&lt;p>出于演示目的，我编写了一个逻辑上不严谨的小示例项目，代码托管在 &lt;a href="https://github.com/HackerPie/go-microblog">HackerPie/go-microblog&lt;/a>。demo 实现了两个用于管理指定用户微博的 Restful API，按照后续讨论章节的内容，这份代码相应地通过多个 git tag 来识别对应的代码版本，分别为&lt;code>v1&lt;/code>、&lt;code>v2&lt;/code>、&lt;code>v3&lt;/code>和&lt;code>v4&lt;/code>。&lt;/p>
&lt;h4 id="概述">概述&lt;/h4>
&lt;p>尽管只是一个小 demo，我还是希望提前说明下这个 demo 的分层设计。demo 核心逻辑存放在 &lt;code>internal&lt;/code> 目录里，因为只是 demo，所以只划分了 &lt;code>service&lt;/code>、&lt;code>repo&lt;/code> 以及 &lt;code>model&lt;/code> 三层：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/unit-testing/demo_layers.png" alt="">
&lt;figcaption>demo 应用分层&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>各层说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>service&lt;/strong>: 该层代码负责请求的处理与响应，同时负责核心业务逻辑，一般真实项目里，我会进一步分开服务处理和核心业务逻辑层，但是作为示例项目，就简化了；
&lt;ul>
&lt;li>&lt;strong>adapter&lt;/strong>: adapter 主要定义各类 dto 对象和数据库模型对象之间的转换适配，我认为这仍旧属于 &lt;code>service&lt;/code> 层的逻辑，但是在实际代码中，我会独立一个目录来管理；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>repo&lt;/strong>: 该层代码负责单一数据模型的持久化操作，即数据的 CURD；&lt;/li>
&lt;li>&lt;strong>model&lt;/strong>: 该层定义各类数据结构，按照使用场景不同，进一步划分 &lt;code>dto&lt;/code> 和 &lt;code>db&lt;/code>
&lt;ul>
&lt;li>&lt;strong>dto&lt;/strong>: 数据传输对象，用于定义一些需要返回给客户端或者从客户端请求反序列化的数据结构；&lt;/li>
&lt;li>&lt;strong>db&lt;/strong>: 数据库模型定义，用于描述数据库表的结构，此层不负责任何数据读写操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各层代码在项目代码结构中的管理如图：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/unit-testing/layout.png" alt="">
&lt;figcaption>internal 代码结构组织&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="v1-依赖具体实现的版本">v1: 依赖具体实现的版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/HackerPie/go-microblog/tree/v1">v1 版本&lt;/a> 代码中，是一个经典的代码分层之间直接依赖具体实现的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>r := gin.Default()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.GET(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, service.ListUserMBlogs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.POST(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, service.PublishNewBlog)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.Run(&lt;span style="font-style:italic">&amp;#34;:8000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/service/micro_blogs_service.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> ListUserMBlogs(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> mblogs, err := repo.ListUserMBlogs(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> PublishNewBlog(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> err = repo.NewUserMBlog(userID, req.Content); err != &lt;span style="font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// intrnal/repo/micro_blogs_repo.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> ListUserMBlogs(userID &lt;span style="">int&lt;/span>) ([]*dbModel.MicroBlog, &lt;span style="">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> err := db.Model(dbModel.MicroBlog{}).Where(&lt;span style="font-style:italic">&amp;#34;user_id = ?&amp;#34;&lt;/span>, userID).Scan(&amp;amp;mblogs).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> NewUserMBlog(userID &lt;span style="">int&lt;/span>, content &lt;span style="">string&lt;/span>) &lt;span style="">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> db.Create(&amp;amp;mblog).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个版本的实现中，Web 接口 &lt;code>/users/:user_id/blogs&lt;/code> 依赖了 &lt;code>service.ListUserMBlogs&lt;/code> 的实现，而其又直接依赖了 &lt;code>repo.ListUserMBlogs&lt;/code> 函数，而后者又依赖了 &lt;code>db&lt;/code>，也就是 &lt;code>gorm.DB&lt;/code> 对象指针，亦即数据库连接。假如我们需要为 &lt;code>service.ListUserMBlogs&lt;/code> 编写单元测试，用于验证几类显而易见的测试场景：&lt;/p>
&lt;ul>
&lt;li>数据查询失败&lt;/li>
&lt;li>数据查询成功，但是没有匹配的数据集&lt;/li>
&lt;li>数据查询成功，并且有匹配的数据集&lt;/li>
&lt;/ul>
&lt;p>那么，基于这套设计和测试需求，我们需要实现：&lt;/p>
&lt;ul>
&lt;li>在测试环境初始化中建立好数据库连接&lt;/li>
&lt;li>模拟数据库连接失败等可能导致数据查询失败的场景，这会跟上面的数据库连接管理造成矛盾&lt;/li>
&lt;li>载入指定测试数据集，以满足不同的匹配结果的场景&lt;/li>
&lt;li>最后需要清理数据库数据，以防止干扰其他单元测试用例的结果&lt;/li>
&lt;/ul>
&lt;p>假如我们还希望这些单测用例可以执行于 CI 流程或者每日自动回归中，又会有新的问题：&lt;/p>
&lt;ul>
&lt;li>CI 环境需要提供可用的 MySQL 数据库等；&lt;/li>
&lt;li>CI 环境需要初始化过程中额外完成 DDL 操作，以准备好单测依赖的库表结构；&lt;/li>
&lt;/ul>
&lt;p>除了这些一下子想到的问题，还会有协作层面的问题：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>测试环境难以保持一致&lt;/strong>：如果使用本地数据库，则大家各自的数据库管理的不同会导致每个人在执行同一套测试用例时，需要针对性定制自己的环境信息等；如果使用共享的远程数据库，则容易因为并行的开发和测试导致相互干扰。&lt;/li>
&lt;/ul>
&lt;p>一趟捋下来，仅仅是一个简单函数的单元测试，在本来就已经很有限的场景下，就已经牵扯出这么多令人生畏的问题，我想，开发没有动力写单测，也是自然的事情了。&lt;/p>
&lt;p>很自然的，针对这种设计风格的代码，我们急需一个解决方案，方便我们在单测中实现依赖的解耦！这就是&lt;a href="https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/">依赖倒置原则&lt;/a>的用武之地！&lt;/p>
&lt;h2 id="v2-依赖倒置依赖接口">v2: 依赖倒置：依赖接口&lt;/h2>
&lt;p>在我另一篇博文《&lt;a href="https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/">依赖倒置原则&lt;/a>》中，我们知道依赖倒置可以帮助避免耦合依赖双方实现的代码结构问题。而按照依赖倒置原则，我们需要将依赖实现的代码，改为依赖接口定义的代码，具体到 golang 中，就是 &lt;code>interface&lt;/code>，于是，应用了依赖倒置原则的&lt;a href="https://github.com/HackerPie/go-microblog/tree/v2">新版本&lt;/a>代码应运而生：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server/main.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> buildService() *service.MicroBlogsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db := repo.NewDB()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repoImpl := repo.NewMicroBlogRepoImpl(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> srv := service.NewMicroBlogsService(repoImpl)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> srv
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> srv := buildService()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r := gin.Default()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.GET(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, srv.ListUserMBlogs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.POST(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, srv.PublishNewBlog)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.Run(&lt;span style="font-style:italic">&amp;#34;:8000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/service/micro_blogs_service.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> MicroBlogsService &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo repo.MicroBlogRepoIface &lt;span style="font-style:italic">// 依赖了 repo.MicroBlogRepoIface 接口
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> NewMicroBlogsService(repo repo.MicroBlogRepoIface) *MicroBlogsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &amp;amp;MicroBlogsService{repo: repo}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (srv *MicroBlogsService) ListUserMBlogs(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ....
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> mblogs, err := srv.repo.ListUserMBlogs(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (srv *MicroBlogsService) PublishNewBlog(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> err = srv.repo.NewUserMBlog(userID, req.Content); err != &lt;span style="font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/interfaces.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> MicroBlogRepoIface &lt;span style="font-weight:bold">interface&lt;/span> { &lt;span style="font-style:italic">// &amp;lt;----- MicroBlogRepoIface 接口定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> ListUserMBlogs(userID &lt;span style="">int&lt;/span>) ([]*dbModel.MicroBlog, &lt;span style="">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NewUserMBlog(userID &lt;span style="">int&lt;/span>, content &lt;span style="">string&lt;/span>) &lt;span style="">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/micro_blogs_repo.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> MicroBlogRepoImpl &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db *gorm.DB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> NewMicroBlogRepoImpl(db *gorm.DB) *MicroBlogRepoImpl {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &amp;amp;MicroBlogRepoImpl{db: db}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (impl *MicroBlogRepoImpl) ListUserMBlogs(userID &lt;span style="">int&lt;/span>) ([]*dbModel.MicroBlog, &lt;span style="">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> err := impl.db.Model(dbModel.MicroBlog{}).Where(&lt;span style="font-style:italic">&amp;#34;user_id = ?&amp;#34;&lt;/span>, userID).Scan(&amp;amp;mblogs).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (impl *MicroBlogRepoImpl) NewUserMBlog(userID &lt;span style="">int&lt;/span>, content &lt;span style="">string&lt;/span>) &lt;span style="">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> impl.db.Create(&amp;amp;mblog).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 &lt;a href="https://github.com/HackerPie/go-microblog/tree/v2">v2 版本&lt;/a> 代码中，最主要的重构是提取了 &lt;code>repo.MicroBlogRepoIface&lt;/code> 接口的定义，而 service 层逻辑不再直接依赖 repo 层的具体函数，而是依赖此接口。而为了整个程序能够正常初始化，则需要手工完成依赖的注入，具体体现在 &lt;code>cmd/api_server/main.go&lt;/code> 的 &lt;code>buildService&lt;/code> 函数中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>db := repo.NewDB()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>repoImpl := repo.NewMicroBlogRepoImpl(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>srv := service.NewMicroBlogsService(repoImpl)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>buildService&lt;/code> 函数首先通过工厂函数获取了 &lt;code>*gorm.DB&lt;/code> 对象，将其注入 &lt;code>repo.NewMicroBlogRepoImpl&lt;/code> 工厂函数，进而生产得到 &lt;code>repo.MicroBlogRepoImpl&lt;/code> 对象，其实现了 &lt;code>repo.MicroBlogRepoIface&lt;/code> 接口，因此可以作为 &lt;code>MicroBlogsService&lt;/code> 的依赖，因此通过 &lt;code>service.NewMicroBlogsService&lt;/code> 完成依赖注入，最终得到我们需要的 service 对象。&lt;/p>
&lt;p>这种通过运行时完成依赖注入的方式，为单测提供了一个很关键的扩展入口：我们可以在单测初始化时为 service 注入 &lt;code>repo.MicroBlogRepoIface&lt;/code> 接口的其他实现，这样就可以达到隔离真实数据库依赖的目的！&lt;/p>
&lt;h2 id="v3-基于接口-mock-添加单测">v3: 基于接口 mock 添加单测&lt;/h2>
&lt;p>通过 v2 版本的重构，项目代码已经为单测代码编写打下了很好的基础。显然，如果需要在不同测试用例下需要 &lt;code>repo.MicroBlogRepoIface&lt;/code> 的实现能够不同行为或者返回值，我们最简单的方式就是可以在每个测试用例里手写一个新的类型，并且让其实现 &lt;code>repo.MicroBlogRepoIface&lt;/code> 的每一个方法即可。但是这种方式比较低效，而且会带来维护的问题：一旦这个接口的定义变了，将会要求我们将单测代码中的每个实现都相应进行修改！有没有一种方式，可以实现接口的 mock 代码的自动生成呢？有的，&lt;a href="https://github.com/golang/mock">gomock&lt;/a>！&lt;/p>
&lt;p>gomock 是 golang 官方维护的用于为接口自动生成 mock 实现的工具，方便单测中复用 mock 代码完成调用断言、返回值定制等。&lt;/p>
&lt;p>在 &lt;a href="https://github.com/HackerPie/go-microblog/tree/v3">v3 版本&lt;/a>代码中，我们借助 gomock 实现了 mock 代码的生成，并且应用到了单测代码中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/interfaces.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//go:generate mockgen -destination=./mocks/mock_repo.go -package=repomocks -source=interfaces.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">type&lt;/span> MicroBlogRepoIface &lt;span style="font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListUserMBlogs(userID &lt;span style="">int&lt;/span>) ([]*dbModel.MicroBlog, &lt;span style="">error&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NewUserMBlog(userID &lt;span style="">int&lt;/span>, content &lt;span style="">string&lt;/span>) &lt;span style="">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/mocks/mock_repo.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> MockMicroBlogRepoIface &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl *gomock.Controller
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> recorder *MockMicroBlogRepoIfaceMockRecorder
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">type&lt;/span> MockMicroBlogRepoIfaceMockRecorder &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mock *MockMicroBlogRepoIface
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> NewMockMicroBlogRepoIface(ctrl *gomock.Controller) *MockMicroBlogRepoIface {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (m *MockMicroBlogRepoIface) EXPECT() *MockMicroBlogRepoIfaceMockRecorder {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// ListUserMBlogs indicates an expected call of ListUserMBlogs.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> (mr *MockMicroBlogRepoIfaceMockRecorder) ListUserMBlogs(userID &lt;span style="font-weight:bold">interface&lt;/span>{}) *gomock.Call {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (mr *MockMicroBlogRepoIfaceMockRecorder) NewUserMBlog(userID, content &lt;span style="font-weight:bold">interface&lt;/span>{}) *gomock.Call {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/service/micro_blogs_service_test.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> TestMicroBlogsService_ListUserMBlogs(t *testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">type&lt;/span> mockRepoReturn &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list []*dbModel.MicroBlog
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> err &lt;span style="">error&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tests := []&lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expectMsg &lt;span style="">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expectDataLength &lt;span style="">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mock mockRepoReturn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">&amp;#34;list is empty&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mock: mockRepoReturn{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> list: []*dbModel.MicroBlog{},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> expectMsg: &lt;span style="font-style:italic">&amp;#34;success&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> _, tt := &lt;span style="font-weight:bold">range&lt;/span> tests {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.Run(tt.name, &lt;span style="font-weight:bold">func&lt;/span>(t *testing.T) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ctrl := gomock.NewController(t)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">defer&lt;/span> ctrl.Finish()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mockRepo := repomocks.NewMockMicroBlogRepoIface(ctrl)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mockRepo.EXPECT().
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListUserMBlogs(gomock.Eq(1)).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Return(tt.mock.list, tt.mock.err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> srv := &amp;amp;MicroBlogsService{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo: mockRepo, &lt;span style="font-style:italic">// 这里将 mock 的实现注入了 MicroBlogsService 实例
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> srv.ListUserMBlogs(c)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个版本里，首先在 &lt;code>internal/repo/interfaces.go&lt;/code> 中新增了 go generate 指令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//go:generate mockgen -destination=./mocks/mock_repo.go -package=repomocks -source=interfaces.go
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>该指令将会指引后续的 &lt;code>go generate&lt;/code> 命令，将当前文件里的 interface 的 mock 实现保存到相对于当前文件的 &lt;code>mocks/mock_repo.go&lt;/code> 文件中，使用的 go 包名为 &lt;code>repomocks&lt;/code>。&lt;/p>
&lt;p>接着在命令行里执行 &lt;code>go generate ./...&lt;/code> 后，便符合期待地自动生成了 &lt;code>internal/repo/mocks/mock_repo.go&lt;/code> 文件，可以看到里面的类型 &lt;code>MockMicroBlogRepoIface&lt;/code> 实现了 &lt;code>repo.MicroBlogRepoIface&lt;/code> 接口。&lt;/p>
&lt;p>而在最后的单测代码中，我们通过表格驱动测试的风格，定制了对应每一个测试用例下的 mock 实现的返回值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>mockRepo := repomocks.NewMockMicroBlogRepoIface(ctrl)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mockRepo.EXPECT().
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ListUserMBlogs(gomock.Eq(1)).
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Return(tt.mock.list, tt.mock.err) &lt;span style="font-style:italic">// &amp;lt;------- 定制返回值
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到没有？这次我们的单测逻辑里，是不用在意数据库相关的东西的，对于 service 层的单测代码来说，它只需要关注它依赖的 &lt;code>repo.MicroBlogRepoIface&lt;/code> 接口的直接行为即可，至于背后的实际实现，则是无需关心的内容了。因为隔离了对环境的间接依赖，我们有信心可以将这样的单测代码丢到各种执行环境中去运行，而无需担心环境改变导致单测可能执行失败的繁琐问题。&lt;/p>
&lt;h2 id="v4-使用-googlewire-实现依赖注入">v4: 使用 google/wire 实现依赖注入&lt;/h2>
&lt;p>在 v2 版本代码中，我们的 &lt;code>buildService&lt;/code> 函数用于实现依赖注入，但是在实际的项目中，我们的依赖会复杂得多，如果依靠人工编写这种依赖注入代码，会非常繁琐枯燥，而 &lt;a href="https://github.com/google/wire">google/wire&lt;/a> 则是可以用来帮我们提升幸福感的工具。&lt;/p>
&lt;p>wire 是一个 google 公司开发维护的用于实现编译时依赖注入的工具，其工作的方式也是代码的自动生成。wire 有两个核心概念：injector 和 provider，provider 可以理解各种可以生成依赖组件实例的工厂函数，而 injector 则是用于定义最终依赖产物的函数，通过 injector 的返回值定义以及项目中提供的一系列 provider，wire 能够自动识别出应用组件之间的依赖关系，并且自动生成依赖注入的完整代码。下面看 &lt;a href="https://github.com/HackerPie/go-microblog/tree/v4">v4 版本&lt;/a>的相关代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server/main.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> srv := buildService()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r := gin.Default()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.GET(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, srv.ListUserMBlogs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.POST(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, srv.PublishNewBlog)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> r.Run(&lt;span style="font-style:italic">&amp;#34;:8000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server/wire.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> buildService() *service.MicroBlogsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wire.Build(service.NewMicroBlogsService,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo.WireSet,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo.NewDB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &amp;amp;service.MicroBlogsService{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server/wire_gen.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> buildService() *service.MicroBlogsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db := repo.NewDB()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> microBlogRepoImpl := repo.NewMicroBlogRepoImpl(db)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> microBlogsService := service.NewMicroBlogsService(microBlogRepoImpl)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> microBlogsService
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/wire_set.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">var&lt;/span> WireSet = wire.NewSet(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NewMicroBlogRepoImpl,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wire.Bind(new(MicroBlogRepoIface), new(*MicroBlogRepoImpl)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/repo/conn.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> NewDB() *gorm.DB {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db, err := gorm.Open(mysql.Open(&lt;span style="font-style:italic">&amp;#34;root@tcp(127.0.0.1:3306)/micro_blog?charset=utf8mb4&amp;amp;parseTime=True&amp;amp;loc=Local&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> err != &lt;span style="font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> panic(err)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> db
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个版本中，我们将原来手写的 &lt;code>buildService&lt;/code> 函数从 &lt;code>main.go&lt;/code> 文件中清除了，取而代之的，在新的 &lt;code>wire.go&lt;/code> 文件中，我们定义了一个 wire injector &lt;code>buildService&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> buildService() *service.MicroBlogsService {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wire.Build(service.NewMicroBlogsService,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo.WireSet,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repo.NewDB)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &amp;amp;service.MicroBlogsService{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>与之前手写代码不同的是，这里通过 &lt;code>wire.Build&lt;/code> 指明了用于实现完整依赖注入所需的所有 provider，所以这里的 &lt;code>service.NewMicroBlogsService&lt;/code> 和 &lt;code>repo.NewDB&lt;/code> 都是 provider，而 &lt;code>repo.WireSet&lt;/code> 则是一个 provider set：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">var&lt;/span> WireSet = wire.NewSet(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> NewMicroBlogRepoImpl,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wire.Bind(new(MicroBlogRepoIface), new(*MicroBlogRepoImpl)),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>wire.NewSet&lt;/code> 用于定义一组 provider 的集合，好处是方便打包使用，这样就不用在 injector 中重复罗列这些 provider。而 &lt;code>wire.Bind&lt;/code> 则是用于提示 wire：&lt;code>MicroBlogRepoImpl&lt;/code> 类型实现了 &lt;code>MicroBlogRepoIface&lt;/code> 接口，应该在依赖注入过程中将 &lt;code>MicroBlogRepoImpl&lt;/code> 注入给所有依赖 &lt;code>MicroBlogRepoIface&lt;/code> 接口的组件。&lt;/p>
&lt;p>通过 wire，减轻了我们的依赖注入的负担，让这种应用架构变得更称手。&lt;/p>
&lt;h2 id="其他组件-mock-的思路">其他组件 mock 的思路&lt;/h2>
&lt;p>由于是示例项目，上面的内容最核心的内容，还是在于通过依赖倒置的原则，将应用内分层之间的耦合分离，让单元测试有施展的空间。但是，实际项目由于复杂度等，除了分层接口的 mock，还可能会遇到的情况是对相同组件内部的其他方法或者函数的依赖，这种情况下，基于接口的依赖倒置没有发挥的空间。作为解决方案，我会慎重引入 &lt;a href="https://github.com/bouk/monkey">bouk/monkey&lt;/a> 以猴子补丁的形式在单测中临时替换被依赖函数或者方法的实现。&lt;/p>
&lt;h3 id="数据库依赖的问题">数据库依赖的问题&lt;/h3>
&lt;p>前面在介绍重构和单测的过程中，其实没有讲到 repo 层自身的单测的问题。而如果考虑 repo 层的单测的话，就需要解决对 &lt;code>*gorm.DB&lt;/code> 的依赖的问题，因为 &lt;code>gorm.DB&lt;/code> 不是一个接口定义，所以不能通过 mock 代码生成的方式来解决。要解决这个问题，有两种思路：&lt;/p>
&lt;ul>
&lt;li>使用 sqlite 这种本地文件型数据库&lt;/li>
&lt;li>使用 &lt;a href="DATA-DOG/go-sqlmock">go-sqlmock&lt;/a> 这类用于 mock 数据连接层的工具库&lt;/li>
&lt;/ul>
&lt;p>由于 sqlite 本质上还是物理数据库，而且有造数据和清理数据的负担，我不大会作为首选的工具。而如果使用 sqlmock，则可以很轻松地将 gorm 依赖的数据库连接进行替换，进而实现 mock 数据库层的目的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>db, mock, err := sqlmock.New()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>gormDB := gorm.Open(db) &lt;span style="font-style:italic">// &amp;lt;---- 注入 sqlmock，作为 gorm.DB 的依赖
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>repo := NewMicroBlogRepoImpl(gormDB)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="远程调用依赖的问题">远程调用依赖的问题&lt;/h3>
&lt;p>工程实践中，另一类常见的依赖，就是远程调用的依赖，既包含 HTTP 协议服务的依赖，也可能是其他 rpc 服务的依赖。如果是 HTTP 类服务的依赖，可以借助 &lt;a href="https://github.com/jarcoal/httpmock">httpmock&lt;/a> 实现 mock。而对于 rpc 类服务，则最好期待相关 rpc 框架在生成协议桩代码的时候，能够顺便提供相关的接口定义，还是同样的原则：依赖接口，不依赖具体实现！&lt;/p>
&lt;h2 id="其他可能影响代码可测试性的因素">其他可能影响代码可测试性的因素&lt;/h2>
&lt;p>上面的思考，更多的是思考如何实现单测最小化依赖的问题，避免依赖问题成为单测执行的阻碍以及不稳定因素。而如果放开点思考，还有一些其他因素同样会降低代码的可测试性：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>全局变量&lt;/strong>：全局变量破坏了单测用例的相互独立性；&lt;/li>
&lt;li>&lt;strong>函数或方法的复杂度&lt;/strong>：因为单测的对象是一个足够小的逻辑单元，如果一个函数或者方法包含了太多的逻辑，也会同时很大程度加大单测的复杂度，如果涉及到多个接口的 mock，还需要考虑多种 mock 组合的设计，我们尽可能简化单个函数或者方法的逻辑，让乘法（mock组合）变成简单的加法。&lt;/li>
&lt;/ul>
&lt;h2 id="其他思考">其他思考&lt;/h2>
&lt;p>值得记住的是，单测并不是银弹，哪怕单测测试覆盖率已经达到 100%，也不能仅凭单测结果证明系统是完全符合预期的。因为单测中对环境的隔离，以及单测未能覆盖组件之间组装起来之后运行的场景，这些问题都只能交给集成测试环节来保障。但是话说回来，在很多人都不写或者写不好单测的情况下，能够坚持写好单测的话，就已经可以跑赢很多人了。&lt;/p>
&lt;p>与 mock 的方式相对的，有些场景下，我们仍然希望基于真实的数据库环境运行自动化测试，但是为了测试用例可以重复执行而保持稳定的结果，需要考虑如何实现测试数据的装载和清理问题。参照 Rails 中的 &lt;code>test fixtures&lt;/code>，我也尝试过编写了 golang 版本的 &lt;a href="https://github.com/martin91/gofixtures">gofixtures&lt;/a>，其原理是实现 &lt;code>sql.Driver&lt;/code> 接口，并且在测试用例启动时开启全局事务，在完成测试用例执行之后，再回滚这个全局事务，而达到数据回滚的目的。&lt;/p>
&lt;p>最后一点思考是，如果想要写好单测，就应该跟对待其他功能性代码一样看待单测，将单测的支持一并考虑到项目代码的设计中去，也就是写代码除了追求常见的易读性、可维护性、可扩展性，还得追求测试友好性。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/">依赖倒置原则&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/@rosaniline/unit-testing-gorm-with-go-sqlmock-in-go-93cbce1f6b5b">Unit testing GORM with go-sqlmock in Go&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/martin91/gofixtures">gofixtures&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/google/wire">google/wire&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/golang/mock">golang/mock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/bouk/monkey">bouk/monkey&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/jarcoal/httpmock">httpmock&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>MySQL + go 如何安全处理 decimal 类型数据</title><link>https://blog.hackerpie.com/posts/mysql/handle-decimal-fields/</link><pubDate>Wed, 02 Mar 2022 18:31:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/mysql/handle-decimal-fields/</guid><description>&lt;p>在电商或者金融相关的场景中，商品价格等数据都会涉及到小数的表示或者计算，如果使用编程语言内置的浮点数类型，会有精度丢失的风险。在应用领域，&lt;code>decimal&lt;/code> 类型应运而生，MySQL 数据库中内置支持 &lt;code>decimal&lt;/code> 数据类型，而程序设计上，一般编程语言都会有标准库或者第三方库对 &lt;code>decimal&lt;/code> 类型提供实现。本文快速展示下如何实现全链路对 &lt;code>decimal&lt;/code> 类型数据的读取处理，而不用担心会丢失数据的精度。&lt;/p>
&lt;h2 id="数据库层---mysql">数据库层 - MySQL&lt;/h2>
&lt;p>在 MySQL 层，&lt;code>decimal&lt;/code> 类型的值使用二进制表示，其大致转换过程是：&lt;/p>
&lt;ol>
&lt;li>将待存储的数据按照整数和小数部分一分为二，比如 &lt;code>1234567890.1234&lt;/code>，分为 &lt;code>1234567890&lt;/code> 和 &lt;code>1234&lt;/code>；&lt;/li>
&lt;li>针对整数部分，从低位到高位，按照每 9 位数字为一组，进行分割，比如 &lt;code>1234567890&lt;/code> 将分为 &lt;code>1&lt;/code> 和 &lt;code>234567890&lt;/code>；&lt;/li>
&lt;li>使用最短字节序列分别表示每个分组的整数，上面的 &lt;code>1&lt;/code> 即 &lt;code>0b00000001&lt;/code>，而 &lt;code>234567890&lt;/code> 则对应 &lt;code>0x0D-FB-38-D2&lt;/code>；&lt;/li>
&lt;li>对于小数部分，使用类似的分组（从高位到低位）处理方式，即 1234 表示为 &lt;code>0x04D2&lt;/code>；&lt;/li>
&lt;li>最后，将最高位置反，得到 &lt;code>0x81 0D FB 38 D2 04 D2&lt;/code>，也就是使用了 7 个字节来表示这个数字。&lt;/li>
&lt;/ol>
&lt;p>Bonus: 如果是小数，比如 &lt;code>-1234567890.1234&lt;/code>，则只需要将上面第 5 步的所有位置反即可，也就是 &lt;code>0x7E F2 04 C7 2D FB 2D&lt;/code>&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>MySQL 通过设计巧妙的可变长度的二进制转换，实现了对严格要求精度的小数的表示。&lt;/p>
&lt;h2 id="网络传输层---mysql">网络传输层 - MySQL&lt;/h2>
&lt;p>存储在 MySQL 底层存储上的 decimal，我们知道是二进制了之后，也就对精度问题的持久化存储放心了，但是，又带来两个问题：&lt;/p>
&lt;ol>
&lt;li>数据经过二进制转换之后，如果将这个字节序列给客户端，客户端显然是不能理解的，而且耦合了转换逻辑，显然是需要 MySQL 服务器做一次反向的从二进制数据到真实小数的转换；&lt;/li>
&lt;li>转换后的数据在数据库连接中的传输，MySQL 又是如何保证安全呢？&lt;/li>
&lt;/ol>
&lt;p>答案很简单：纯文本。&lt;/p>
&lt;p>通过对 MySQL 连接进行抓包，可以确认这一点，截图是通过 Wireshark 抓包 MySQL 服务器返回的 decimal 数据：&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/decimal/mysql_protocol.png" alt="screenshot">
&lt;figcaption>MySQL 服务器响应的 decimal 类型数据是纯文本&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h3 id="小结-1">小结&lt;/h3>
&lt;p>因为使用了纯文本传输数据，所以不用担心小数在传输过程中会有精度问题&lt;/p>
&lt;h2 id="应用层---golang">应用层 - Golang&lt;/h2>
&lt;p>在我的应用程序里，我使用了 golang 来开发程序，依赖了 &lt;a href="https://github.com/shopspring/decimal">shopspring/decimal&lt;/a> 包来处理 decimal 类型，而且它同时实现了 &lt;a href="https://pkg.go.dev/database/sql#Scanner">sql.Scanner&lt;/a> 接口，也就意味着我可以直接用它完成对数据库查询返回数据的反序列化。比如我的代码里：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Order ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> Order &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> OrderNo &lt;span style="">string&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> PurchaseAmount decimal.Decimal
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Status &lt;span style="">uint8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>order := new(Order)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>db.Where(&lt;span style="font-style:italic">&amp;#34;order_no = ?&amp;#34;&lt;/span>, orderNo).First(order).Error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>不需要额外的逻辑，&lt;code>PurchaseAmount&lt;/code> 能够精确地反序列化 decimal 类型的数据。&lt;/p>
&lt;p>尽管如此，我还是看了下 shopspring/decimal 包里对 &lt;code>Scanner&lt;/code> 接口的实现，以确认它确实是安全的：&lt;/p>
&lt;p>首先，我在源码处加了两行代码，以方便我确认底层数据的类型，确认反序列前，是一个字节序列：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/decimal/decimal_type.png" alt="screenshot">
&lt;figcaption>decimal 获取的value的类型是字节序列&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;p>之后，我跟踪了代码的执行，可以看到 decimal 包按照字符串的方式对数据直接进行了反序列化：
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/decimal/decimal_string.png" alt="screenshot">
&lt;figcaption>decimal 按照处理字符串的方式完成反序列化&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="网络传输层---protobuf">网络传输层 - protobuf&lt;/h2>
&lt;p>考虑到整数的溢出以及浮点数精度损失风险，我在对外服务的协议规范上，也都统一使用字符串类型。&lt;/p>
&lt;pre tabindex="0">&lt;code class="language-pb" data-lang="pb">message Order {
string order_no = 1;
string purchase_amount = 2;
status int32 = 3;
}
&lt;/code>&lt;/pre>&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>MySQL 底层使用可变长度的二进制表示 decimal 类型数据；&lt;/li>
&lt;li>MySQL 在网络传输中使用纯文本表示 decimal 类型数据；&lt;/li>
&lt;li>Golang 程序中借助 &lt;code>shopspring/decimal&lt;/code> 实现 decimal 类型数据的处理；&lt;/li>
&lt;li>&lt;code>shopspring/decimal&lt;/code> 底层使用了科学计数法表示 decimal，但是本文就不展开了；&lt;/li>
&lt;li>应用对外服务协议使用字符串表示 decimal 类型数据。&lt;/li>
&lt;/ul>
&lt;h2 id="思考">思考&lt;/h2>
&lt;ul>
&lt;li>使用字符串表示 decimal 类型数据可能带来更多的字节数量。&lt;/li>
&lt;/ul></description></item><item><title>当反射 map[string]interface{} 遇上 MapIndex 方法，返回值的 Kind 不是具体类型？</title><link>https://blog.hackerpie.com/posts/reflect/why-reflect-map-index-function-returns-interface/</link><pubDate>Sat, 19 Feb 2022 15:38:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/reflect/why-reflect-map-index-function-returns-interface/</guid><description>&lt;h2 id="什么是反射">什么是反射？&lt;/h2>
&lt;p>反射是一种在运行时用于探测甚至修改内存数据以及程序行为的机制，在 go 语言中通过 &lt;code>reflect&lt;/code> 包实现。直白来说，利用反射，我们可以实现包括但不限于的以下这些场景：&lt;/p>
&lt;ul>
&lt;li>数据的反序列化，比如 json、yaml 等格式数据从纯文本到内存数据结构的反序列化过程&lt;/li>
&lt;li>动态修改内存中的数据，比如创建新的字典数据、修改结构体的字段的值等&lt;/li>
&lt;li>动态调用对象的某个方法或者包里的某个函数等&lt;/li>
&lt;li>检查数据的类型以及对象的方法列表等&lt;/li>
&lt;/ul>
&lt;h2 id="所以这次想说什么问题呢">所以，这次想说什么问题呢？&lt;/h2>
&lt;p>今天想分享的，是我前几天在一个使用 golang 反射功能对 map[string]interface{} 类型的数据做处理的过程中，遇到的一个反直觉的问题。下面是相关代码片断示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>myData := &lt;span style="font-weight:bold">map&lt;/span>[&lt;span style="">string&lt;/span>]&lt;span style="font-weight:bold">interface&lt;/span>{}{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>json.Unmarshal(&lt;span style="font-style:italic">&amp;#34;{\&amp;#34;name\&amp;#34;: \&amp;#34;martin\&amp;#34;, \&amp;#34;score\&amp;#34;: 99}&amp;#34;&lt;/span>, &amp;amp;myData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HandleData(myData) &lt;span style="font-style:italic">// 进行数据的处理过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> HandleData(data &lt;span style="font-weight:bold">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value := reflect.ValueOf(data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyValue := value.MapIndex(reflect.ValueOf(&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>)) &lt;span style="font-style:italic">// 从数据中取对应键 name 的值，应该为 &amp;#34;martin&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">switch&lt;/span> keyValue.Kind() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">case&lt;/span> reflect.String:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doSth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他 case，但是都没有包含 reflect.Interface 的匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他后续代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编写上面的代码的过程中，我期待程序会进入 &lt;code>case reflect.String:&lt;/code> 的逻辑分支进行处理，但是事实上，并没有。在网上搜索了一番之后，StackOverflow 上的这个&lt;a href="https://stackoverflow.com/questions/14142667/reflect-value-mapindex-returns-a-value-different-from-reflect-valueof">问答&lt;/a>给出了可以奏效的方法：&lt;/p>
&lt;pre tabindex="0">&lt;code>keyValue := reflect.ValueOf(value.MapIndex(reflect.ValueOf(&amp;#34;name&amp;#34;)).Interface())
&lt;/code>&lt;/pre>&lt;p>很奇怪啊！ &lt;code>(╯‵□′)╯︵┻━┻&lt;/code>&lt;br>
大家应该都知道，&lt;code>reflect.ValueOf&lt;/code> 和 &lt;code>reflect.Interface()&lt;/code> 是一对相反的操作啊（看下图右侧部分），为什么要这么绕一圈，而且绕完还真的可以了？&lt;/p>
&lt;p>
&lt;figure>
&lt;img src="https://blog.hackerpie.com/images/posts/reflect/golang-bidirectional-reflection.png" alt="test">
&lt;figcaption>图片来自《Go 语言设计与实现》博客，https://draveness.me/golang&lt;/figcaption>
&lt;/figure>
&lt;/p>
&lt;h2 id="出发之前让我准备个小-demo">出发之前，让我准备个小 demo&lt;/h2>
&lt;p>既然 &lt;code>map[string]interface{}&lt;/code> 有这个奇怪问题，那 &lt;code>map[string]string&lt;/code> 这种值类型确定的数据结构，是否就没有问题呢？来，上代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">package&lt;/span> main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;reflect&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> main() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implicitMap := &lt;span style="font-weight:bold">map&lt;/span>[&lt;span style="">string&lt;/span>]&lt;span style="font-weight:bold">interface&lt;/span>{}{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Martin&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> explicitMap := &lt;span style="font-weight:bold">map&lt;/span>[&lt;span style="">string&lt;/span>]&lt;span style="">string&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Martin&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implicitRValue := reflect.ValueOf(implicitMap)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> explicitRValue := reflect.ValueOf(explicitMap)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implicitNameValue := implicitRValue.MapIndex(reflect.ValueOf(&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> explicitNameValue := explicitRValue.MapIndex(reflect.ValueOf(&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="font-style:italic">&amp;#34;the kind of name key value in implicitRValue is: %s\n&amp;#34;&lt;/span>, implicitNameValue.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="font-style:italic">&amp;#34;the kind of name key value in explicitRValue is: %s\n&amp;#34;&lt;/span>, explicitNameValue.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implicitNameInterface := implicitNameValue.Interface()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(&lt;span style="font-style:italic">&amp;#34;the type of implicitNameValue is: &amp;#34;&lt;/span>, implicitNameValue.Type().String())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> directName, ok := implicitNameInterface.(&lt;span style="">string&lt;/span>); ok {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(&lt;span style="font-style:italic">&amp;#34;the directName is: &amp;#34;&lt;/span>, directName)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="font-weight:bold">else&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(&lt;span style="font-style:italic">&amp;#34;could not assert directName as string&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> convertedImplicitNameValue := reflect.ValueOf(implicitNameInterface)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Printf(&lt;span style="font-style:italic">&amp;#34;the kind of name key value after converting is: %s\n&amp;#34;&lt;/span>, convertedImplicitNameValue.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fmt.Println(&lt;span style="font-style:italic">&amp;#34;the converted value is: &amp;#34;&lt;/span>, convertedImplicitNameValue.Interface().(&lt;span style="">string&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>demo 代码略多，大家不要怕。大概思路就是想看看两种不同值类型的 map 通过反射后的 MapIndex 方法得到的反射值的 &lt;code>Kind&lt;/code> 有什么区别，以及，能否直接都进行类型转换。&lt;/p>
&lt;p>怎么样？思路应该知道了吧？那你觉得这段程序的输出是什么呢？想好了的话，我们往下揭晓答案：&lt;/p>
&lt;pre tabindex="0">&lt;code>the kind of name key value in implicitRValue is: interface
the kind of name key value in explicitRValue is: string
the type of implicitNameValue is: interface {}
the directName is: Martin
the kind of name key value after converting is: string
the converted value is: Martin
&lt;/code>&lt;/pre>&lt;p>看到没有？&lt;/p>
&lt;ol>
&lt;li>&lt;code>map[string]interface{}&lt;/code> 类型的数据对应的反射值在通过 &lt;code>MapIndex&lt;/code> 方法获取到的值，对应的 Kind 是 &lt;code>interface&lt;/code>；&lt;/li>
&lt;li>&lt;code>map[string]string&lt;/code> 类型的数据和1的数据尽管人类角度理解一致，但是其反射值在通过 &lt;code>MapIndex&lt;/code> 方法获取到的值，对应的 Kind 是 &lt;code>string&lt;/code>；&lt;/li>
&lt;li>&lt;code>map[string]interface{}&lt;/code> 类型的数据的反射值在通过 &lt;code>MapIndex&lt;/code> 方法获取到的值，再经过一次 &lt;code>reflect.Interface&lt;/code> 和 &lt;code>reflect.ValueOf&lt;/code> 的往返后，最后的值的 Kind 成功变成 &lt;code>string&lt;/code> 了！&lt;/li>
&lt;/ol>
&lt;p>我本来想玩一玩反射，结果没想到这是被反射玩了啊！到底是为什么？&lt;/p>
&lt;h2 id="开启原理分析之旅">开启原理分析之旅&lt;/h2>
&lt;h3 id="提出问题">提出问题&lt;/h3>
&lt;p>为了找出问题的答案，我把问题进行了分解，相信找到这些问题的答案之后，上面的问题就自然迎刃而解了。&lt;/p>
&lt;ul>
&lt;li>问题一：&lt;code>reflect.Value#Kind&lt;/code> 方法如何工作，它怎么知道具体的 Kind 值？&lt;/li>
&lt;li>问题二：在 &lt;code>reflect.Value#Interface&lt;/code> 和 &lt;code>reflect.ValueOf&lt;/code> 这一来一往之间，是哪个操作起了关键作用，让反射值的 Kind 得到纠正？&lt;/li>
&lt;/ul>
&lt;p>既然提出来问题，我们就逐个问题击破吧，let&amp;rsquo;s go!&lt;/p>
&lt;h3 id="问题一reflectvaluekind-方法如何工作它怎么知道具体的-kind-值">问题一：&lt;code>reflect.Value#Kind&lt;/code> 方法如何工作，它怎么知道具体的 Kind 值？&lt;/h3>
&lt;p>要想知道，不妨跟着源码分析出发？以下是 &lt;code>Kind&lt;/code> 方法的源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (v Value) Kind() Kind {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> v.kind()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>有意思，它啥也不干，喊了自己的分身 &lt;code>kind&lt;/code> 方法出来干活：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (f flag) kind() Kind {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> Kind(f &amp;amp; flagKindMask)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好家伙，这里也就一行代码，定睛一看，这里不是 &lt;code>Value&lt;/code> 定义的方法，而是 &lt;code>Value&lt;/code> 值的 &lt;code>flag&lt;/code> 匿名字段的 &lt;code>kind&lt;/code> 方法，干了啥呢？就是做了下位的掩码运算，翻了下代码，找到文件开头一处重点代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">type&lt;/span> flag &lt;span style="">uintptr&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flagKindWidth = 5 &lt;span style="font-style:italic">// there are 27 kinds
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> flagKindMask flag = 1&amp;lt;&amp;lt;flagKindWidth - 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">//...
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，上面 &lt;code>kind()&lt;/code> 方法的实现逻辑就是取自身的 flag 值的低 5 位（也就是 0-31），而如果熟悉反射的同学都知道，reflect 包里总的定义了 27 个 kind 常量，其中 0 是非法 kind，我们刚才讨厌的 &lt;code>interface&lt;/code> 对应的值是 20，&lt;code>map&lt;/code> 是 21，我们想要的 &lt;code>string&lt;/code> 是 24。&lt;/p>
&lt;h4 id="小结一个">小结一个&lt;/h4>
&lt;p>所以到这里，我们的问题的答案就清楚了，&lt;code>Kind&lt;/code> 方法实际只是从 &lt;code>reflect.Value&lt;/code> 对象自身的 &lt;code>flag&lt;/code> 字段的低 5 位中取出对应的 kind 值。那么，问题又变了：这个 &lt;code>flag&lt;/code> 的低 5 位是怎么赋值的？&lt;/p>
&lt;h3 id="问题一的延伸reflectvalue-对象的-flag-字段的-低-5-位也就是-kind是怎么来的">问题一的延伸：&lt;code>reflect.Value&lt;/code> 对象的 &lt;code>flag&lt;/code> 字段的 低 5 位，也就是 kind，是怎么来的？&lt;/h3>
&lt;p>想要解答这个问题，我找到了一点间接的线索。从《Go语言设计与实现》的 4.3.2 节中得到的下面 2 点结论需要大家先记住：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>大家知道 &lt;code>reflect.ValueOf&lt;/code> 函数的参数列表是 &lt;code>(i interface{}) Value&lt;/code>，也就是入参是一个 &lt;code>interface{}&lt;/code> 类型的值，但是，外部调用时，明明是 &lt;code>reflect.ValueOf(implicitMap)&lt;/code>，这里 &lt;code>implicitMap&lt;/code> 明明只是一个 &lt;code>map[string]interface{}&lt;/code> 类型的参数啊，为什么能工作？道理很简单，一切你没干，但是又能工作的语法，一定是编译器在背后为你默默做了一些事情。事实上，&lt;strong>这里的类型转换就是编译器在编译阶段完成的&lt;/strong>。这个结论怎么证明呢？汇编！有关于这个结论的汇编代码展示和说明，感兴趣的可以自己去看，只记住结论就足以跟着我的脚步往下了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>进一步，Go 语言的 &lt;code>interface{}&lt;/code> 类型在语言内部是通过 &lt;code>reflect.emptyInterface&lt;/code> 结构体表示的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// emptyInterface is the header for an interface{} value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> emptyInterface &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> typ *rtype
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> word unsafe.Pointer
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的 rtype 字段用于表示变量的类型，另一个 word 字段指向内部封装的数据。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>接下来，我们回到这个问题，我们先看看当我们执行 &lt;code>reflect.ValueOf(xxx)&lt;/code> 的时候，&lt;code>reflect.Value&lt;/code> 的 flag 是怎么来的。依然从源码入手：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> ValueOf(i &lt;span style="font-weight:bold">interface&lt;/span>{}) Value {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> unpackEface(i)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里最重要的代码就这一行 &lt;code>unpackEface&lt;/code>，其中 &lt;code>Eface&lt;/code> 就是 &lt;code>Empty Interface&lt;/code>，所以，unpack 了啥呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// unpackEface converts the empty interface i to a Value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> unpackEface(i &lt;span style="font-weight:bold">interface&lt;/span>{}) Value {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e := (*emptyInterface)(unsafe.Pointer(&amp;amp;i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// NOTE: don&amp;#39;t read e.word until we know whether it is really a pointer or not.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> t := e.typ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> t == &lt;span style="font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> Value{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f := flag(t.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> ifaceIndir(t) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> f |= flagIndir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> Value{t, e.word, f}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>嗯，可以，代码依旧不多。首先代码将空接口类型的值 &lt;code>i&lt;/code> 通过指针强转转为了 &lt;code>emptyInterface&lt;/code> 类型的值，还记得刚才说的第2点吗？&lt;/p>
&lt;blockquote>
&lt;p>Go 语言的 &lt;code>interface{}&lt;/code> 类型在语言内部是通过 &lt;code>reflect.emptyInterface&lt;/code> 结构体表示&lt;/p>
&lt;/blockquote>
&lt;p>接着隔开5行，来到 &lt;code>f := flag(t.Kind())&lt;/code>，也就是在这里，定下了 &lt;code>Value&lt;/code> 的 kind 值。&lt;/p>
&lt;p>我们不会止步于此，再看 &lt;code>*rtype#Kind&lt;/code> 方法的源码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">const&lt;/span> (
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> kindMask = (1 &amp;lt;&amp;lt; 5) - 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// rtype is the common implementation of most values.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// It is embedded in other struct types.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// rtype must be kept in sync with ../runtime/type.go:/^type._type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> rtype &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> kind &lt;span style="">uint8&lt;/span> &lt;span style="font-style:italic">// enumeration for C
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (t *rtype) Kind() Kind { &lt;span style="font-weight:bold">return&lt;/span> Kind(t.kind &amp;amp; kindMask) }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里又是一次掩码计算，&lt;code>kindMask&lt;/code> 仍然是一个低5位的掩码，也就是 &lt;code>11111&lt;/code>。而 &lt;code>rtype&lt;/code> 类型中的 &lt;code>kind&lt;/code> 数值中存着具体数据类型。&lt;/p>
&lt;p>这里就能结合起来得到一个结论：&lt;/p>
&lt;blockquote>
&lt;p>对于每个通过调用 &lt;code>reflect.ValueOf&lt;/code> 函数得到的反射值，它的 &lt;code>Kind()&lt;/code> 方法的结果取决于编译器在编译阶段实现的到 &lt;code>emptyInterface&lt;/code> 类型的类型转换过程中存在 &lt;code>typ&lt;/code> 字段指向的 &lt;code>rtype&lt;/code> 类型的值中的 &lt;code>kind&lt;/code> 字段的值。&lt;/p>
&lt;/blockquote>
&lt;p>有点拗口，画个图示意：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/reflect/flag-sourcing.png" alt="">
&lt;/p>
&lt;p>这套关系之后，我们里问题的真相更近一步了，只要我们知道：&lt;code>reflect.Value#MapIndex&lt;/code> 方法又是怎么给返回的 &lt;code>Value&lt;/code> 对象设置它的 &lt;code>flag&lt;/code> 的呢？&lt;/p>
&lt;p>你猜到了吗？继续看源码！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (v Value) MapIndex(key Value) Value {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tt := (*mapType)(unsafe.Pointer(v.typ))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> typ := tt.elem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fl := (v.flag | key.flag).ro()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fl |= flag(typ.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> copyVal(typ, fl, e)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里方法内部第一行的 &lt;code>v.typ&lt;/code> 是怎么来的呢？回顾前面刚才看的 &lt;code>unpackEface&lt;/code> 函数，同时结合 &lt;code>Value&lt;/code> 的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> unpackEface(i &lt;span style="font-weight:bold">interface&lt;/span>{}) Value {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> e := (*emptyInterface)(unsafe.Pointer(&amp;amp;i))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t := e.typ
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> Value{t, e.word, f}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">type&lt;/span> Value &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// typ holds the type of the value represented by a Value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> typ *rtype
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> flag
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，这里的 &lt;code>v.typ&lt;/code> 就是表示变量的类型，它的类型是 &lt;code>rtype&lt;/code>。回到 &lt;code>MapIndex&lt;/code> 的代码，&lt;code>tt&lt;/code> 是将 &lt;code>rtype&lt;/code> 类型的值转换为 &lt;code>mapType&lt;/code> 类型的值，其中 &lt;code>mapType&lt;/code> 的定义就是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// mapType represents a map type.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> mapType &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rtype
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key *rtype &lt;span style="font-style:italic">// map key type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> elem *rtype &lt;span style="font-style:italic">// map element (value) type
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中的 &lt;code>key&lt;/code> 代表键值对中键的类型，而 &lt;code>elem&lt;/code> 代表键值对中值的类型。继续回到 &lt;code>MapIndex&lt;/code> 的剩余代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> typ := tt.elem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fl := (v.flag | key.flag).ro()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fl |= flag(typ.Kind())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> copyVal(typ, fl, e)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">func&lt;/span> copyVal(typ *rtype, fl flag, ptr unsafe.Pointer) Value {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> Value{typ, *(*unsafe.Pointer)(ptr), fl}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>fl&lt;/code> 通过 &lt;code>fl |= flag(typ.Kind())&lt;/code> 加上了复制了 &lt;code>typ&lt;/code> 的 &lt;code>kind&lt;/code>，也就是键值对中值的类型的 &lt;code>kind&lt;/code>。&lt;/p>
&lt;p>了解了这些原理之后，我们可以自然想到，回到我们的 demo，那我们看下 &lt;code>implicitRValue&lt;/code> 和 &lt;code>explicitRValue&lt;/code> 分别对应的 &lt;code>typ&lt;/code> 的 &lt;code>elem&lt;/code> 的值不就知道为什么后面的 &lt;code>MapIndex&lt;/code> 方法返回的 &lt;code>Value&lt;/code> 对象的 &lt;code>Kind()&lt;/code> 为什么不同了？以下上个调试截图：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/reflect/map-index-breakpoint-1.png" alt="">
&lt;img src="https://blog.hackerpie.com/images/posts/reflect/map-index-breakpoint-2.png" alt="">
&lt;/p>
&lt;h4 id="问题一总结">问题一总结&lt;/h4>
&lt;ol>
&lt;li>&lt;code>reflect.Value&lt;/code> 的 &lt;code>Kind&lt;/code> 方法返回的是自身 &lt;code>flag&lt;/code> 字段的低 5 位表示的枚举值 kind；&lt;/li>
&lt;li>&lt;code>reflect.Value&lt;/code> 的 &lt;code>MapIndex&lt;/code> 方法返回的新的 &lt;code>Value&lt;/code> 对象的 &lt;code>flag&lt;/code> 的 kind 是原 &lt;code>Value&lt;/code> 对象的值类型的 &lt;code>kind&lt;/code>，对于 &lt;code>reflect.ValueOf(map[string]interface{})&lt;/code> 的值，它的值类型的 kind 是 20，即 interface；而 对于 &lt;code>reflect.ValueOf(map[string]interface{})&lt;/code> 的值，它的值类型的 kind 是 24, 即 string。&lt;/li>
&lt;/ol>
&lt;h3 id="问题二在-reflectvalueinterface-和-reflectvalueof-这一来一往之间是哪个操作起了关键作用让反射值的-kind-得到纠正">问题二：在 &lt;code>reflect.Value#Interface&lt;/code> 和 &lt;code>reflect.ValueOf&lt;/code> 这一来一往之间，是哪个操作起了关键作用，让反射值的 Kind 得到纠正？&lt;/h3>
&lt;p>我们不妨先看看 &lt;code>Interface&lt;/code> 方法如何工作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> (v Value) Interface() (i &lt;span style="font-weight:bold">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> valueInterface(v, &lt;span style="font-weight:bold">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> valueInterface(v Value, safe &lt;span style="">bool&lt;/span>) &lt;span style="font-weight:bold">interface&lt;/span>{} {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// 为了聚焦，此处省略一些不太重要的代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> v.kind() == Interface {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// Special case: return the element inside the interface.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// Empty interface has one layout, all interfaces with
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// methods have a second layout.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> v.NumMethod() == 0 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> *(*&lt;span style="font-weight:bold">interface&lt;/span>{})(v.ptr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> *(*&lt;span style="font-weight:bold">interface&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> M()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })(v.ptr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// TODO: pass safe to packEface so we don&amp;#39;t need to copy if safe==true?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> packEface(v)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在问题一的分析中，我们可以确认 &lt;code>reflect.ValueOf(map[string]interface{})&lt;/code> 的值调用 &lt;code>MapIndex&lt;/code> 会得到的 &lt;code>Value&lt;/code> 的 &lt;code>Kind()&lt;/code> 会是 &lt;code>Interface&lt;/code>，于是我们的 demo 会走到 &lt;code>return *(*interface{})(v.ptr)&lt;/code> 这一行。其中 &lt;code>v.ptr&lt;/code> 的定义是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">type&lt;/span> Value &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// typ holds the type of the value represented by a Value.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> typ *rtype
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// Pointer-valued data or, if flagIndir is set, pointer to data.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// Valid when either flagIndir is set or typ.pointers() is true.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> ptr unsafe.Pointer
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，它指向反射值所包装的真实数据。所以，&lt;code>reflect.Value&lt;/code> 对象的 &lt;code>Interface()&lt;/code> 会返回实际的数据。&lt;/p>
&lt;p>开始意识到什么没有？如果我们再将这个实际的数据传给 &lt;code>reflect.ValueOf()&lt;/code> 函数，会发生什么？回想一下！前面已经分析过了：&lt;/p>
&lt;blockquote>
&lt;p>对于每个通过调用 &lt;code>reflect.ValueOf&lt;/code> 函数得到的反射值，它的 &lt;code>Kind()&lt;/code> 方法的结果取决于编译器在编译阶段实现的到 &lt;code>emptyInterface&lt;/code> 类型的类型转换过程中存在 &lt;code>typ&lt;/code> 字段指向的 &lt;code>rtype&lt;/code> 类型的值中的 &lt;code>kind&lt;/code> 字段的值。&lt;/p>
&lt;/blockquote>
&lt;p>想不起来的，返回去看看前面的图片。&lt;/p>
&lt;h4 id="问题二的总结">问题二的总结&lt;/h4>
&lt;ol>
&lt;li>&lt;code>reflect.ValueOf(xxx.Interface())&lt;/code> 通过先获取真实的数据再转回反射值，从而能够通过 &lt;code>Kind&lt;/code> 拿到真实数据的实际类型，而不是在 &lt;code>MapIndex&lt;/code> 过程中复制的 &lt;code>kind&lt;/code>。&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ol>
&lt;li>通过 &lt;code>reflect.Value#Interface()&lt;/code> 方法，我们获得了实际的数据的空接口表示，而再用 &lt;code>reflect#ValueOf&lt;/code> 函数将空接口转成反射值，就可以利用 &lt;code>Kind()&lt;/code> 获取到真实数据的实际类型了；&lt;/li>
&lt;li>除了字典类型的 &lt;code>MapIndex&lt;/code> 会有上述问题，同理列表型数据的 &lt;code>Index(i int)&lt;/code> 方法也有相同问题；&lt;/li>
&lt;li>在阅读反射源码的过程中，看到了一些理论上影响 golang 运行时性能的源码，比如 &lt;code>ValueOf&lt;/code> 函数会先将变量逸出到堆等，后面可以再写写关于反射带来的一些问题。&lt;/li>
&lt;/ol>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://stackoverflow.com/questions/14142667/reflect-value-mapindex-returns-a-value-different-from-reflect-valueof">StackOverflow: reflect.Value.MapIndex() returns a Value different from reflect.ValueOf()&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/#432-%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%80%BC">《Go 语言设计与实现》4.3.2节&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pkg.go.dev/reflect">golang: reflect package&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Prefix or Suffix oh-my-zsh's shell prompt</title><link>https://blog.hackerpie.com/posts/skills/prefix-or-suffix-zsh-prompt/</link><pubDate>Wed, 16 Feb 2022 23:30:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/prefix-or-suffix-zsh-prompt/</guid><description>&lt;p>Almost every developer loves his/her cool and colorful shell, so I install &lt;a href="https://ohmyz.sh/">oh-my-zsh&lt;/a> on my laptops and remote servers. However, as I use similar themes of oh-my-zsh and I also have the exactly same user name, most time I could not distinguish the actual machine on which I was operating.&lt;/p>
&lt;p>I tried to search online about how to decorate the zsh prompt so that I can insert a machine label within it. Unfortunetely, all articles which I could find specified that it has to overwrite the &lt;code>PS1&lt;/code> or &lt;code>PROMPT&lt;/code> environment variable in the &lt;code>~/.zshrc&lt;/code> file. These kinds of solutions will nail the prompt even though users change their zsh theme in the future.&lt;/p>
&lt;p>Fortunately, I suddenly realized that I could export the &lt;code>PROMPT&lt;/code> variable with shell substitution, that is my final solution:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># ~/.zshrc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>source $ZSH/oh-my-zsh.sh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># ... some lines, it is worth mentioning that the below&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># line have to be after `source $ZSH/oh-my-zsh.sh`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export PROMPT=&lt;span style="font-style:italic">&amp;#34;[devcloud]&lt;/span>$PROMPT&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Now my shell will always be prefixed a &lt;code>[devcloud]&lt;/code> label, I also added different labels on my different VPS so that I can judge if I am operating on a server quickly.&lt;/p>
&lt;p>The below shows the screenshot that prefix the prompt with a &lt;code>[devcloud]&lt;/code> label.&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/prefix-or-suffix-zsh-PROMPT.png" alt="">
&lt;/p></description></item><item><title>瞎聊：避免手握锤子看啥都是钉子</title><link>https://blog.hackerpie.com/posts/tittle-tattle/something-learned-from-techparty-blog-migration/</link><pubDate>Wed, 12 Jan 2022 11:24:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/tittle-tattle/something-learned-from-techparty-blog-migration/</guid><description>&lt;p>前两天在给 &lt;a href="http://techparty.org/">TechParty&lt;/a> 设计和制作新的官网，选型了&lt;a href="http://www.sxl.cn/">上线了&lt;/a>作为网站设计和托管的平台。最后的一个大活就是如何将 TechParty 原来的 218 篇博客文章迁移到新的官网上，一站式管理。比较遗憾的是，上线了的博客系统并没有提供编程接口用于迁移已有博客，所以唯一的方式就是自行想办法将所有文章逐一拷贝到他们的富文本编辑器中。&lt;/p>
&lt;p>TechParty 旧的博客系统是用的 Jekyll，一种主要使用 markdown 作为协作语言的静态博客站点生成工具，而上线了只支持富文本编辑器，也不支持 markdown，所以大体思路就是直接拷贝 Jekyll 生成好的 TechParty 博客的网页内容到上线了的编辑器中。但是问题是，这里面可是有 218 篇文章呢！不是一个小的工作量，所以作为程序员，第一反应就是尝试能不能将这个过程自动化？&lt;/p>
&lt;h3 id="尝试-python--selenium">尝试 python + selenium&lt;/h3>
&lt;p>第一个尝试的方案就是基于 Python + Selenium 的方式来实现整个过程的自动化。整个方案花了一下午大概4个小时的时间，包括解决 pip 依赖安装的问题、如何模拟鼠标长按选中博客文章正文的操作、如何模拟复制、如何模拟人工在上线了编辑器里点击和编辑等，最终整个方案因为无法完美模拟人工点击上线了的各个编辑框（为了进入编辑态，非编辑态时，页面上的各个控件显示为普通的文本）而失败……&lt;/p>
&lt;h3 id="人肉复制粘贴">人肉复制粘贴&lt;/h3>
&lt;p>第二天早上，痛定思痛，觉得自动化的路子虽然看起来比较聪明，但是实际上还有一些缺点或者未知问题：&lt;/p>
&lt;ul>
&lt;li>可复用性低：因为这种从 Jekyll 博客到上线了博客迁移的需求显然对我自己是一次性的任务，而对于别人可能压根没有什么需求&lt;/li>
&lt;li>未知的异常处理：哪怕我解决了交互模拟的问题，我还是无法预知脚本后续自动执行的过程中还会不会有其他问题需要解决，尽管脚本自动化很酷，但是干过的人都知道，它不是一劳永逸的事情，往往你还是需要人盯着，以备随时介入处理突发的情况，而且一旦修复完问题，你还需要脚本到底是从头再来，还是断点作业，问题只多不少，无穷无尽……&lt;/li>
&lt;/ul>
&lt;p>在决定是否改用人工方式之前，我算了道简单的数学题：&lt;/p>
&lt;ul>
&lt;li>迁移一篇文章的主要操作是：打开原文链接 -&amp;gt; 复制原文标题 -&amp;gt; 在上线了新建一篇博客 -&amp;gt; 粘贴标题 -&amp;gt; 回到原文复制原文发布时间 -&amp;gt; 粘贴到上线了的文章中 -&amp;gt; 复制原文正文 -&amp;gt; 粘贴到上线了的编辑器中 -&amp;gt; 点击上线了的“上线”按钮。如此往复就可以把所有文章都复制完。&lt;/li>
&lt;li>以上一篇文章的复制操作，我大致觉得 60 秒绝对足够了，事实上对于熟练操作之后应该不需要这么长的时间&lt;/li>
&lt;li>所以理论上复制所有文章需要的时间是： &lt;code>218 x 60 = 13080 秒 = 218 分钟 = 3 小时 38 分钟&lt;/code>&lt;/li>
&lt;li>而更加合理一点的是按照每个文章 30 秒，那总体的时间就是减半的，也就是 &lt;code>1 小时 49 分钟&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>很有意思，当我想的是我需要完成 &lt;code>218&lt;/code> 篇文章的搬迁的时候，我主观上觉得这是一个人肉操作难以短时间内完成的任务，至少可能要一整天都在干这个事情，除非用程序来自动完成。但是通过分解和评估，事实上不管是3个多小时还是2个小时，我都觉得这时间是要比写代码和调试程序的时间短的，而且结果可控的多：我很确定这是一个纯粹的时间问题，只要无脑操作，一定时间后，这个事情一定会完成，不用担心过程还有没有大的问题。&lt;/p>
&lt;h3 id="最终结果人肉操作完成用时-2-个小时出头">最终结果：人肉操作完成，用时 2 个小时出头&lt;/h3>
&lt;p>因为我希望这个事情无论如何，都要尽快完成，所以我用最笨也是最确定的方法：人肉复制粘贴。从 9:45 左右开始，到 12:05 左右完成，中间也处理少量的比如上线了网页崩溃必须刷新之类的问题，如果是继续用原来的脚本的方式，想必这类问题因为还要修改和调试代码会让我抓狂，但是人是最灵活的，所以我人肉操作的话都是顺便的事。尽管顺利完成，但是过程其实很痛苦：特别枯燥乏味，重复的操作多了之后，特别容易犯困。我是一边听着比较嗨的音乐一边抖腿才坚持弄完的。&lt;/p>
&lt;h2 id="最后的感悟">最后的感悟&lt;/h2>
&lt;p>这个事情其实很琐碎，但是对我自己挺大感触，记录一下：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>不要拿着锤子看啥都是钉子，你可能需要一把起子&lt;/strong>：作为程序员，可能习惯于用专业的视角来处理生活中的事情，什么都想要以编程的形式来解决，但是适用性是有前提的：针对问题的程序有很大的复用的价值，比如事情是重复执行的，或者，这个方案可以移植到其他类似的事情上，否则，最笨的方法反而更有效，所以不要排斥那些看起来太笨不够酷的方法，可能它们反倒是最有效的；&lt;/li>
&lt;li>&lt;strong>失败也可以有所得，只是可能性价比低&lt;/strong>：失败了的方案只是一种探索，可以发掘未知，比如我第一次知道了 selenium 的 action chains 可以用来模拟鼠标和键盘操作，这种发现和经验是可以复用的，长期来看可能是有价值的，只是当下对完成任务没有什么帮助&lt;/li>
&lt;li>&lt;strong>量化分析，帮助自己绕开情感陷阱&lt;/strong>：如果一开始我能够直接计算一下人肉操作的时间成本的话，我很可能就不会去尝试其他方案了，因为显然这种本方法确定性高，我早点完成它，我就早点可以投入到其他有价值的事情上，我可以做时间的主人，而不是把时间当成赌注，赌自动化的方案能成功，并且一切顺利；&lt;/li>
&lt;li>&lt;strong>把令人畏惧的大目标拆成给我信心的小目标&lt;/strong>：人肉复制的过程中，我刻意不去关注目前剩余的总的文章数量，这是为了避免给自己造成压力，只专注于眼下某一块的任务就好，告诉自己，只要慢慢完成每一个块就好了。所以往往我们盯着一个很大的目标的时候，我们很容易泄气，但是如果把它拆解成一个个比较小的我们有信心完成的小目标时，我们反倒容易保持专注，最终完成。&lt;/li>
&lt;/ol>
&lt;p>我个人最喜欢的两个感悟就是 1 和 3。&lt;/p></description></item><item><title>我的刻意练习——双拼输入</title><link>https://blog.hackerpie.com/posts/skills/double-input-method/</link><pubDate>Thu, 23 Dec 2021 14:38:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/double-input-method/</guid><description>&lt;p>作为一个程序员，每天都需要和键盘打交道，自然少不了打字这个事情，以前就知道有五笔输入法，但是也听说练习起来很难，加上拼音输入法很简便，自然就使用的拼音输入法。但是久了之后，总是觉得全拼输入法太死板了，有没有不需要逐个打入每个拼音字母就可以快速打出需要的字的输入法的呢？答案是有的：双拼输入法，是的，就是我在写这篇文章时所使用的输入法。当然，我现在的打字速度就跟乌龟爬行一样慢……&lt;/p>
&lt;h2 id="什么是双拼输入法呢">什么是双拼输入法呢？&lt;/h2>
&lt;p>与全拼输入法需要挨个输入拼音字母不同的是，双拼是将汉语拼音中的所有声母和韵母都映射到键盘上，所以打字的时候，我们的思维转回自然的拼音规律：声母+韵母，非常简单直观。换句话说，对于每个汉字，固定只需要 2 次敲击键盘就可以了，比起全拼自然是会更高效的，只是刚开始从全拼切换过来确实很痛苦，我自己也是在刻意练习中。比如“双拼输入法”这五个字，对应的拼音就是：&lt;/p>
&lt;pre tabindex="0">&lt;code>shuang pin shu ru fa
&lt;/code>&lt;/pre>&lt;p>按照声母和韵母分开的话，就是：&lt;/p>
&lt;pre tabindex="0">&lt;code>sh uang
p in
sh u
r u
f a
&lt;/code>&lt;/pre>&lt;p>以小鹤双拼来讲，对应的键盘输入顺序就是：&lt;code>u&lt;/code>、&lt;code>l&lt;/code>、&lt;code>p&lt;/code>、&lt;code>b&lt;/code>、&lt;code>u&lt;/code>、&lt;code>u&lt;/code>、&lt;code>r&lt;/code>、&lt;code>u&lt;/code>、&lt;code>f&lt;/code>、&lt;code>a&lt;/code>。&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/typewriting/double_input_method_example.png" alt="">
&lt;/p>
&lt;p>所以双拼输入法的原理极其简单，但是练习起来还是有一些痛苦的。&lt;/p>
&lt;h2 id="个人练习的心得体会">个人练习的心得体会&lt;/h2>
&lt;h3 id="第一周">第一周&lt;/h3>
&lt;p>第一周的打字速度跟龟速一样，基本上是打每个字都得停顿一下提前想下接下来每个字的拼音以及对应的码键。这期间，我可以把我的电脑和手机的输入法都改为双拼，使用的小鹤双拼，虽然打字速度慢得叫人别扭，但是还是可以勉强忍受的。&lt;/p>
&lt;h3 id="第二周">第二周&lt;/h3>
&lt;p>经过第一周的刻意练习后，基本上就能记住每个双拼码的键位了，所以打字速度有一定程度的提升，这个阶段的最大问题就是经常不自觉就按照全拼的输入法来打字了，比如想要打“成”字，一打得快了，就是先打了“c”，实际上应该是“i”。又或者是“就”这个字，应该是“jq”，但是总是一顺手就打成了“ji”，哪怕现在已经是第三周了，也是如此。除了输入习惯的错误，另一个错误就是没有选对字，因为打字的时候注意力都在思考键位和纠正输入的键上，所以总是不自觉刚把拼音打完，就直接空格了，结果很可能选到的词是错误的。&lt;/p>
&lt;h3 id="第三周此刻是2022-01-12的上午">第三周（此刻是2022-01-12的上午）&lt;/h3>
&lt;p>第三周会和第二周差不多，会稍微更注意候选词的问题，但是仍旧没有彻底改掉全拼遗留的输入习惯，容易一快了就敲错键，所以大部分时候的打字都还是需要在退格和重新输入中往复。不过好的一点是，打字速度还是有一些提升的，一些常用字可以很快甚至肌肉记忆般敲出来了，整体顺利和流畅的话，也能感受到双拼带给人的节奏感，期待未来某一天能够靠着双拼输入法一“写”千里。&lt;/p>
&lt;h2 id="感悟">感悟&lt;/h2>
&lt;ul>
&lt;li>刻意练习，就是决心把自己丢进不适应的状态中，并且尝试在&lt;strong>不改变环境&lt;/strong>的前提下努力改变状态，比如我一开始就故意将自己的所有设备的输入法都改为双拼，后来跟别人聊天的时候，发现自己打字好慢，还特别多错字，特别着急，但是这个时候我也没有去临时改回全拼，而是坚持继续用双拼，慢慢就发现打字速度还是能提升，也就再也没有必要考虑改回双拼输入了。想起以前我纠正自己打字时候的指法也是一样的道理。&lt;/li>
&lt;/ul>
&lt;h2 id="好看的码表图">好看的码表图&lt;/h2>
&lt;p>以下图片是我从知乎讨论区（文末附了链接）看到的一个图片，我觉得比较好看，就拿来当壁纸了，以备对双拼码表不熟悉的时候可以直接回到桌面看看，但是实际上也基本没有用上，分享给有需要的同学。
&lt;img src="https://blog.hackerpie.com/images/posts/typewriting/xiaohe_shuangpin_keyboard.jpeg" alt="">
&lt;/p>
&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/20698750">知乎：怎样记忆双拼输入法的回答&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Unicode？UTF-8？GBK？……聊聊字符集和字符编码格式</title><link>https://blog.hackerpie.com/posts/text-processing/character-sets-and-encoding-formats/</link><pubDate>Sun, 12 Dec 2021 18:25:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/text-processing/character-sets-and-encoding-formats/</guid><description>&lt;h2 id="按照习惯起个调">按照习惯起个调&lt;/h2>
&lt;p>作为程序员，经常会在编程语言、操作系统、网络以及文本编辑等多个层面遇上字符集或者字符编码的问题，尽管一般都能快速通过搜索引擎找到解决方案，但是对于这种字符集以及其相关的字符编码格式的知识，倒是未曾系统梳理。恰逢近期有了一些收获，趁热记录分享下。&lt;/p>
&lt;h2 id="从-unicode-和-utf-8-说起">从 Unicode 和 UTF-8 说起&lt;/h2>
&lt;p>对于类 Unix 操作系统（比如 Mac OS 以及 Linux 操作系统等）的用户来说，会更多地接触 UTF-8 编码格式，我也是其中一个。而我过往总是容易跟另一个词—— Unicode 混淆，所以，当我们在讨论 UTF-8 和 Unicode 的时候，我们在讨论什么？&lt;/p>
&lt;h3 id="unicode-字符集简介">Unicode 字符集简介&lt;/h3>
&lt;p>当我们说 Unicode 的时候，是在讨论一种字符集（character set）。Unicode 翻译成中文叫“统一码”，是一种可以简单理解为收录了世界上所有语言的文字和符号的全球标准。大家知道，英语的基本组成元素是 26 个英文字母加上各种标点符号；而汉语的文字则相对繁杂，大量汉字，每个文字都有各自的拼音，拼音里还要区分音调，这里提到的汉字、拼音、音调以及汉字自身的标点符号，跟英语的英文字母以及标点符号等，统统收录在了 Unicode 字符集中，而类似的，还有繁体中文、日文、韩文、俄罗斯语、越南语、泰语、蒙古语等等。&lt;/p>
&lt;p>收录了这么多的字符，就会带来一个问题：怎么整理和编排记录这些内容呢？编号！类比在一些常见的场景中，当一个集体中包含很多的个体时，为了用一种统一且简单的方式区分，我们最容易想到的就是编号。比如，给班里的同学安排座位号，给学生安排学号，给员工安排工号，等等。&lt;/p>
&lt;p>但是，计算机是不能直接理解十进制这种人类易于理解的数字的，它只能理解二进制的数值，所以，在计算机里，我们可以用编码（使用特定的二进制序列来表示一个特定的值）的方式来给这些字符和符号进行一一映射。目前 Unicode 实际应用版本 UCS-2 在计算机中使用了 2 个字节来编码一个字符，也就是 16 位的编码空间，在表示上，采用类如 &lt;code>U+????&lt;/code> 的形式，其中每个“?”都是一个十六进制数。注意，Unicode 还有个 4 字节编码版本，亦即 UCS-4，不在这里讨论。&lt;/p>
&lt;p>以下是一些示例的 Unicode 字符及其对应编码：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>编码值&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>牛&lt;/td>
&lt;td>U+725B&lt;/td>
&lt;td>汉字&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>ù&lt;/td>
&lt;td>U+00F9&lt;/td>
&lt;td>拼音 u 的四声&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>,&lt;/td>
&lt;td>U+002C&lt;/td>
&lt;td>英文逗号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>，&lt;/td>
&lt;td>U+FF0C&lt;/td>
&lt;td>中文逗号&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>😁&lt;/td>
&lt;td>U+D83D&lt;/td>
&lt;td>emoji 表情：笑脸&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>⚔&lt;/td>
&lt;td>U+2694&lt;/td>
&lt;td>emoji 表情：剑&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>是不是挺有意思的？另外是否也注意到，同样是逗号，但是英文的逗号和中文的逗号，并不是同一个符号，哪怕看起来非常相似！相信很多初学编程的同学也都踩过在代码中输入了中文逗号导致代码编译出错的坑吧！&lt;/p>
&lt;h3 id="utf-8--一种变长的-unicode-字符编码转换格式">UTF-8 —— 一种变长的 Unicode 字符编码转换格式&lt;/h3>
&lt;p>上面 Unicode 的编码方式已经理解了，但是那还只是表示层面的，字符在计算机世界里，需要被传输和存储等，这种情况下又该设计呢？最简单的方式当然是直接原样使用每个字符的两个字节即可（事实上，UTF-16 即是这种思路），但是这种方式有两种问题：&lt;/p>
&lt;ul>
&lt;li>对于英语这类只需要一些非常简单的字符就足够的语言来说，单字节的 ASCII 字符集(一种主要包含英文字母、数字和标点符号以及其他不可见字符的字符集，总共 128 个字符)刚好就足以使用，如果使用两个字节，无疑是浪费了一半的存储空间；&lt;/li>
&lt;li>取决于具体的字节序，我们在存储和传输层面还得考虑字符编码的大端序或者小端序问题。&lt;/li>
&lt;/ul>
&lt;p>为了解决这些问题，&lt;code>UTF-8&lt;/code> 应运而生。UTF 全称 Unicode Transformation Format，中文“Unicode 转换格式”。UTF-8 是一种变长编码，其最大的特点是完全兼容 ASCII 字符编码（本质上得益于 Unicode 完全兼容 ASCII 字符集），对于所有在 ASCII 字符集中出现的字符，其在 UTF-8 中也是使用完全一样的单字节表示，且二进制码值完全一致。&lt;/p>
&lt;p>比如对比以下的字符，在 ASCII 字符集下以及 Unicode 字符集中，和使用 UTF-8 表示的值：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>字符&lt;/th>
&lt;th>ASCII 码值（十进制表示）&lt;/th>
&lt;th>Unicode 码值&lt;/th>
&lt;th>UTF-8 表示&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>A&lt;/td>
&lt;td>65&lt;/td>
&lt;td>U+0041&lt;/td>
&lt;td>0100 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>97&lt;/td>
&lt;td>U+0061&lt;/td>
&lt;td>0110 0001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>57&lt;/td>
&lt;td>U+0039&lt;/td>
&lt;td>0011 1001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>,&lt;/td>
&lt;td>44&lt;/td>
&lt;td>U+002C&lt;/td>
&lt;td>0010 1100&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>因此，对于需要存储或者传输包含有较多纯英文字符的文本，UTF-8 的这种格式能够节省更多的存储空间，比如磁盘或者内存以及网络带宽等！对于 UTF-8 的完整格式，稍后会有单独的一章来具体分析。&lt;/p>
&lt;h3 id="扩展聊聊主要针对汉字的字符集gbk-和-gb18030">扩展：聊聊主要针对汉字的字符集——GBK 和 GB18030&lt;/h3>
&lt;p>上面聊到 UTF-8 优化了英文存储空间占用的问题，而且 Unicode 也是优先收录了各类西方语言的字符。那有没有专门针对我们汉字的方案呢？有的，GBK！&lt;/p>
&lt;p>GBK，全称“汉字内码扩展规范”，全名为《汉字内码扩展规范(GBK)》1.0版。GBK共收录21886个汉字和图形符号，其中汉字（包括部首和构件）21003个，图形符号883个。所以 GBK 是一种主要收录汉字的字符集。&lt;/p>
&lt;p>GBK 于 1995 年 12 月 15 日发布，而 2000 年国家质量技术监督局推出了 GB18030-2000 标准，用以取代 GBK，GB18030 完全兼容 GBK。而 GB18030 在本质上也算得上是一种 Unicode 的转换格式（UTF），只不过其转换要比 UTF-8 复杂得多，在此就不展开了。&lt;/p>
&lt;p>稍后的一些例子中还会提到 GBK 或者 GB18030，这里仅作简单介绍，有个印象，大致知道是个啥即可。&lt;/p>
&lt;h2 id="utf-8-编码格式分析">UTF-8 编码格式分析&lt;/h2>
&lt;p>UTF-8 是一种变长（长度范围为 1-4 个字节）的字符编码格式，所以一个字符对应的字节长度，需要结合每个字节开头的比特位来确认，具体的规则是：&lt;/p>
&lt;ul>
&lt;li>对于UTF-8编码中的任意字节B，如果B的第一位为0，则B独立的表示一个字符(ASCII码)；&lt;/li>
&lt;li>如果B的第一位为1，第二位为0，则B为一个多字节字符中的一个字节(非ASCII字符)；&lt;/li>
&lt;li>如果B的前两位为1，第三位为0，则B为两个字节表示的字符中的第一个字节；&lt;/li>
&lt;li>如果B的前三位为1，第四位为0，则B为三个字节表示的字符中的第一个字节；&lt;/li>
&lt;li>如果B的前四位为1，第五位为0，则B为四个字节表示的字符中的第一个字节。&lt;/li>
&lt;/ul>
&lt;p>所以，对于最长的 4 字节编码，其可表示的最大位数为 21（首字节剩余 3 位，后续 3 个字节，每个字节有 6 位， 3+3x6=21）。&lt;br>
上面的规则比较绕，为了方便理解，我们来列举下所有可能的比特序列：&lt;/p>
&lt;pre tabindex="0">&lt;code>① 单字节的情况，对应 ASCII：
0???????
② 双字节的情况，第一个字节必须 110 开头，第二个字节开头必须是 10，剩余 11 位用于编码：
110????? 10??????
③ 三字节的情况，第一个字节必须 1110 开头，第二、三个字节开头都必须是 10，剩余 16 位用于编码：
1110???? 10?????? 10??????
④ 四字节的情况，第一个字节必须 11110 开头，后续三个字节开头都必须是 10，剩余 21 位用于编码：
11110??? 10?????? 10?????? 10??????
&lt;/code>&lt;/pre>&lt;p>一些示例的对应的 Unicode 字符及其对应的 UTF-8 编码：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>类型&lt;/th>
&lt;th>Block&lt;/th>
&lt;th>字符&lt;/th>
&lt;th>Unicode 编码&lt;/th>
&lt;th>UTF-8 编码（16进制）&lt;/th>
&lt;th>UTF-8 编码（二进制表示）&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>单字节&lt;/td>
&lt;td>基本拉丁字母&lt;/td>
&lt;td>&lt;code>a&lt;/code>&lt;/td>
&lt;td>U+0061&lt;/td>
&lt;td>\x61&lt;/td>
&lt;td>01100001&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>双字节&lt;/td>
&lt;td>拉丁文补充集&lt;/td>
&lt;td>&lt;code>£&lt;/code>&lt;/td>
&lt;td>U+00A3&lt;/td>
&lt;td>\xC2\xA3&lt;/td>
&lt;td>11000010 10100011&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>三字节&lt;/td>
&lt;td>日文平假名&lt;/td>
&lt;td>&lt;code>の&lt;/code>&lt;/td>
&lt;td>U+306E&lt;/td>
&lt;td>\xE3\x81\xAE&lt;/td>
&lt;td>11100011 10000001 10101110&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>四字节&lt;/td>
&lt;td>越南语&lt;/td>
&lt;td>&lt;code>𦓡&lt;/code>&lt;/td>
&lt;td>U+D859&lt;/td>
&lt;td>\xF0\xA6\x93\xA1&lt;/td>
&lt;td>11110000 10100110 10010011 10100001&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>而我们熟悉的常见的汉字使用的都是 3 字节的编码。&lt;/p>
&lt;h2 id="一些有趣的字符编码格式的例子">一些有趣的字符编码格式的例子&lt;/h2>
&lt;h3 id="操作系统中的默认字符集和转换格式">操作系统中的默认字符集和转换格式&lt;/h3>
&lt;p>在 Windows 10 简体中文版系统中，通过在命令提示符程序中输入命令 &lt;code>chcp&lt;/code>，可以查看到系统活动代码页为 936，对应的编码格式为GBK。
&lt;img src="https://blog.hackerpie.com/images/posts/win10_active_page_code.png" alt="Windows 936">
&lt;/p>
&lt;p>而在 Linux 服务器和我个人的 Macbook 电脑（操作系统 macOS Catalina 10.15.7）上，通过打印 &lt;code>LC_CTYPE&lt;/code> 变量可以确认系统缺省使用 UTF-8 格式。
&lt;img src="https://blog.hackerpie.com/images/posts/character-encoding/macOS_CTYPE.png" alt="macOS">
&lt;img src="https://blog.hackerpie.com/images/posts/character-encoding/Linux_CTYPE.png" alt="linux">
&lt;/p>
&lt;p>系统间的这种缺省字符编码格式的差异，往往会导致一个操作系统下编辑保存好的文件，到了另一个操作系统下就会出现乱码。除了文件内容乱码，也会存在文件名乱码的情况等，原因都是类似的。&lt;/p>
&lt;h3 id="mysql-数据库中的字符集处理">MySQL 数据库中的字符集处理&lt;/h3>
&lt;p>有过 MySQL 数据库使用经验的同学一定对字符集的选择使用会有一些经验心得：&lt;/p>
&lt;ul>
&lt;li>注意避免默认的 &lt;code>latin1&lt;/code> 字符集&lt;/li>
&lt;li>如果需要支持 emoji 表情字符，还需要注意使用 &lt;code>utf8mb4&lt;/code> 字符集&lt;/li>
&lt;/ul>
&lt;p>这又是什么原因呢？历史原因！&lt;/p>
&lt;p>首先，&lt;code>latin1&lt;/code> 字符集是多字节字符编码技术之前的技术，在 MySQL 4.0 及更早之前的版本中缺省使用，可能出于向下兼容的因素，这个缺省逻辑一直保留到 5.7 版本，到了当前最新版 8.0 中，已经改为缺省 &lt;code>utf8mb4&lt;/code>。&lt;/p>
&lt;p>另外，MySQL 字符集在 MySQL 中有两套 UTF-8 的实现，大家容易想到的同名“utf8”的方案，每个字符最多占据 3 个字节的空间，是一套非完整的实现，因此 MySQL 后来将其正式名字改为“utf8mb3”，用以指示这是一套有缺陷的实现，而保留下来的“utf8”只不过是个别名而已了；如果需要完整的实现，需要使用“utf8mb4”。至于为什么会出现这种情况，根本原因还是历史。MySQL 在4.1 版本开始支持 UTF-8 编码格式，当时对 utf-8 的实现并未形成统一标准，而 MySQL 在其实现中限制了编码空间最多为3个字节，而 UTF-8 正式形成业界的标准化文档在这个事情之后。&lt;/p>
&lt;h3 id="编程语言对字符集的处理">编程语言对字符集的处理&lt;/h3>
&lt;p>来到编程语言层面，随着 utf-8 格式正式化以及发展，编程语言在字符集处理的方式上，在不同版本上也有一些有趣的历史。&lt;/p>
&lt;ul>
&lt;li>Ruby 2.0 以前的版本（不包含 2.0），如果需要指定源码的编码格式为 utf-8，需要在代码文件的开头加上魔法注释：&lt;code># encoding: utf-8&lt;/code>&lt;/li>
&lt;li>在 Python 3.0 以前的版本（不包含 3.0），如果需要指定源码的编码格式为 utf-8，需要在代码文件的开头加上魔法注释：&lt;code># -*- coding: utf-8 -*-&lt;/code>&lt;/li>
&lt;li>在 Golang 中，由于这门语言本身比较新，没有这类在老版本代码中显式声明编码格式的需要&lt;/li>
&lt;/ul>
&lt;h3 id="http-中用-accept-charset-协商字符集">HTTP 中用 &lt;code>Accept-Charset&lt;/code> 协商字符集&lt;/h3>
&lt;p>&lt;code>Accept-Charset&lt;/code> 请求头用来告知（服务器）客户端可以处理的字符集类型。借助内容协商机制，服务器可以从诸多备选项中选择一项进行应用， 并使用 &lt;code>Content-Type&lt;/code> 应答头通知客户端它的选择。&lt;/p>
&lt;p>以下是一个实际的 HTTP 协议中协商 charset 的实际例子：
&lt;img src="https://blog.hackerpie.com/images/posts/character-encoding/%e5%8d%8f%e5%95%86charset.png" alt="linux">
&lt;/p>
&lt;h3 id="html-标记语言中指定字符编码">HTML 标记语言中指定字符编码&lt;/h3>
&lt;p>通常在 HTML 里声明 UTF-8 字符编码，使用如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">meta&lt;/span> charset=&lt;span style="font-style:italic">&amp;#34;utf-8&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>字符集和字符编码技术无处不在，通过诸多实际案例展示和原理分析，看到了其有趣且应用广泛的一面。希望这篇文章，能够帮助你更加系统全面地了解掌握对它的认识和应用！&lt;/p>
&lt;p>最后附上一张图，看下一些前面提到的例子中，比如编程语言或者数据库管理系统对 UTF-8 的应用和相伴发展概况，来结束这篇文章：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/character-encoding/unicode_and_utf8_development_history.jpg" alt="">
&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/Unicode">Wikipedia：Unicode&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://unicode.yunser.com/unicode">Unicode 查询&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/zh-hans/ASCII">Wikipedia：ASCII&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83">Wikipedia：汉字内码扩展规范&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/GB_18030">Wikipedia：GB18030&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/UTF-8">Wikipedia：UTF-8&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mothereff.in/utf-8">UTF-8 encoder/decoder&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kermitproject.org/utf8.html">UTF-8 Sampler&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tool.oschina.net/hexconvert/">OSCHINA：在线进制转换&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/16521949">StackOverflow: Unicode sample text file for testing for Unicode related problems?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cloud.tencent.com/developer/article/1353937">云+社区：如何查看windows操作系统的默认编码？&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.csdn.net/yinshuilan/article/details/86081541">CSDN：查看windows与Mac的默认系统编码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.ibm.com/docs/en/integration-bus/10.0?topic=locales-changing-your-locale-linux-unix-systems">IBM: Changing your locale on Linux and UNIX systems&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/3936094">StackOverflow: Why does MySQL use latin1_swedish_ci as the default?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/5.7/en/charset.html">MySQL :: MySQL 5.7 Reference&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://dev.mysql.com/doc/refman/8.0/en/charset.html">MySQL :: MySQL 8.0 Reference&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/20523482">StackOverflow: Set UTF-8 as default for Ruby 1.9.3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/6289494">StackOverlfow: Working with UTF-8 encoding in Python source&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/MySQL">Wikipedia: MySQL&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/Python">Wikipedia: Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept-Charset">MDN: Accept-Charset&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://developer.mozilla.org/zh-CN/docs/Glossary/character_encoding">MDN: Character encoding（字符编码）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://adamhooper.medium.com/in-mysql-never-use-utf8-use-utf8mb4-11761243e434">Medium: In MySQL, never use “utf8”. Use “utf8mb4”.&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://downloads.mysql.com/docs/mysql-5.5-relnotes-en.pdf">MySQL 5.5 Release notes&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Kafka 核心设计思考——来自官方文档的总结</title><link>https://blog.hackerpie.com/posts/kafka/kakfa-main-design/</link><pubDate>Thu, 09 Dec 2021 10:16:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/kafka/kakfa-main-design/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近在学习 Kafka 的一些设计原理，偶然间发现 Kafka 官方文档中独列了 &lt;a href="https://kafka.apache.org/documentation/#design">Design&lt;/a> 一章。两天看完后觉得很兴奋，因为文档中很详细地从各方面阐述了 Kafka 官方对于 Kafka 设计的目标以及设计权衡等，让我恍然大悟 Kafka 的独特与简洁。这种快乐是阅读网上各种零散的博客文章无法比拟的。我此处总结更多是为了提升自己的领悟和理解程度，行文之中会夹杂个人主观理解，我建议大家抽出时间阅读原汁原味的&lt;a href="https://kafka.apache.org/documentation/#design">官方文档&lt;/a>。&lt;/p>
&lt;h2 id="kafka-设计目标与设计概述">Kafka 设计目标与设计概述&lt;/h2>
&lt;p>设计一个系统，精准的目标是第一步。Kafka 官方在最开始的时候，对 Kafka 的设计理想是将其做成一个可以帮助大型公司应对各种可能的实时数据流处理的通用平台。这句话里边有几个重点：“大型公司”、“实时”、“通用”，对应到系统设计上，就是需要支持大量数据的低延迟处理，并且需要考虑各种不同的数据处理场景。在官方阐述中，Kafka 着眼于以下几个核心指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高吞吐量&lt;/strong>：因为 Kafka 需要处理大量的消息；&lt;/li>
&lt;li>&lt;strong>低延迟&lt;/strong>：消息系统的关键设计指标；&lt;/li>
&lt;li>&lt;strong>支持加载离线数据&lt;/strong>：这是 Kafka 考虑的所谓“各种可能的”数据处理场景，支持从离线系统中加载数据，或者将数据加载到离线系统中，都是无法逃避的；&lt;/li>
&lt;li>&lt;strong>支持分区的、分布式的、实时的数据流处理以产生新的、派生的数据流&lt;/strong>：这个指导了 Kafka 里 topic 分区模型以及消费者模型的设计；&lt;/li>
&lt;li>&lt;strong>容错与可靠性&lt;/strong>：Kafka 作为消息中间件，核心场景之一就是作为系统间的连接器，需要保证整体业务的正常运作，可靠的消息投递机制以及应对节点故障的高可用设计等，必不可少。&lt;/li>
&lt;/ul>
&lt;p>理解了 Kafka 的设计目标以及核心指标，后续对 Kafka 的整体架构设计就会有一个方向了，因为 Kafka 的整体设计细节还算比较多，但是归根结底都是围绕这几个核心指标去做的设计，我尝试分门别类先汇总一下，可能不是很准确，希望请大家看的时候顺便赐教：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>核心指标&lt;/th>
&lt;th>实现的角度&lt;/th>
&lt;th>具体设计手段&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>高吞吐量&lt;/td>
&lt;td>读写缓存&lt;/td>
&lt;td>依赖文件系统自身的 Page Cache，而不是自己实现内存缓存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高吞吐量&lt;/td>
&lt;td>高效的数据结构&lt;/td>
&lt;td>采用顺序读写的结构，而不是 B 树等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高吞吐量&lt;/td>
&lt;td>降低大量小的 I/O&lt;/td>
&lt;td>消息分批发布，按批投递&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高吞吐量&lt;/td>
&lt;td>提高消息投递吞吐量&lt;/td>
&lt;td>由消费者批量拉取&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高吞吐量&lt;/td>
&lt;td>支持分批消息&lt;/td>
&lt;td>支持异步发送消息&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>低延迟&lt;/td>
&lt;td>避免昂贵的字节拷贝&lt;/td>
&lt;td>统一的消息格式，零拷贝技术&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>低延迟&lt;/td>
&lt;td>优化传输性能&lt;/td>
&lt;td>通过批量消息压缩减小传输数据量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>低延迟&lt;/td>
&lt;td>提升读取性能&lt;/td>
&lt;td>顺序读，日志文件分段存储，应用二分查找&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>低延迟&lt;/td>
&lt;td>降低负载均衡延迟&lt;/td>
&lt;td>producer 直连 broker&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>离线数据加载&lt;/td>
&lt;td>支持周期性大量数据加载&lt;/td>
&lt;td>依赖存储层顺序读写的常量时间复杂度的访问优势以及低廉的磁盘成本要求&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>离线数据处理&lt;/td>
&lt;td>支持并行处理&lt;/td>
&lt;td>通过分区设计以及 consumer 的 offset，支持 Hadoop 一类的并行作业以及断点作业&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>可靠性&lt;/td>
&lt;td>支持“有且仅有一次”的消息投递语义&lt;/td>
&lt;td>producer 的 ID 与消息 Sequence Number，类事务提交语义&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>可靠性&lt;/td>
&lt;td>容错处理与高可用&lt;/td>
&lt;td>ISR 机制与 Leader 均匀分布设计&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>除了上表所列内容，还有少量设计思考暂时不好归类，比如：&lt;/p>
&lt;ul>
&lt;li>消息消费进度的存储设计思考&lt;/li>
&lt;li>日志压缩（Log Compaction）的设计&lt;/li>
&lt;li>其他……&lt;/li>
&lt;/ul>
&lt;p>以上的总体设计，让 Kafka 看起来也更像是一个日志型系统，而不仅仅是传统意义上的消息队列。&lt;/p>
&lt;h2 id="高吞吐量的设计思考">高吞吐量的设计思考&lt;/h2>
&lt;h3 id="读写缓存的利用">读写缓存的利用&lt;/h3>
&lt;p>Kafka 的设计中，存储层直接基于文件系统实现，而不是额外实现复杂的存储层抽象，比如引入缓存和缓冲等。&lt;/p>
&lt;p>一般提到文件系统或者磁盘存储，大家第一反应就是“这东西不是很慢吗”？是的，一般来说，磁盘的读写速度是很慢，但也限于随机访问的前提下，而事实上，特定条件下，磁盘的顺序读写性能堪比内存的随机访问性能！是不是很出乎意料？&lt;/p>
&lt;p>另外，现代操作系统内部都已经实现对底层文件系统的统一抽象，特别是对读写性能的优化，大家可能了解的是预读（Read-Ahead）和后写（Write-Behind）。结合顺序读写的特性，这种操作系统的优化能够被发挥到极致。&lt;/p>
&lt;p>如果考虑应用层的缓存设计方案，就会考虑到 Kafka 运行于 JVM 之上，JVM 中对象的封装表示都会有额外的内存开销，这种额外开销与对象本身数据的大小相当。所以，如果是在应用层自行实现缓存层，则意味着会有额外的大致两倍于消息体积的内存开销。这个成本对于大数据处理场景来说，可不是闹着玩的。开销也不仅限于内存开销，Java 本身的 GC 算法会随着应用堆内存的增加而愈加频繁且迟钝。&lt;/p>
&lt;p>最后，缓存的设计还绕不开缓存预热的思考，由于操作系统本身对于读写性能优化的设计，可以认为预读和后写等特性已经帮助应用透明地实现了缓存的预热和落盘。而如果是在应用层面，则不得不重复造轮子，且需要考虑的细节很多。&lt;/p>
&lt;p>综上，Kafka 官方认为直接基于文件系统实现存储，是一个非常明智的决定。&lt;/p>
&lt;h3 id="顺序数据结构的妙处">顺序数据结构的妙处&lt;/h3>
&lt;p>众所周知，Kafka 采用了追加写也就是顺序写的方式来完成数据持久化，消息投递过程中也是按照顺序读的方式实现。在 Kafka 看来，顺序读写带来了诸多好处。&lt;/p>
&lt;p>在 B 树等数据结构上操作的时间复杂度是 log(n)，一种一般看来近似于常量时间复杂度的算法。但是实际上，考虑到磁盘的特殊结构以及额外的磁盘定位（事实上，定位不是一步到位的，分为寻道和旋转两个阶段，感兴趣的可以阅读《&lt;a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">磁盘I/O那些事&lt;/a>》）等，这种数据结构的操作性能的下降速度，其实是高于数据本身体积的增长的，也就是随着数据越来越大，这种数据结构的性能下降越来越快。&lt;/p>
&lt;p>而采用顺序读写，由于只需要一次磁盘定位，可以认为其操作时间复杂度为O(1)。因为一般而言，一次 I/O 操作的总体延迟，主要是磁盘定位的延迟，而数据传输的延迟与之相比不值一提。所以这种常量时间复杂度的访问操作，天然的好处是我们可以不用担心访问数据的大小。因此，这种数据结构在面对大量数据的读写时，会有更加稳定的性能表现。在 Kafka 团队看来，Kafka 可以放心地以更低成本实现存储，特别是可以以磁盘转速换取空间，这也是 Kafka 可以放心地保留历史消息而不做即刻清除的原因。&lt;/p>
&lt;p>这里补充一点来自《&lt;a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">磁盘I/O那些事&lt;/a>》）的参考信息：&lt;/p>
&lt;blockquote>
&lt;p>目前磁盘的平均寻道时间一般在3-15ms&lt;br>
7200rpm的磁盘平均旋转延迟大约为60*1000/7200/2 = 4.17ms&lt;br>
目前IDE/ATA能达到133MB/s，SATA II可达到300MB/s的接口数据传输率，数据传输时间通常远小于前两部分消耗时间&lt;/p>
&lt;/blockquote>
&lt;p>除此之外，由于是追加写顺序读，还可以简化读写操作并发的问题。我们不需要担心各种锁或者阻塞问题，读写互不干扰。&lt;/p>
&lt;h3 id="避免过多的小-io-操作">避免过多的小 I/O 操作&lt;/h3>
&lt;p>Kafka 中的 I/O 操作主要是两个环节：客户端和服务器端之间的网络 I/O，以及服务器内部持久化操作中的磁盘 I/O。在 Kafka 的整体设计里，大的思路就是降 I/O，增吞吐。&lt;/p>
&lt;p>Kafka 在设计上支持消息分批投递，并且在持久化存储上原样保存，最后也是按批交付给消费者，全程不会对此批数据进行分解或者合并。这种设计有几个好处：&lt;/p>
&lt;ul>
&lt;li>足够大的网络分包&lt;/li>
&lt;li>足够大的磁盘顺序操作&lt;/li>
&lt;li>毗邻的内存空间等&lt;/li>
&lt;/ul>
&lt;p>这里消息原样存储和投递还有一些零拷贝以及消息压缩方面的考虑，稍后也会聊到。&lt;/p>
&lt;p>这里刚好由消息分批就想到了发布者的异步消息发送，这是由客户端 SDK 完成的功能，其可以配置在超过指定时间或者超出指定消息量的情况下触发消息投递到 broker，虽然会牺牲一些投递时机的延迟，但是赢取了分批投递所带来的吞吐量的提升。&lt;/p>
&lt;p>目前为止，关于提高吞吐量的设计，画了个图，以助加深印象：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/kafka-how-to-improve-thoughput.jpg" alt="kafka 如何提高吞吐量架构">
&lt;/p>
&lt;h2 id="低延迟的设计思考">低延迟的设计思考&lt;/h2>
&lt;h3 id="避免昂贵的字节拷贝等操作">避免昂贵的字节拷贝等操作&lt;/h3>
&lt;p>为了降低延迟，broker 最好是越少干预消息约好。为此，Kafka 设计了统一的二进制消息格式，而且在消息投递的全过程中，都需要修改消息内容，带来的好处是二进制消息无需经过 broker 的任何转化处理，原样落盘。更重要的是，由于消息原样投递给消费者，可以方便结合零拷贝技术实现消息在网络的快速传输。特别是对于多消费者组的场景，消息的投递直接从 Page Cache 读取，不用担心广播带来线性的访问开销。最后通过网络传输，理论上消息投递的速率可以逼近网络连接传输速率的上限。&lt;/p>
&lt;h3 id="端到端消息压缩">端到端消息压缩&lt;/h3>
&lt;p>如果说零拷贝是为了避免无谓的开销，那将消息体进行压缩，则是为了降低数据传输的体积。Kafka 使用了端到端的分批消息压缩协议，至于为什么是分批呢？因为一般来说，在同个 topic 里，我们倾向于传输同类或者相似的消息类型，这些类型的消息会有大量重复的字段名，如果按批压缩，能够获得远比单条消息大的压缩率。由于是端到端压缩解压，Kafka broker 也就无需考虑消息本身实际使用的压缩格式，这也符合上面说的二进制消息格式中，broker 不参与消息转换的设计思想。目前，Kafka 支持的压缩协议有 GZIP、Snappy、LZ4 以及 ZStandard。&lt;/p>
&lt;h3 id="发布者的低延迟设计">发布者的低延迟设计&lt;/h3>
&lt;p>发布者的低延迟设计主要是降低负载均衡的延迟。Kafka 采用了 producer 直连 broker 的设计，而不依赖其他任何中间的路由层，好处是直接高效，减少了一层就是去除了一个环节的回路，同时降低了系统的复杂度，无需额外考虑路由层的高可用问题。但是就要求所有 broker 节点都能够获知集群的节点分布以及每个分区的 leader 所在节点等信息，这些信息由 ZooKeeper 管理。&lt;/p>
&lt;p>另外，消息投递分区由客户端也就是 producer 决定，既支持随机或者轮询等简单的均衡算法，也支持按 Key 哈希的分区算法等，这些在 producer 上完成。&lt;/p>
&lt;h3 id="消费者的低延迟设计">消费者的低延迟设计&lt;/h3>
&lt;p>消费者的低延迟，一方面是依赖前面讲的零拷贝技术的应用，另一方面是结合批量拉取消息，由于前面都有介绍，这里只是带过。&lt;/p>
&lt;h2 id="可靠性的设计思考">可靠性的设计思考&lt;/h2>
&lt;h3 id="实现有且仅有一次的消息投递语义">实现“有且仅有一次”的消息投递语义&lt;/h3>
&lt;p>想要实现刚好一次的消息投递，需要分开从发布端和消费端来看。&lt;/p>
&lt;p>在发布端，每个发布者都会获得 broker 授予的一个唯一的 ID，结合消息本身隐含的顺序的序号，可以方便 broker 识别重复投递的消息。其次，考虑到在一次事务型操作中可能会有多个消息同时发布到多个分区的需求，Kafka 也提供了类似事务的语义，具体大家可以搜索了解一下。&lt;/p>
&lt;p>来到消费端，实现刚好一次的消息投递也相对简单。由于消息拉取起点由消费者控制，所以只需要思考消费者如何避免重复拉取就好了。在官方文档中，建议的方式是消费者将已消费的消息偏移量一同记录到消费消费处理结果的输出中，这样可以保证消费者（可能是原来的消费者重启了，也可能是消费者挂了后有其他消费者分担了此消费者原来的分区）在开始拉取之前确认最后消费进度。&lt;/p>
&lt;h3 id="高可用的设计思考">高可用的设计思考&lt;/h3>
&lt;p>高可用的设计主要涉及两个内容：复制和容灾选主。&lt;/p>
&lt;p>复制上，Kafka 的每个分区都可以配置 0 个或多个副本数量，也就是每个分区对应 1 个或多个 broker 节点。follower 使用和消费者一致的批量拉取机制来同步 leader 节点的日志。&lt;/p>
&lt;p>在节点活性方面，Kafka 认为如果一个节点满足以下两点，即可称为 &lt;code>In-Sync&lt;/code> 节点：&lt;/p>
&lt;ul>
&lt;li>节点保持了到 ZooKeeper 的心跳&lt;/li>
&lt;li>节点紧跟 Leader 的日志复制，没有 “明显落后” Leader 节点的日志&lt;/li>
&lt;/ul>
&lt;p>在考虑 Leader 故障上，Kafka 放弃了大多数选举的分布式一致性方案，而是采用名为 ISR （In-Sync Replica）的方案。因为传统的大多数选举，为了容忍 &lt;code>n&lt;/code> 次 leader 故障，必须部署 &lt;code>2n+1&lt;/code> 个节点，对于需要存储大量数据的 Kafka 来说，这个成本显然过大。而采用 ISR 的方案，只需要 &lt;code>n+1&lt;/code> 个节点，就可以做到容忍 &lt;code>n&lt;/code> 次故障的情况，成本相比而言降低了接近一半。&lt;/p>
&lt;p>在 ISR 的方案下，消息被成功提交的判断就是 In-Sync 集合中的所有节点返回确认成功。一个成功提交的消息可以保证不会丢失。&lt;/p>
&lt;p>但是 ISR 的方案还需要考虑一种极端场景：如果所有 In-Sync 节点都故障了，怎样选取新的 Leader？有两种不同的取舍：&lt;/p>
&lt;ul>
&lt;li>牺牲可用性：坚决等待 In-Sync 机器恢复，不可用的时间可能更长&lt;/li>
&lt;li>牺牲一致性：选取任意一台可用的机器作为 Leader，这个机器可能是 In-Sync，也可能不是&lt;/li>
&lt;/ul>
&lt;p>在 Kafka 默认选项中，使用了前面的方案，就是 Kafka 认为一般来说一致性更重要。&lt;/p>
&lt;p>另外，Kafka 还会尽可能将所有分区的 Leader 均匀分散到不同的 broker 上。&lt;/p>
&lt;h2 id="其他设计思考">其他设计思考&lt;/h2>
&lt;h3 id="分段存储提升查找效率">分段存储提升查找效率&lt;/h3>
&lt;p>熟悉 Kafka 的同学也都知道，尽管 Kafka 的 topic 会进一步分为多个分区（partition），分区也是备份的最小单元，但是单个分区的日志在磁盘上还会进一步分解为多个段，也就是多个独立的文件，逻辑上可以见下面这个官方文档的图：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/kafka_log.png" alt="">
&lt;/p>
&lt;p>好处是什么呢？当然是方便查找了，你想想，既然消息的日志是顺序存储的，那我结合二分查找算法，不就可以支持快速定位到指定的消息了吗？&lt;/p>
&lt;h3 id="消息消费进度标记consumer-offset">消息消费进度标记——consumer offset&lt;/h3>
&lt;p>作为消息队列，broker都需要考虑一种功能：记录消息被消费的状态。一种经典的思路是标记每个消息的状态：已投递、已确认。但是这种方案有几个问题：&lt;/p>
&lt;ul>
&lt;li>可能重复投递消息：对于 broker 来说，等待确认消息的过程中有很多未知因素，可能导致消息未能被正确确认，broker 可能会被设计成再次投递未确认消息；&lt;/li>
&lt;li>额外的存储空间开销：对于每个消息，都需要额外的存储空间用于标记信息；&lt;/li>
&lt;li>需要考虑极端场景：大量消息发送后未被确认。&lt;/li>
&lt;/ul>
&lt;p>Kafka 的做法比较简单粗暴：限定每个分区一个消费者。这样一来，由于一个分区只能被一个消费者消费，而且消息顺序投递，这样就可以用一个简单的整数表示一个消费者组在一个分区上的消费进度，而不是记录每个消息的消费状态，这是一个极低的 O(1) 的常量空间开销。另外消息消费进度可以周期性更新，而且只需要更新 offset 信息，整体维护消息确认进度的成本显然更低。&lt;/p>
&lt;p>最后，Kafka 由于保留了历史消息，配合前面说的分段存储和查找，所以 Kafka 可以方便地支持回退 offset 的场景，以便重放消息。&lt;/p>
&lt;h3 id="日志压缩log-compaction">日志压缩（Log Compaction）&lt;/h3>
&lt;p>这里的日志压缩不同于前面提到的消息压缩，这里特指对日志进行合并重写，以只保留同个 key 的消息的最新版本。经过日志压缩后，保留下来的消息仍旧保持时序性不变，offset 也不变，但是整个分区内的消息的 offset 不再连续。&lt;/p>
&lt;p>至于日志压缩的作用，应该类似 Redis 的 AOF 重写，更多是为了减小存储空间的占用吧。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文以走马观花的方式介绍了 Kafka 官方对于 Kafka 设计思考以及诸多权衡，以便我自己能够快速理解 Kafka 中的很多设计的出发点，进而能够更好地理解 Kafka 的很多底层设计思路。此前我对于 Kafka 的认识仅限于它的分区设计以及offset，特别是消费者组的设计等等，但是只是知其然，官方文档的设计思考内容帮我自己补全了对于 Kafka 知其所以然的认识。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://kafka.apache.org/documentation/#design">Kafka Documentation: 4. Design&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tech.meituan.com/2017/05/19/about-desk-io.html">美团技术团队博客：磁盘I/O那些事&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>后缀表达式之逆波兰表示法</title><link>https://blog.hackerpie.com/posts/algorithms/queue-and-stack/reverse-polish-representation/</link><pubDate>Sun, 05 Dec 2021 20:56:28 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/queue-and-stack/reverse-polish-representation/</guid><description>&lt;h2 id="从中缀表达式说起">从中缀表达式说起&lt;/h2>
&lt;p>对于人类来说，中缀表达式是最直观自然的，比如“3+5x4”或者“(3+5)x4”，一般来说，对于中缀表达式，在程序中会用一个抽象语法树来表示表达式和求值，比如：&lt;/p>
&lt;pre tabindex="0">&lt;code> 3+5x4
+
/ \
/ \
3 x
/ \
/ \
5 4
--------------------------------
(3+5)x4
x
/ \
/ \
+ 4
/ \
/ \
3 5
&lt;/code>&lt;/pre>&lt;p>后续表达式求值使用二叉树的中序遍历便可。&lt;/p>
&lt;p>但是这种表达式对于计算机来说，会有2个可以考虑提升的问题：&lt;/p>
&lt;ul>
&lt;li>对于计算机不够直观，需要在树的结构上进行遍历和求值；&lt;/li>
&lt;li>额外的括号来用于明确运算优先级。&lt;/li>
&lt;/ul>
&lt;h2 id="后缀表达式">后缀表达式&lt;/h2>
&lt;p>后缀表达式，也叫&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表达式&lt;/a>，前述的表达式对应的后缀表达式为：&lt;/p>
&lt;ul>
&lt;li>&lt;code>3+5x4&lt;/code>：&lt;code>3 5 4 x +&lt;/code>&lt;/li>
&lt;li>&lt;code>(3+5)x4&lt;/code>：&lt;code>3 5 + 4 x&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>可以看出后缀表达式的特点：&lt;/p>
&lt;ul>
&lt;li>操作符在操作数的末尾，比如 &lt;code>5 x 4&lt;/code> 表示为 &lt;code>5 4 x&lt;/code>；&lt;/li>
&lt;li>无需括号表达优先级&lt;/li>
&lt;/ul>
&lt;p>从计算机的角度，后缀表达式还有以下特点：&lt;/p>
&lt;ul>
&lt;li>由于没有括号，可以节省内存&lt;/li>
&lt;li>可以基于栈结构实现后缀表达式的求值&lt;/li>
&lt;li>&lt;strong>如果对抽象语法树进行末序遍历，刚好可以得到逆波兰表达式，这点比较有意思&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="将中缀表达式转为后缀表达式">将中缀表达式转为后缀表达式&lt;/h3>
&lt;p>为了将中缀表达式转为后缀表达式，一般需要用到的是&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">调度场算法&lt;/a>，算法中需要用到一个输出队列和一个操作符栈，完整的算法细节比较多，这里简化为简单的四则运算（支持括号）来描述精简版算法，如果需要支持完整的运算符或者函数等，需要自行学习完整的调度场算法。&lt;/p>
&lt;p>以下用伪代码描述（&lt;strong>注意：&lt;/strong> 算法中的“单词符号”一词参考编译原理中的“token”一词，意思是一样的，我为了伪代码不会中英混杂，才写了中文名字，不一定精确）：&lt;/p>
&lt;pre tabindex="0">&lt;code>声明 Q：输出队列
声明 S：操作符栈
遍历中缀表达式中的每一个单词符号 x：
如果 x 是一个操作数，直接将 x 追加到输出队列 Q 末尾，否则往下检查；
如果 x 是一个左括号“(”，将 x 压入操作符栈 S 栈顶，否则往下检查；
如果 x 是一个操作符：
如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的运算符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶；
如果操作符栈 S 栈顶为一个优先级小于 x 的操作符，或者不为操作符（在这个简化算法里，只有可能是左括号），则直接将 x 压入栈顶即可。
如果 x 是一个右括号“)”，则将操作符栈 S 栈顶到往下第一个左括号“(”之间的元素依次弹出并且追加到输出队列末尾，将“(”出栈丢弃，x 也不用入栈。注意：如果栈到底后仍没有找到左括号，则说明表达式不合法，左右括号不匹配。
最后将栈 S 中的元素全部依次弹出并且入队列 Q。
&lt;/code>&lt;/pre>&lt;h4 id="实例演示">实例演示&lt;/h4>
&lt;p>用一个稍微复杂的四则运算表达式来举例：&lt;code>(12+5)x(8-1)-6x6&lt;/code>。&lt;/p>
&lt;p>则算法对应每一步的过程以及队列和栈的状态如下表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>遍历序号&lt;/th>
&lt;th>单词符号&lt;/th>
&lt;th>输出队列（左边为队首）&lt;/th>
&lt;th>操作符栈（左侧为栈底）&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>(&lt;/td>
&lt;td>（空）&lt;/td>
&lt;td>(&lt;/td>
&lt;td>遇到左括号，直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>12&lt;/td>
&lt;td>12&lt;/td>
&lt;td>(&lt;/td>
&lt;td>12 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>+&lt;/td>
&lt;td>12&lt;/td>
&lt;td>(, +&lt;/td>
&lt;td>+ 为操作符，栈顶此时为非操作符，直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>5&lt;/td>
&lt;td>12, 5&lt;/td>
&lt;td>(, +&lt;/td>
&lt;td>5 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>)&lt;/td>
&lt;td>12, 5, +&lt;/td>
&lt;td>(空)&lt;/td>
&lt;td>) 为右括号，需要将栈顶到第一个左括号之间的元素出栈入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>x&lt;/td>
&lt;td>12, 5, +&lt;/td>
&lt;td>x&lt;/td>
&lt;td>x 为操作符，栈顶为空，直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>(&lt;/td>
&lt;td>12, 5, +&lt;/td>
&lt;td>x, (&lt;/td>
&lt;td>左括号直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>8&lt;/td>
&lt;td>12, 5, +, 8&lt;/td>
&lt;td>x, (&lt;/td>
&lt;td>8 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>-&lt;/td>
&lt;td>12, 5, +, 8&lt;/td>
&lt;td>x, (, -&lt;/td>
&lt;td>- 为操作符，栈顶为非操作符，直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>1&lt;/td>
&lt;td>12, 5, +, 8, 1&lt;/td>
&lt;td>x, (, -&lt;/td>
&lt;td>1 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11&lt;/td>
&lt;td>)&lt;/td>
&lt;td>12, 5, +, 8, 1, -&lt;/td>
&lt;td>x&lt;/td>
&lt;td>遇到右括号，需要将栈顶到第一个左括号之间的元素出栈入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>12&lt;/td>
&lt;td>-&lt;/td>
&lt;td>12, 5, +, 8, 1, -, x&lt;/td>
&lt;td>-&lt;/td>
&lt;td>- 为操作符，此时栈顶元素也为操作符，且优先级更高，则将栈顶弹出入队列，再将 - 入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>13&lt;/td>
&lt;td>6&lt;/td>
&lt;td>12, 5, +, 8, 1, -, x, 6&lt;/td>
&lt;td>-&lt;/td>
&lt;td>6 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>14&lt;/td>
&lt;td>x&lt;/td>
&lt;td>12, 5, +, 8, 1, -, x, 6&lt;/td>
&lt;td>-, x&lt;/td>
&lt;td>x 为操作符，此时栈顶元素也为操作符，但优先级较低，这个时候直接将 x 入栈即可&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>15&lt;/td>
&lt;td>6&lt;/td>
&lt;td>12, 5, +, 8, 1, -, x, 6, 6&lt;/td>
&lt;td>-, x&lt;/td>
&lt;td>6 为操作数，直接入队列&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>遍历结束后，操作符栈不为空，将栈里元素依次弹出并且追加到输出队列末尾，可得输出队列结果为：&lt;/p>
&lt;pre tabindex="0">&lt;code>12, 5, +, 8, 1, -, x, 6, 6, x, -
&lt;/code>&lt;/pre>&lt;p>也就是得到的后缀表达式是 &lt;code>12 5 + 8 1 - x 6 6 x -&lt;/code>。&lt;/p>
&lt;h3 id="求值计算">求值计算&lt;/h3>
&lt;p>后缀表达式的求值过程相对比较简单直观，同样需要借助栈来实现，以下为简要的四则运算对应的后缀表达式求值算法描述：&lt;/p>
&lt;pre tabindex="0">&lt;code>声明 S：求值栈
遍历后缀表达式中的每一个单词符号 x:
如果 x 为操作数，则直接将 x 压入求值栈 S，否则往下继续；
如果 x 为操作符（在这个例子中，只有可能是+-✖️÷之一），则从栈中弹出2个元素 a 和 b，将 b 和 a 执行对应操作符的运算，将运算结果压入栈。
最后栈中应该只有一个元素，即为表达式的最终结果。
&lt;/code>&lt;/pre>&lt;p>以前一小节得到的后缀表达式 &lt;code>12 5 + 8 1 - x 6 6 x -&lt;/code> 为例，我们来看看求值过程：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>遍历序号&lt;/th>
&lt;th>单词符号&lt;/th>
&lt;th>求值栈（左侧为栈底）&lt;/th>
&lt;th>解释说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>12&lt;/td>
&lt;td>12&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>5&lt;/td>
&lt;td>12, 5&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>3&lt;/td>
&lt;td>+&lt;/td>
&lt;td>17&lt;/td>
&lt;td>遇到操作符，弹出栈中的 5 和 12，做加法 &lt;code>12 + 5&lt;/code>，得到 17，压回栈中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>4&lt;/td>
&lt;td>8&lt;/td>
&lt;td>17, 8&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>5&lt;/td>
&lt;td>1&lt;/td>
&lt;td>17, 8, 1&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>6&lt;/td>
&lt;td>-&lt;/td>
&lt;td>17, 7&lt;/td>
&lt;td>遇到操作符，弹出栈中的 1 和 8，做减法 &lt;code>8 - 1&lt;/code>，得到 7，压回栈中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>7&lt;/td>
&lt;td>x&lt;/td>
&lt;td>119&lt;/td>
&lt;td>遇到操作符，弹出栈中的 7 和 17，做乘法 &lt;code>17 x 7&lt;/code>，得到 119，压回栈中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>8&lt;/td>
&lt;td>6&lt;/td>
&lt;td>119, 6&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>9&lt;/td>
&lt;td>6&lt;/td>
&lt;td>119, 6, 6&lt;/td>
&lt;td>操作数直接入栈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>10&lt;/td>
&lt;td>x&lt;/td>
&lt;td>119, 36&lt;/td>
&lt;td>遇到操作符，弹出栈中的 6 和 6，做乘法 &lt;code>6 x 6&lt;/code>，得到 36，压回栈中&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>11&lt;/td>
&lt;td>-&lt;/td>
&lt;td>83&lt;/td>
&lt;td>遇到操作符，弹出栈中的 36 和 119，做乘法 &lt;code>119 - 36&lt;/code>，得到 83，压回栈中&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>最后，栈里刚好只剩一个元素 83，即为我们的求值结果。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>逆波兰表达式是一种更适合计算机理解的表达式表示方法，相比较抽象语法树的形式：&lt;/p>
&lt;ul>
&lt;li>在表示上，它能够节省更多的内存（如果用树，一方面的内存开销在于括号节点，另一方面的内存开销在于树节点之间的指针，如果考虑到遍历，还会有递归调用带来的调用栈的内存开销）；&lt;/li>
&lt;li>在求值上，逆波兰表达式也更简洁，同时可以避免树遍历过程中的递归形式，递归是一种人类阅读起来比较费脑的代码结构；&lt;/li>
&lt;li>支持无歧义的运算优先级而无需引入括号。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>再次声明，本文中的调度场算法和求值算法均为简化模型，如果需要了解学习完整的算法，请自行查阅维基百科等，本文末尾附有参考资料链接。&lt;/strong>&lt;/p>
&lt;h2 id="扩散思考">扩散思考&lt;/h2>
&lt;ul>
&lt;li>前缀表达式也应该具备类似的特点？&lt;/li>
&lt;li>既然是叫逆波兰表达式，那是不是也应该有波兰表达式？我猜就是前缀表达式？&lt;/li>
&lt;li>结合后缀表达式的求值算法，是不是可以快速得到将后缀表达式还原为中缀表达式的算法？&lt;/li>
&lt;/ul>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表达式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">调度场算法&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://juejin.cn/post/6844904094306402312">编译原理-词法分析&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>技术面试如何“试”</title><link>https://blog.hackerpie.com/posts/2021/interview-thinking/</link><pubDate>Sun, 07 Nov 2021 13:03:10 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/interview-thinking/</guid><description>&lt;p>毕业7年了，经历过多家不同公司的面试，这些公司的面试方式不尽相同，给我的喜恶程度不一；反过来，自己作为面试官，前后也为公司筛选物色了不少候选人，我希望我所认可的人能在后续的工作表现中证明我没看错人。我时不时会想：在技术面试中，以怎样的方式对候选人进行评估筛选，才足够高效精准？不妨先从自己所经历过的面试形式聊起吧。&lt;/p>
&lt;h2 id="我所经历过的几类面试风格">我所经历过的几类面试风格&lt;/h2>
&lt;p>细想一路走来，我所经历过的面试风格大致分为几类：&lt;/p>
&lt;ol>
&lt;li>全凭一张嘴，双方直接聊&lt;/li>
&lt;li>家庭作业型&lt;/li>
&lt;li>理论知识问答&lt;/li>
&lt;li>算法能力考查&lt;/li>
&lt;/ol>
&lt;h3 id="全凭一张嘴双方直接聊">全凭一张嘴，双方直接聊&lt;/h3>
&lt;p>这种面试风格，存在于早期的互联网企业面试中，而据我了解，目前一些小公司也会采用这种方式。就我自己来说，15年我面试 4399 以及大疆的时候，均是采用的这种风格的面试。&lt;/p>
&lt;p>面试双方就简历上的项目展开讨论，了解候选人在项目中的具体工作和成果，以及候选人在编程素养等方面的水平。这种面试方式简单快速，但是有效与否，很大程度上依赖候选人的表达能力以及面试官自身经验能力水平以及对人才的判断能力。&lt;/p>
&lt;p>采用这种面试风格的公司，大抵是一些小型公司或者初创公司，因为这类公司一般相对难以吸引到拥有“优秀”背景的人才前来面试，除非事前双方都是知根知底的，于是公司必然会在人才招募上务实。如果本身吸引到的人才数量有限背景有限，公司自己还平添很多繁琐的面试环节或者提高通过门槛，最终可能一个人都招不到。所以，开门见山，直奔主题。&lt;/p>
&lt;h3 id="家庭作业型">家庭作业型&lt;/h3>
&lt;p>这种面试形式，是在简历通过筛选后，面试官给候选人发送一份家庭作业一样的项目需求，描述一个极小型项目的设计要求，然后让候选人自己在业余时间完成。之后的技术面试则一方面结合这个小项目进行实现思路以及架构设计交流，另一方面则通过过往项目经验了解候选人的能力水平。我在 15 年面试 ThoughtWorks 以及 20 年面试 crypto.com 公司的时候，都体验过这种面试形式，也是我个人最为喜欢的形式。而根据朋友的分享，我了解到 AWS 中国也是采用的此类面试形式。&lt;/p>
&lt;p>我之所以喜欢这种面试风格，主要是因为方式灵活以及代码更容易让技术面试双方建立共同语言。灵活性方面，它给我自己发挥的空间最大，比如我想向面试官展现我的开发习惯，比如单元测试和代码注释等，那我就会在这种作业型项目上用心完善单测和注释。其次我也会注意文档的编写和注释，特别是一份帮助面试官方便快速运行你的代码的 README 文档。这些，都不需要像其他面试一样临场发挥，我只需要思考如何准备得更好就行了。另一方面，代码是技术人之间的共同语言，这种方式拉近了我和面试官之间的距离。比如我在去年面试 crypto.com 的过程中，我在交完作业到开始正式面试中间的这段时间里，我和 crypto.com 的面试官在微信上就已经开始就代码问题进行了多次讨论。在这种非正式的交流过程中，我得以一种比较轻松自在的方式去表达我的思考，而面试官也在此过程中向我展示了他自身的技术水平，这种方式让我感觉就是在进行如常的技术交流而已，仿佛是在一个同事或者同行一起探讨而已。&lt;/p>
&lt;p>尽管我自己喜欢这种面试风格，但是身边还是会有朋友或者同事并不认同这种方式，甚至觉得恶心。主要原因有两种，一是这种方式会更多地占用候选人的业余时间，二是这种方式可能会存在候选人作弊，由他人代为完成了作业。只不过我真觉得这两对我而言都不是问题。假如我需要追求一个未来3-5年适合我的公司，我觉得充分的准备以完整展现自己，是值得投入时间的。而第二个问题，我觉得配合面试流程中对作业中的实现细节以及架构思路等进行讨论，是可以快速判断这个代码是不是候选人自己独立完成的。&lt;/p>
&lt;h3 id="理论知识问答">理论知识问答&lt;/h3>
&lt;p>这种就是大家常说的“八股文”了，就是面试官按照题库给出数据结构、数据库、计算机网络以及编程语言等等科目相关的基础知识问题，由候选人做出正确的回答。大家常吐槽的题目比如红黑树的原理、MySQL innoDB 存储引擎的索引设计、TCP 三次握手/四次挥手以及 Golang 语言的 goroutine 调度原理等等。而由于这种面试环节中的题目过于基础和客观，导致候选人不得不在面试之前花费大量的时间和精力进行复习，但是入职后在工作岗位上却由于没有实践机会后快速遗忘，留下了“面试造火箭，日常拧螺丝”的调侃。&lt;/p>
&lt;p>至于采用这种面试风格的公司，皆是各类校招社招人才热捧的大公司，比如国内的 BAT，美团字节以及 Shopee 等等。这些公司所提供的薪资水平在业界出于中上甚至天花板水平，自然每年都能够吸引到大量优秀人才前往应聘。&lt;/p>
&lt;p>我自己在去年面试腾讯和字节的经历中，一路摸爬滚打，每天起早摸黑复习基础知识，或者是根据面试过程中暴露的薄弱知识点进行强化复习，最终才终于通过这些公司的技术基础关。&lt;/p>
&lt;p>尽管我并不喜欢这种方式，但是在 Shopee 公司担任面试官的时候，按照部门统一面试要求，我还是不得不机械地从题库中挑选各个知识点的题目，逐一向候选人提问。在一个半小时的时间里，我需要按序完成对候选人项目经验、编程语言基础、数据结构、计算机网络、数据库理论、操作系统原理、网络安全的理论知识考查，另外还包含一道中等难度的编程题，因为面试评估采用各环节得分累加的形式，我无法跳过其中某一部分。我仅有的发挥空间，大概就是面试开场的项目经验交流以及对候选人的回答决定是否追问了。&lt;/p>
&lt;p>这种面试形式，更像是一种应试考核，尽管不够个性化，但是却仍然不失为一种筛选人才的方式。因为本身这类热门公司就能够吸引到超级多优秀人才，在简历筛选环节留下来的人选，绝大部分人基础都不会太差，基本素养也不至于太糟糕，而大公司在实现一种盈利机制的稳定之后，并不需要太多领军型人才，更多是需要一些踏实勤奋的人去保证这套机制的运作如常，甚至允许部分蛀虫的存在。在这种背景下，大公司的面试筛选机制便可以相对简单粗暴，公司只需要确保挑选出来的人在某个角度客观上比其他人突出即可。古代科举考试以及现代高考或者公务员考试制度，大致如此，虽说无法挖掘人的特长或者个性，但是确实公平。&lt;/p>
&lt;h3 id="算法能力考查">算法能力考查&lt;/h3>
&lt;p>除开上面几种类型，我遇到的这种类型特点是面试绝不寒暄，也不多聊理论，简单自我介绍后，面试官直接给出算法题目，要求直接完成算法题实现。去年在 flexport 公司就是这种面试形式，当然，我没有通过。而众所周知，谷歌、微软、字节跳动、pony.ai 等公司都是比较重视算法能力的，如果候选人想要追求这类公司的岗位机会，算法能力太差是注定不行的。而今年在和一个海归的朋友聊的时候，他也聊到美企普遍重视算法能力，所以面试多是简单粗暴的多道算法题。这就让人忍不住又得提一下 Homebrew 作者 Max Howell 因为没有完成翻转二叉树的算法题而没有通过谷歌面试的故事。&lt;/p>
&lt;p>尽管好的算法对于软件设计来说确实可以降本增效，但是对于大部分工程师来说，更多时候他们需要完成的是如何通过技术方案的组合来给出一个商业产品的解决方案。这也让我想起18年底的时候，一个刚入职微软半年左右的朋友，通过猎头找到我，希望跟我了解 Shopee 的工作情况，他正在考虑跳槽 Shopee。因为他觉得入职微软之后大失所望，尽管他准备微软的面试上花了很大力气，微软在他的想象里，一直是个高效专业的公司，但是实际他当时所在的团队所维护的代码，实在难以恭维，而且很多所学毫无用武之地。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>这里我们先汇总对比下几种面试风格：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>形式&lt;/th>
&lt;th>形式简述&lt;/th>
&lt;th>举例公司&lt;/th>
&lt;th>好处&lt;/th>
&lt;th>不足&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>纯口头交流&lt;/td>
&lt;td>全程口头沟通，交流技术想法等&lt;/td>
&lt;td>早期的大疆、4399&lt;/td>
&lt;td>简单快速，成本低&lt;/td>
&lt;td>重度依赖候选人表达能力以及面试官慧眼识人能力&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>家庭作业型&lt;/td>
&lt;td>面试前完成作业，面试中交流作业实现思路等&lt;/td>
&lt;td>thoughtworks、crypto.com、AWS&lt;/td>
&lt;td>给候选人更多发挥空间，能更真实考查候选人的编码习惯和规范等&lt;/td>
&lt;td>加大业余时间成本，需要避免候选人作弊，难以通过作业考查复杂架构能力&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>理论知识问答&lt;/td>
&lt;td>结构化面试，一问一答，客观问题作答&lt;/td>
&lt;td>腾讯、字节跳动&lt;/td>
&lt;td>简单粗暴、相对公平&lt;/td>
&lt;td>相对死板，可能错过高潜人才&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>算法能力考查&lt;/td>
&lt;td>直接完成算法编写，每轮面试以编写算法代码为主&lt;/td>
&lt;td>微软、flexport&lt;/td>
&lt;td>相对公平&lt;/td>
&lt;td>相对死板，可能错过高潜人才&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="面试方式与体验">面试方式与体验&lt;/h2>
&lt;p>这里想插入说一声的是，面试是公司形象宣传的第一站，好的面试体验带给候选人好的印象，甚至可以成为口碑传播的基础，所以对于面试形式的选择，除了效率，还要考虑候选人的体验。就我自己而言，由于我非常喜欢家庭作业型的面试风格，我个人也感觉在这类面试中，我的表现是最好的。尽管由于客观原因，我都没有去成这些公司，但是我至今仍对这些公司存有好感，以至于在面试后的很长一段时间，我都会持续地向身边找工作的朋友安利这类公司。我的逻辑很简单：能给候选人发挥空间的公司，相信在公司内部，文化也会相对更开放。所以，如果你是20年底到现在找我推荐公司的朋友，很大概率都会听我提到 crypto.com。&lt;/p>
&lt;h2 id="技术面试何去何从">技术面试何去何从？&lt;/h2>
&lt;p>纵观当下的技术面试评估方式，各有各的适用方式，即所谓存在即合理。小公司吸引力有限，不得不直奔主题，大公司总体供大于求，可以任性采用客观考题等等。但是合理之余，是否可以更高效？&lt;/p>
&lt;p>不妨回归到面试本身的供需双方，作为候选人，&lt;strong>我希望面试不要是一种内卷的形式，我需要展现的是我日常工作的真实能力水平以及我所积累的经验等等&lt;/strong>；而作为雇主，首先需要&lt;strong>想明白到底自己需要的是怎样的人才，其次在保证候选人真实展现他的能力水平之后，我可以快速评估我的岗位需求与他的能力水平是否足够契合&lt;/strong>，如果不够，他是否有足够的潜力在不久的将来胜任这个工作？行业和世界持续演变，目前技术面试评估的形式不会是终点，但是它会往哪去呢？另外考虑到程序员行业人才的持续饱和以及国内的业务发展进入一个存量市场的角逐，还有最近屡屡传闻的大厂取消 996 甚至推行 1075 工作制的新闻，未来一定是一个各个企业精打细算过日子的世界，未来是一个追求高效的市场。那么所谓高效意味着什么？&lt;/p>
&lt;h3 id="理想的高效">理想的“高效”&lt;/h3>
&lt;p>候选人一方的高效，是不需要在面试之前额外花费大量的时间和精力去刻意学习一些与日常工作关系不大的东西，而是能够有一种方式支持候选人将日常工作中的积累转换为一种看得见的真实的可考查的形式。或许我们可以对候选人在全网声誉（博客、开源代码等）进行一种量化评估，也可能给候选人提供一个精准的个性化问题，让候选人可以在面试过程中随机应变运用自身积累对问题求解实现。&lt;/p>
&lt;p>在雇主一方的高效，是希望尽可能还原真实的候选人的形象，而不是一个临时抱佛脚所修饰出来的形象，以便客观地将候选人与自身业务所需人才的特征进行契合度评估，以求通过面试的人才能够胜任工作并且和团队一起走得更远。更长远看，雇主肯定希望招募到出活更好更快的人才，称手高效的技术评估手段必然是关键一环。最理想的面试，自然是完整还原工作场景，让候选人代入到其中。比如团队向候选人直接呈现自己所曾经或者现在面对的问题或者挑战，进而观察候选人在问题或者挑战面前所采取的解决问题的思路和所做的尝试等等。但是碍于很多干扰因素，比如技术选型、商业机密性等等，我们实际上还是需要屏蔽掉很多无关信息，直击要害，那么，我们必然要对每个问题进行抽象，再由候选人尝试做出解答。&lt;/p>
&lt;p>设想这样的未来：候选人没必要刻意刷题，也没得刷，随时都可以在面试中淋漓尽致地展现真实的自己，将更多的业余时间留给真正需要自我提升的地方；而企业可以有更高效的方式筛选候选人，面试官不再是一个没有感情的提问机器。这个未来所需要的解决方案，我也还没有答案，也没有在市面上找到答案，但是或许，会是下一个机会。&lt;/p>
&lt;p>而最后，这真的是人性深处的需要吗？要是，不管工具多完美，人最终的归宿是想着办法卷起来呢？&lt;/p></description></item><item><title>部分应用与柯理化</title><link>https://blog.hackerpie.com/posts/programming-paradigm/partial-application-and-currying/</link><pubDate>Sun, 15 Aug 2021 21:18:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/programming-paradigm/partial-application-and-currying/</guid><description>&lt;p>在最近学习函数式编程的过程中，反复接触到的就是“柯理化”这个概念，特别数学范有没有？虽然看过多次，但是一直不是很好地理解它，恰逢今天在阅读《Scala 函数式编程》这本书的过程中加深了理解，便写个文章，总结一下。&lt;/p>
&lt;h2 id="柯理化">柯理化&lt;/h2>
&lt;p>柯理化，英文叫“Currying”，命名源自逻辑学家 Haskell Curry 的名字。在数学和编程领域，&lt;strong>柯理化&lt;/strong>用于将一个接收多个参数的函数转换为一系列只接收单个输入参数的函数。比如，将一个接收三个参数的函数 &lt;code>f&lt;/code> 进行柯理化，会得到三个新的函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>x = f(a, b, c) 变为：
h = g(a)
i = h(b)
x = i(c)
或者使用匿名函数按序调用的形式，则为：
x = g(a)(b)(c)
&lt;/code>&lt;/pre>&lt;p>这样讲或许仍有点不好理解，我们用个数学函数的例子来分解。假如我们有函数 &lt;code>f(a, b, c) = a² + b - c&lt;/code>，并且有 &lt;code>a = 2&lt;/code>、&lt;code>b = 3&lt;/code>、&lt;code>c = 1&lt;/code>，则一般数学求解过程中，我们可以直接将 a、b、c 的值对应代入函数右侧式子，得到 &lt;code>2² + 3 - 1 = 6&lt;/code>，于是我们知道 &lt;code>f(2, 3, 1) = 6&lt;/code>。这个过程很直观很好理解，也很亲切对不对？&lt;/p>
&lt;p>但是，假如我们要求每次只能代入函数的一个输入值，会是怎样的过程呢？&lt;/p>
&lt;ul>
&lt;li>第一步，我们代入 &lt;code>a = 2&lt;/code>，我们将得到 &lt;code>f(2, b, c) = 2² + b - c&lt;/code>，我们可以记 &lt;code>g(b, c) = f(2, b, c) = 4 + b - c&lt;/code>；&lt;/li>
&lt;li>第二步，我们代入 &lt;code>b = 3&lt;/code>，我们得到 &lt;code>g(3, c) = 4 + 3 - c&lt;/code>，我们可以记 &lt;code>h(c) = g(3, c) = 7 - c&lt;/code>；&lt;/li>
&lt;li>最后一步，我们代入 &lt;code>c = 1&lt;/code>，我们得到 &lt;code>h(1) = 7 - 1 = 6&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>上述的过程，向我们展示了我们是如何通过每次代入一个输入值而得到一个输入值数量减 1 的新函数。&lt;/p>
&lt;ul>
&lt;li>第一步，&lt;code>a&lt;/code> 在 &lt;code>f(a, b, c)&lt;/code> 上的代入得到了 &lt;code>g(b, c)&lt;/code>；&lt;/li>
&lt;li>第二步，&lt;code>b&lt;/code> 在 &lt;code>g(b, c)&lt;/code> 上的代入得到了 &lt;code>h(c)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>进一步，我们可以定义一组新的函数：&lt;/p>
&lt;ul>
&lt;li>对应第一步，我们定义一个新函数 &lt;code>F(a)&lt;/code>，由于对 &lt;code>a&lt;/code> 的代入得到了 &lt;code>g(b, c)&lt;/code>，于是 &lt;code>F(a) = g(b, c)&lt;/code>，即 &lt;code>F(a)&lt;/code> 是一个输入为 &lt;code>a&lt;/code>，输出为函数 &lt;code>g(b, c)&lt;/code> 的函数；&lt;/li>
&lt;li>对应第二步，我们定义一个新函数 &lt;code>G(b)&lt;/code>，由于对 &lt;code>b&lt;/code> 的代入得到了 &lt;code>h(c)&lt;/code>，于是 &lt;code>G(b) = h(c)&lt;/code>，即 &lt;code>G(b)&lt;/code> 是一个输入为 &lt;code>b&lt;/code>，输出为函数 &lt;code>h(c)&lt;/code> 的函数；&lt;/li>
&lt;li>对应第三步，我们定义一个新函数 &lt;code>H(c)&lt;/code>，由于对 &lt;code>c&lt;/code> 的代入得到了最终式子，这里可以暂时记为 &lt;code>H(c) =&amp;gt; R&lt;/code>，R 表示实数集合。&lt;/li>
&lt;li>以上三步，结合到一起，就有 &lt;code>f(a, b, c) = F(a)(b)(c)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>这样循环通过每次只代入一个输入值最后得到一组每个函数都只有一个输入值的新函数的过程，就叫&lt;strong>柯理化&lt;/strong>，而 &lt;code>F(a)&lt;/code>、&lt;code>G(b)&lt;/code>以及 &lt;code>H(c)&lt;/code> 就是我们在&lt;strong>柯理化&lt;/strong>过程中间得到的中间函数。&lt;/p>
&lt;h2 id="部分应用">部分应用&lt;/h2>
&lt;p>从上面的分解过程可以看出，与我们习以为常的直接将 &lt;code>a, b, c&lt;/code> 的值全部代入到式子中不同，我们在柯理化的过程中，每次只代入一个输入值，从而得到一个新的返回函数的函数，这种过程就叫&lt;strong>部分应用&lt;/strong>。以下是部分应用的定义：&lt;/p>
&lt;blockquote>
&lt;p>部分应用（partial application）这个名词，表示函数被应用的参数不是它所需要的完整的参数。&lt;/p>
&lt;/blockquote>
&lt;p>依然拗口，是不是？现在结合上面的例子，其实就好理解了，正常来说，我们要对 &lt;code>f(a, b, c)&lt;/code> 求解，肯定是要应用 &lt;code>a&lt;/code>、&lt;code>b&lt;/code>、&lt;code>c&lt;/code> 三个参数的，但是第一次只能应用 &lt;code>a&lt;/code> 这个输入值，于是，我们还不能知道 &lt;code>f(a, b, c)&lt;/code> 函数的值，但是我们得到了一个新的函数，这个新的函数将不再依赖 &lt;code>a&lt;/code> 这个参数。&lt;/p>
&lt;p>所以，柯理化的过程必然会有部分应用的身影，但是只是相关，并非等价，因为按照部分应用的定义，满足部分应用的过程不一定就是柯理化的过程，这个很好证伪，就不赘述了。&lt;/p>
&lt;h2 id="柯理化与函数闭包">柯理化与函数闭包&lt;/h2>
&lt;p>在前面函数柯理化的过程中，我们将函数输入值代入之后的输出都是一个新的函数，对应到编程中就是返回函数的函数，而编程语言中柯理化实现的基础就依赖了闭包的功能，即返回的新函数隐含了对于外部函数的输入值的引用。这点也是将函数闭包和柯理化关联起来的比较有意思的一点。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>《Scala 函数式编程》—— Paul Chiusano, Runar Bjarnason 著&lt;/li>
&lt;li>Wikipedia: &lt;a href="https://en.wikipedia.org/wiki/Currying">Currying&lt;/a>&lt;/li>
&lt;li>Wikipedia: &lt;a href="https://zh.wikipedia.org/zh-hans/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">闭包 (计算机科学)&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>数据结构：单调栈</title><link>https://blog.hackerpie.com/posts/algorithms/monotonous-stacks/monotonous-stacks/</link><pubDate>Wed, 04 Aug 2021 23:13:28 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/monotonous-stacks/monotonous-stacks/</guid><description>&lt;h1 id="什么是单调栈">什么是单调栈&lt;/h1>
&lt;p>单调栈是指从栈顶到栈底，栈内元素的值符合单调性的一种特殊数据结构。从栈顶到栈底，元素的值单调递减，称为单调递减栈；反之，称为单调递增栈。&lt;/p>
&lt;pre tabindex="0">&lt;code> \ 9 / \ 1 /
| 7 | | 3 |
| 5 | | 5 |
| 3 | | 7 |
| 2 | | 9 |
------- -------
单调递减栈 单调递增栈
&lt;/code>&lt;/pre>&lt;h1 id="单调栈的维护">单调栈的维护&lt;/h1>
&lt;p>为了维持栈的单调性，在往栈内插入元素时，需要比较循环比较栈顶元素与待插入元素的值的大小，以单调递增栈举例，需要始终确保栈顶元素的值大于等于待插入元素的值方可插入，否则需要先弹出栈顶元素之后，重复“检查-弹出”的流程，直到栈为空，或者栈顶元素的值大于等于待插入元素的值。&lt;/p>
&lt;p>假设需要插入的元素按照序列 &lt;code>5, 2, 3, 7, 1&lt;/code> 从左到右遍历，且需要维护单调递增栈，则插入过程为：&lt;/p>
&lt;pre tabindex="0">&lt;code> \ / \ / \ / \ / \ /
| | | 2 | | 3 | | | | 1 |
| 5 | | 5 | | 5 | | 7 | | 7 |
------- ------- ------- ------- -------
(1) (2) (3) (4) (5)
&lt;/code>&lt;/pre>&lt;p>(1) 待插入 5，栈为空，直接插入 5；&lt;br>
(2) 待插入 2，栈顶元素为 5，大于待插入元素 2，2 可以直接插入；&lt;br>
(3) 待插入 3，栈顶元素为 2，不满足大于等于 3 的要求，所以弹出栈顶元素 2；此时新的栈顶元素为 5，大于 3，3 直接入栈；&lt;br>
(4) 待插入 7，栈顶元素为 3，不满足大于等于 7 的要求，所以弹出栈顶元素 3；此时新的栈顶元素为 5，仍然小于 7，于是也弹出栈顶元素 5；最后栈为空，直接插入 7；&lt;br>
(5) 待插入 1，栈顶元素为 7，大于待插入元素 1，1 可以直接入栈。&lt;/p>
&lt;p>类似地，假如我们翻转下插入的顺序，即按照按照序列 &lt;code>5, 2, 3, 7, 1&lt;/code> 从右到左顺序插入单调递增栈，则插入过程为：&lt;/p>
&lt;pre tabindex="0">&lt;code> \ / \ / \ / \ 2 / \ /
| | | | | 3 | | 3 | | 5 |
| 1 | | 7 | | 7 | | 7 | | 7 |
------- ------- ------- ------- -------
&lt;/code>&lt;/pre>&lt;h2 id="单调栈的性质总结">单调栈的性质总结&lt;/h2>
&lt;p>通过上面的两个例子，可以总结出单调递增栈的性质：&lt;/p>
&lt;blockquote>
&lt;p>单调递增栈可以表示：按照元素入栈顺序，入栈元素前面比它&lt;strong>大&lt;/strong>的所有元素中离它最近的元素。&lt;/p>
&lt;/blockquote>
&lt;p>更具体地讲，当我们从左到右访问序列时，则单调递增序列表示入栈元素左边所有比它大的元素中，距离它最近的元素，比如第一个例子中，3左边第一个比它大的元素是5，而7左边没有比它大的元素；反过来，当我们从右到左访问序列时，则单调递增序列表示入栈元素右边所有比它大的元素中，距离它最近的元素，比如7右边没有比7大的元素，1右边也没有比1大的元素，而2右边第一个比2大的元素刚好是3，5右边比5大的第一个元素是7。&lt;/p>
&lt;p>很容易通过类似的演示归纳总结单调递减栈的性质：&lt;/p>
&lt;blockquote>
&lt;p>单调递增栈可以表示：按照元素入栈顺序，入栈元素前面比它&lt;strong>小&lt;/strong>的所有元素中离它最近的元素。&lt;/p>
&lt;/blockquote></description></item><item><title>算法题解：二叉树寻路</title><link>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</link><pubDate>Sat, 31 Jul 2021 18:20:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</guid><description>&lt;p>本题来自 Leetcode 的 &lt;a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104 题&lt;/a>，是一道很有趣的考察二叉树数据结构的题，同时由于二叉树父子节点之间的特殊关系，同时还可以运用到位运算来巧妙解题。&lt;/p>
&lt;p>先贴一下题目：&lt;/p>
&lt;blockquote>
&lt;p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。&lt;br>
如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；&lt;br>
而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。
&lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png" alt="">
给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。&lt;/p>
&lt;/blockquote>
&lt;p>示例 1：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：label = 14
输出：[1,3,4,14]
&lt;/code>&lt;/pre>&lt;p>示例 2：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：label = 26
输出：[1,2,6,10,26]
&lt;/code>&lt;/pre>&lt;h3 id="算法题解思路1运用二叉树的节点的数值特性推导出公式求解">算法题解思路1：运用二叉树的节点的数值特性推导出公式求解&lt;/h3>
&lt;p>观察这个“之”字形二叉树，我们可以得出几个特点：&lt;/p>
&lt;ol>
&lt;li>假如所有节点都是按照从左到右依次递增，按照二叉树的特性，我们可以归纳总结出：
&lt;pre tabindex="0">&lt;code>记 vi = 某个节点的数值
v(左子节点) = 2 x vi
v(右子节点) = 2 x vi + 1
相反：
v(父节点) = vi / 2
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>对于每层(第一层为根节点)的第一个和最后一个节点，会有：
&lt;pre tabindex="0">&lt;code>v（第一个节点）= 2^(n-1) // 2 的 n-1 次方，n为当前层数
v（最后一个节点）= 2^n - 1 // 2 的 n 次方减 1，n为当前层数
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>对于任意一个数值，可以求出其所在的层数为：
&lt;pre tabindex="0">&lt;code>level = log2(N) + 1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>从根节点开始，所有奇数层的节点是从左到右依次递增的；而所有偶数层的节点是从右到左依次递增的；&lt;/li>
&lt;li>对于某一层的所有节点来说，它们都是一个等差数列，所以数列对称位置上的两个节点数值之和总是相等，即第一个节点和最后一个节点的值之和一定等于第二个节点和倒数第二个节点的值之和。结合第 2 点，这个和始终为 2^(n-1) + 2^n - 1。&lt;/li>
&lt;/ol>
&lt;p>结合以上5点性质，我们写出求任意一个节点的伪代码为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>def getParentLabel(label: &lt;span style="">int&lt;/span>) -&amp;gt; label: &lt;span style="">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level := log2(label) + 1 &lt;span style="font-style:italic">// 求 label 所在层级
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="">如果&lt;/span> level &lt;span style="">为偶数：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">则获得当前节点的对称节点的值，再求父节点的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">如果&lt;/span> level &lt;span style="">为奇数：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">则直接求父节点的值，再求父节点的对称节点的值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>def pathInZigZagTree(label: &lt;span style="">int&lt;/span>) -&amp;gt; path: []&lt;span style="">int&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path := [label] &lt;span style="font-style:italic">// label 是路径的最后一个节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> loop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">如果&lt;/span> label &lt;span style="">等于&lt;/span> 1&lt;span style="">，则跳出循环，因为此时已经到达根节点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">父节点&lt;/span> := getParentLabel(label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">将父节点加到&lt;/span> path &lt;span style="">的开头位置&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label := &lt;span style="">父节点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">返回&lt;/span> path
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对应的 Golang 代码为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-style:italic">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> getParentLabel(label &lt;span style="">int&lt;/span>) &lt;span style="">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n := int(math.Log2(float64(label))) + 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> n % 2 == 0 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label = int(math.Pow(2, float64(n-1)) + math.Pow(2, float64(n))) - 1- label &lt;span style="font-style:italic">// 先对称翻转
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">return&lt;/span> label / 2 &lt;span style="font-style:italic">// 再算父节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> int(math.Pow(2, float64(n-2)) + math.Pow(2, float64(n-1))) - 1 - label / 2 &lt;span style="font-style:italic">// 直接算父节点的对称翻转节点
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> pathInZigZagTree(label &lt;span style="">int&lt;/span>) []&lt;span style="">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> label == 1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> []&lt;span style="">int&lt;/span>{1}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original := label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path := []&lt;span style="">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> label == 1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label = getParentLabel(label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = append(path, label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> i := 0; i &amp;lt; len(path) / 2; i++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path[i], path[len(path) - 1 - i] = path[len(path) - 1 - i], path[i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = append(path, original)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提交运行，结果为双 100。&lt;/p>
&lt;h3 id="算法题解思路2位运算">算法题解思路2：位运算&lt;/h3>
&lt;p>这个思路其实还是基于思路1的归纳总结，但是更巧妙的是可以结合位运算的特性，因为我们都知道，对于对2乘法和对2除法，在位运算里都是简单的位移操作，往左移1位就是乘以2，反之，往右移就是除以2。&lt;/p>
&lt;p>那么好，怎样将位运算技巧运用进来？我们重新回顾上面 5 个性质中的部分性质：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>父节点的计算：&lt;/p>
&lt;pre tabindex="0">&lt;code>v(父节点) = vi / 2
// 换成位计算，就是：
v(父节点) = vi &amp;gt;&amp;gt; 1 // 即右移1位
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>对称节点的和为 &lt;code>2^(n-1) + 2^n - 1&lt;/code>，也就是二进制的 &lt;code>0b100...0&lt;/code>（&lt;code>n-1&lt;/code>个&lt;code>0&lt;/code>）加上 &lt;code>0b00...00&lt;/code>（&lt;code>n&lt;/code>个&lt;code>0&lt;/code>）再减去 &lt;code>0b1&lt;/code>，即 &lt;code>0b1011...11&lt;/code>（&lt;code>n-1&lt;/code>个低位均为&lt;code>1&lt;/code>）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>而对于某一层的节点的值，其值的范围为&lt;code>[2^(n-1), 2^n-1]&lt;/code>，亦即&lt;code>[0b100...00，0b111...11]&lt;/code>，总位数为&lt;code>n&lt;/code>，结合上面新的第 2 点，我们可以知道，每个节点，与其对称节点的各自的值的 &lt;code>n-1&lt;/code> 个低位相加刚好等于 &lt;code>0b11...11&lt;/code>（&lt;code>n-1&lt;/code>位的二进制），也就是说，一个节点的对称节点的值，刚好等于这个节点的值的最高1位，加上剩余&lt;code>n-1&lt;/code>位的反码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分情况讨论：&lt;br>
4.1. 如果当前行是偶数，则计算父节点值的过程是：&lt;/p>
&lt;pre>&lt;code> value = (value &amp;amp; 100...00 + !(val &amp;amp; 11...11)) // 100...00 表示保留高1位，1...11 表示保留低 n - 1 位
value &amp;gt;&amp;gt; 1
&lt;/code>&lt;/pre>
&lt;p>4.2. 如果当前行是奇数，则计算父节点值的过程是：
value &amp;raquo; 1
value = (value &amp;amp; 100&amp;hellip;00 + !(val &amp;amp; 11&amp;hellip;11)) // 100&amp;hellip;00 表示保留高1位，1&amp;hellip;11 表示保留低 n - 2 位
当 value ≠ 1 时，可以简单右移操作不管放在前面还是后面执行，都不会影响计算结果。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>按照新的思路，可以得出以下算法实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-style:italic">&amp;#34;math&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> getParentLabel(label &lt;span style="">int&lt;/span>) &lt;span style="">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> n := int(math.Log2(float64(label)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label = label &amp;gt;&amp;gt; 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mask := 1 &amp;lt;&amp;lt; (n-1) &lt;span style="font-style:italic">// 0b1000000, n-1个0，用来保留最高位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> lowMask := mask - 1 &lt;span style="font-style:italic">// 0b0111111, n-1个1，用来取低n-1位
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> label = label &amp;amp; mask + (^label &amp;amp; lowMask)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> pathInZigZagTree(label &lt;span style="">int&lt;/span>) []&lt;span style="">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> label == 1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> []&lt;span style="">int&lt;/span>{1}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original := label
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path := []&lt;span style="">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> label == 1 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">break&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label = getParentLabel(label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = append(path, label)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> i := 0; i &amp;lt; len(path) / 2; i++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path[i], path[len(path) - 1 - i] = path[len(path) - 1 - i], path[i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> path = append(path, original)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> path
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提交后，同样双100通过，对比两种解题思路，基本思路一致，从结果看，执行用时和内存消耗也确实一致，只不过一种是直观表达，一种是位运算角度计算，而后者还统一了计算逻辑。&lt;/p></description></item><item><title>算法题解：扣分后的最大得分</title><link>https://blog.hackerpie.com/posts/algorithms/dynamic-programming/maximum-number-of-points-with-cost/</link><pubDate>Sun, 18 Jul 2021 16:48:43 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/dynamic-programming/maximum-number-of-points-with-cost/</guid><description>&lt;p>题目来自 Leetcode 的 &lt;a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost/">5815 题&lt;/a>。&lt;/p>
&lt;p>题目的核心是：从二维矩阵中的每行中选取一个格子，每次选择一个格子后，所累计的最新积分等于前面已获积分加上被选格子的分数减去上一个格子和当前被选格子的列差。用公式表达更清晰：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>points &lt;span style="font-style:italic">// 表示 m x n 的二维矩阵每个格子的分数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>score(r, c) &lt;span style="font-style:italic">// 表示选取到 r 行 c 列所获得的最大得分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>score(r+1, c^) = score(r, c) + points[r+1, c^] - abs(c - c^)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过这个关系，可以确定两个事情：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>这是一个典型的动态规划问题&lt;/strong>：问题的最优解依赖子问题的最优解，且子问题的最优解相互影响，这一点是和贪心算法最大的不同；&lt;/li>
&lt;li>在为每一行选择一个格子时，要使 &lt;code>score(r+1, c^)&lt;/code> 的值最大，需要找到一对特殊的 &lt;code>(c, c^)&lt;/code> 的值，这也就是意味着：每次在为每一行挑选最优的格子时，需要针对结合上一行的每一列，与当前行的每一列，找出最优组合。&lt;/li>
&lt;/ol>
&lt;p>按照这个思路来写代码的话，整个算法的时间复杂度是 &lt;code>O(RC²)&lt;/code>，空间复杂度是 &lt;code>O(C)&lt;/code>。直接提交，会触发 TLE（Time Limit Exceed）。&lt;/p>
&lt;h3 id="优化思路">优化思路&lt;/h3>
&lt;p>回到最开始列的式子那里，调整式子的写法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>score(r+1, c^) = score(r, c) - abs(c-c^) + points[r+1, c^]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，其中 points[r+1, c^] 是不变量，要使 &lt;code>score(r+1, c^)&lt;/code> 的值最大，只需要满足 &lt;code>score(r, c) - abs(c-c^)&lt;/code> 最大即可。&lt;/p>
&lt;p>由于 &lt;code>abs(c-c^)&lt;/code> 表示相邻两行的两个格子的列差，&lt;code>(c-c^)&lt;/code>的正负结果受两者的相对位置关系影响，于是，我们分开两种情况来考虑：&lt;/p>
&lt;ol>
&lt;li>上一行的格子所在列 &lt;code>c&lt;/code> 为下一行的格子所在列 &lt;code>c^&lt;/code> 的左边或正上方，假设 &lt;code>lmax&lt;/code> 表示 &lt;code>score(r, c) - (c^-c)&lt;/code> 的最大值，则当&lt;code>c^&lt;/code> 从左到右移动的过程中，每向右移动一个格子，对于新的 &lt;code>c^^&lt;/code> 而言，它的 &lt;code>lmax&lt;/code> 等于 &lt;code>max(lmax - 1, score(r, c^^))&lt;/code>。为什么呢？因为不管上一行选择的格子在左侧的哪一列，对于下一行来说，只要它向右移动一格，它和上一行所选格子在横向上的距离就大了 1，于是有 &lt;code>lmax - 1&lt;/code>，而新的 &lt;code>lmax&lt;/code> 要么是从原来的 &lt;code>lmax&lt;/code> 走下来，要么是从 &lt;code>c^^&lt;/code> 的正上方走下来，后者则不需要扣减分数，于是得出 &lt;code>lmax = max(lmax - 1, score(r, c^^))&lt;/code>。&lt;/li>
&lt;li>上一行的格子所在列 &lt;code>c&lt;/code> 为下一行的格子所在列 &lt;code>c^&lt;/code> 的左边或正上方，这种情况类似，只不过每次下一行都是从右往左移动一个格子。所以，类似的，在这个场景里，我们记从上一行右侧到下一行的最大分数为 &lt;code>rmax&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>综合两种情况，我们只要找出 &lt;code>max(lmax, rmax)&lt;/code> 的结果即可。&lt;/p>
&lt;h3 id="编码实现">编码实现&lt;/h3>
&lt;p>每次为新的一行选择格子时，需要参考上一行的选择结果，所以需要空间上需要两个数组：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>dp []&lt;span style="">int64&lt;/span> &lt;span style="font-style:italic">// 表示上一行每一列求得的最大分数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>ndp []&lt;span style="">int64&lt;/span> &lt;span style="font-style:italic">// 表示新一行每一列求得的最大分数
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后的代码是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> max(a, b &lt;span style="">int64&lt;/span>) &lt;span style="">int64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> a &amp;gt;= b {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> maxPoints(points [][]&lt;span style="">int&lt;/span>) &lt;span style="">int64&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rows := len(points)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> rows == 0 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cols := len(points[0])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp := make([]&lt;span style="">int64&lt;/span>, cols)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> r := 0; r &amp;lt; rows; r++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ndp := make([]&lt;span style="">int64&lt;/span>, cols)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lmax := int64(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> c := 0; c &amp;lt; cols; c++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lmax = max(lmax - 1, dp[c])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ndp[c] = max(ndp[c], lmax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmax := int64(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> c := cols - 1; c &amp;gt;= 0; c-- {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rmax = max(rmax - 1, dp[c])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ndp[c] = max(ndp[c], rmax)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> c := 0; c &amp;lt; cols; c++ {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ndp[c] += int64(points[r][c])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dp = ndp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret := int64(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> _, v := &lt;span style="font-weight:bold">range&lt;/span> dp {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> ret &amp;lt; v {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ret = v
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> ret
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>提交后结果是：&lt;/p>
&lt;pre tabindex="0">&lt;code>执行用时: 216 ms
内存消耗: 15.3 MB
&lt;/code>&lt;/pre>&lt;p>双100通过。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://leetcode-cn.com/circle/discuss/8o9q5h/">Leetcode 第250场周赛讨论区-吴自华的回答&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>依赖倒置原则</title><link>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</link><pubDate>Wed, 07 Jul 2021 21:22:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</guid><description>&lt;p>说起依赖倒置原则，已经不是个新鲜的词了，虽然也知道依赖倒置原则的具体设计模式，但是一直觉得难以理解何为“倒置”，直到今晚重新静心阅读了 Wikipedia 才恍然大悟！欣喜之余，赶紧写篇文章总结。&lt;/p>
&lt;h3 id="传统软件分层设计模式">传统软件分层设计模式&lt;/h3>
&lt;p>在软件设计开发的时候，我们都会自然而然思考系统的分层设计，比如以一个典型的三层架构来举例：&lt;/p>
&lt;pre tabindex="0">&lt;code>---------------
服务层 （提供 API 服务）
---------------
↓
---------------
业务逻辑层 （封装具体的业务逻辑）
---------------
↓
---------------
存储层 （处理数据存取）
---------------
&lt;/code>&lt;/pre>&lt;p>依照此架构设计，我们可能自然而然地将各层代码实现直接封装在三个不同的代码包，其中 &lt;code>package.service&lt;/code> 直接依赖 &lt;code>package.business&lt;/code>，而 &lt;code>package.business&lt;/code> 则直接依赖 &lt;code>package.repository&lt;/code>。因此形成以下链式依赖链：&lt;/p>
&lt;pre tabindex="0">&lt;code>package.service ---&amp;gt; package.business ---&amp;gt; package.repository
&lt;/code>&lt;/pre>&lt;p>这种分层代码设计风格直接&lt;strong>耦合了依赖双方的实现&lt;/strong>，假如被依赖的包需要修改代码逻辑，则很可能导致依赖它的上层代码需要相应修改，极端场景下，这种耦合带来的变动影响可能扩散到整个依赖链。&lt;br>
其次，由于上层代码依赖了下层代码的具体实现，导致了上层代码的可复用性降低。举个具体例子，我们有一个运行了很久的系统，出于技术考量，我们需要将其存储层从 MySQL 移植到 MongoDB 上，而整个系统的核心业务逻辑并不需要也不应该有任何改变，如果是采用上述这种分层架构，则会导致我们除了替换存储层代码实现，还要相应修改业务逻辑层的代码，这就是我说的直接依赖实现会降低依赖一方的可复用性降低。&lt;/p>
&lt;h3 id="依赖倒置原则">依赖倒置原则&lt;/h3>
&lt;p>先照本宣科讲下依赖倒置原则的含义：&lt;/p>
&lt;blockquote>
&lt;p>高层级的模块不应该依赖低层级的模块。它们都应该依赖抽象（比如，接口）&lt;br>
抽象不应该依赖实现细节。实现细节（具体的实现）应该依赖抽象&lt;/p>
&lt;/blockquote>
&lt;p>有点抽象，有点拗口，有点无情，有点无理取闹对不对？&lt;br>
还是尝试用大白话解释一下：&lt;/p>
&lt;ol>
&lt;li>高层级的模块应该依赖的是低层级的模块的行为的抽象，取决于具体编程语言，可以是抽象类或者接口等技术；&lt;/li>
&lt;li>第2句话其实很简单，只有一个意思：只要依赖了实现，就是耦合了代码，所以我们需要始终依赖的是抽象，而不是实现。&lt;/li>
&lt;/ol>
&lt;p>将上面举的例子按照依赖倒置原则设计，就是这样子了：&lt;/p>
&lt;pre tabindex="0">&lt;code>package.service ---&amp;gt; package.business.interface
↑
↑ 实现
↑
package.business ---&amp;gt; package.repository.interface
↑
↑ 实现
↑
package.repository
&lt;/code>&lt;/pre>&lt;p>以上面的模式来说，&lt;code>package.service&lt;/code> 不再直接依赖于 &lt;code>package.business&lt;/code>，而是依赖了 &lt;code>package.business.interface&lt;/code> 接口，也就是 &lt;code>package.business&lt;/code> 的抽象。&lt;br>
另一方面，&lt;code>package.business&lt;/code> 也不再是一个被依赖方，而是对 &lt;code>package.business.interface&lt;/code> 的实现，也就是也依赖了 &lt;code>package.business.interface&lt;/code> 抽象。&lt;code>package.business&lt;/code> 从传统分层结构里的被依赖方变成了上面模式中的实现抽象接口的依赖方，这就是“倒置”一词的来由。倒置并不是说这种模式反转了依赖的方向，变成低层级代码依赖高层级代码，而是说原来的被依赖方也变成了依赖方，减少了高层级代码到低层级实现之间的依赖。&lt;/p>
&lt;blockquote>
&lt;p>the &amp;ldquo;inversion&amp;rdquo; concept does not mean that lower-level layers depend on higher-level layers directly&lt;/p>
&lt;/blockquote>
&lt;p>在上面的模式中，由于上层代码与下层代码实现解耦，只要下层代码的抽象（也就是上层依赖的接口）不变，就不会对上层有任何影响。这样，假如我们需要将一个系统的存储层迁移到另外的数据库，就只需要切换存储层实现的代码即可，这样业务逻辑层就不用跟着做任何调整。&lt;/p>
&lt;p>从这种模式很容易就可以看出，它可以帮助我们设计出低耦合、高复用性的代码。&lt;/p>
&lt;h3 id="其他好处">其他好处&lt;/h3>
&lt;p>（未完待续，持续更新）&lt;/p>
&lt;h3 id="依赖注入">依赖注入&lt;/h3>
&lt;p>（未完待续，持续更新）&lt;/p>
&lt;h1 id="参考资料">参考资料&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency inversion principle&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>对于测试数据管理的思考</title><link>https://blog.hackerpie.com/posts/2021/test-data-management-thinking/</link><pubDate>Sat, 03 Jul 2021 12:25:10 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/test-data-management-thinking/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在研发流程管理中，测试环节，不管是白盒测试还是黑盒测试，都是确保研发交付质量的关键。在过往的工作经验之中，测试数据构造一直是影响开发人员自测和测试人员测试质量的一个重要因素，开发人员疲于为测试或者产品体验构造特定场景所需的测试数据，而测试人员往往总因为测试数据不符合用例前置条件的要求，被迫等待开发人员构造数据，最终导致大量的沟通成本和时间成本。&lt;/p>
&lt;p>为什么测试数据构造会如此麻烦？我认为主要还是业务本身的流程过长带来的问题，比如看一个典型的供应链商品采购仓储环节的流程：
&lt;img src="https://blog.hackerpie.com/images/posts/2021/%e6%b5%81%e7%a8%8b.jpg" alt="">
&lt;/p>
&lt;p>在一个黑盒测试的场景下，假如测试人员需要针对“入库预约”环节进行测试，为了避免脏数据导致业务流程中断，最好的方式是从流程起点重新构造整套测试数据，然而在人手操作的情况下，这显然是难以完成的。&lt;/p>
&lt;h2 id="测试数据管理">测试数据管理&lt;/h2>
&lt;p>我调研了国内外关于测试数据构造相关的一些讨论，发现了测试数据管理，英文 Test Data Management，为了逼格，可以简称“TDM”，这个术语的存在。关于测试数据管理，大家都在说它的成本有多高，但是至今却也没有找到相对通用的解决方案，更别说成熟的解决方案了。&lt;/p>
&lt;h3 id="测试数据管理的方案思考">测试数据管理的方案思考&lt;/h3>
&lt;p>按照测试数据管理的切入点以及执行的方式，我觉得可以归纳总结出以下几种形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>复制生产环境数据&lt;/strong>：这种方式产生的数据，一般都满足严格的业务测试需求，数据的质量比较高，但是引入隐私安全和监管风险，且数据量比较大，存储成本高；&lt;/li>
&lt;li>&lt;strong>复制部分生产环境数据&lt;/strong>：这种方式降低存储成本，但是提高了维护成本，特别是关系型数据库，在所谓“部分”数据的前提下，需要针对不同库表指定不同的数据过滤方案；&lt;/li>
&lt;li>&lt;strong>复制生产数据，进行数据混淆处理&lt;/strong>：这种方式可以起到一定的隐私安全防护，但是类似复制生产环境数据的方案，需要针对不同库表指定不同的数据混淆规则，同时需要注意关系数据库的主键外键关系等；&lt;/li>
&lt;li>&lt;strong>执行接口调用，生成业务数据&lt;/strong>：这种方式在接口正常符合和逻辑正确的前提下，方便获得符合测试条件的数据。但是有维护开发成本，需要跟着接口设计调整，改动相对高频。另外特定场景，比如支付，需提供后门接口，以便测试脚本绕过支付等涉及第三方服务的业务，留下安全隐患。另外脚本不得不适配不同的接口协议和复杂接口认证流程等；&lt;/li>
&lt;li>&lt;strong>直接向数据库插入符合测试前置条件的新数据&lt;/strong>：自由度最高，数据完整度可控，能够获得隔离性最高的测试数据集。维护成本高，耦合技术方案存储层设计。管理成本高，需要一种高效组织和检索的方式以避免重复和凌乱的测试数据集。但是这种方式是相对稳定的方案。&lt;/li>
&lt;/ul>
&lt;h3 id="我的方案">我的方案&lt;/h3>
&lt;p>（待续……）&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.informatica.com/services-and-training/glossary-of-terms/test-data-management-definition.html">What is Test Data Management?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.delphix.com/glossary/what-is-test-data-management">What is Test Data Management?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>解决 Mac OS 下 MySQL 客户端连接 caching_sha2_password 插件加载失败问题</title><link>https://blog.hackerpie.com/posts/2021/fix-mysql-caching-sha2-password-problem/</link><pubDate>Sun, 20 Jun 2021 11:29:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/fix-mysql-caching-sha2-password-problem/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在开发我自己的 &lt;a href="https://github.com/Martin91/gofixtures">&lt;code>gofixtures&lt;/code>&lt;/a> 项目时，项目单测需要用到 MySQL，于是模仿 go-txdb 的方式，使用 docker 在本地起了 MySQL 容器。执行测试时，出现如下错误：&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2059 (HY000): Authentication plugin &amp;#39;caching_sha2_password&amp;#39; cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found
&lt;/code>&lt;/pre>&lt;h2 id="原因分析">原因分析&lt;/h2>
&lt;p>结论：本地客户端版本过低，不支持服务器端版本的鉴权方式。&lt;/p>
&lt;h3 id="环境">环境&lt;/h3>
&lt;p>客户端：&lt;/p>
&lt;ul>
&lt;li>&lt;code>mysql Ver 14.14 Distrib 5.7.13, for osx10.11 (x86_64) using EditLine wrapper&lt;/code>&lt;/li>
&lt;li>macOS 10.14.6 Mojave&lt;/li>
&lt;/ul>
&lt;p>服务器端：&lt;/p>
&lt;ul>
&lt;li>version: 8.0.25&lt;/li>
&lt;li>runtime environment: docker container&lt;/li>
&lt;/ul>
&lt;h3 id="原因">原因&lt;/h3>
&lt;p>MySQL 从 8.0 版本开始缺省使用 &lt;code>caching_sha2_password&lt;/code> 作为验证方式，而 5.7 并不支持这种验证方式（5.7 默认使用 &lt;code>mysql_native_password&lt;/code>）。&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;h3 id="方案一升级客户端版本">方案一：升级客户端版本&lt;/h3>
&lt;p>这个比较简单，不用展开。&lt;/p>
&lt;h3 id="方案二设置使用旧的-mysql_native_password-方式">方案二：设置使用旧的 &lt;code>mysql_native_password&lt;/code> 方式&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>首先通过命令行登陆容器 shell：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>docker exec -it mysql /bin/bash &lt;span style="font-style:italic"># mysql 是你的容器名字，我的就叫 mysql&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用容器内的 mysql 命令连接服务器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>mysql -uroot &lt;span style="font-style:italic"># 你可能需要别的连接参数，我的没有密码&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>修改 root 账号的验证方式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sql" data-lang="sql">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">ALTER&lt;/span> &lt;span style="font-weight:bold">USER&lt;/span> &lt;span style="font-style:italic">&amp;#39;root&amp;#39;&lt;/span>@&lt;span style="font-style:italic">&amp;#39;%&amp;#39;&lt;/span> IDENTIFIED &lt;span style="font-weight:bold">WITH&lt;/span> mysql_native_password &lt;span style="font-weight:bold">BY&lt;/span> &lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>完成！&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://blog.csdn.net/u010358168/article/details/81253744">完美解决ERROR 2059 (HY000): Authentication plugin &amp;lsquo;caching_sha2_password&amp;rsquo; cannot be loaded问题&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.51cto.com/fengfeng688/2147169">MySQL8.0新特性——默认使用caching_sha2_password作为身份验证插件&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>《Paxos Made Simple》中文翻译：Paxos 如此简单</title><link>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</link><pubDate>Wed, 28 Oct 2020 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>个人在学习理解 Paxos 算法的过程中，花了比较多的时间，从最开始直接查看中文博客资料，感觉都是看完不知所以然或者有很多疑问，于是决定死磕《Paxos Made Simple》论文原文。但是由于有些英文的意思我自己理解起来还是有点困惑，于是过程中遇到无法理解的内容，一方面是会翻阅前辈们已经写过的论文的翻译作为参考，二是在搜索引擎里就一些难以理解的点搜索中英文的讨论，以此解决自己心中的困惑。在磕磕碰碰中完成论文的阅读之后，仍有一些不尽透彻之处，加上个人认为此论文已有的翻译质量参差不齐，所以斗胆想通过翻译以及必要译注再次加深自己的理解，另外可能的话，也希望本次翻译能够帮助到未来可能会遇到和我一样困惑的人。&lt;/p>
&lt;h3 id="部分关键术语表">部分关键术语表&lt;/h3>
&lt;p>论文中有一些关键术语，我已经力求用词准确，并在论文中尽力保持术语翻译的一致性，目的是尽量充分传达论文本身用词的精准，建议读者可先仔细阅读此表。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原文术语&lt;/th>
&lt;th>翻译中使用术语&lt;/th>
&lt;th>译者注&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>value(s)&lt;/td>
&lt;td>值&lt;/td>
&lt;td>值可能比较抽象，觉得太抽象的读者建议理解为提案的“内容”亦可&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>learn&lt;/td>
&lt;td>获知&lt;/td>
&lt;td>有些文章译作“了解”或者“学习”，但是这里反复斟酌，还是觉得“获知”更贴切，目的性更强烈&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>propose&lt;/td>
&lt;td>提议&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>chosen&lt;/td>
&lt;td>选定&lt;/td>
&lt;td>一个被选定的值，意味着一个被“一致”确认下来的值&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>agent&lt;/td>
&lt;td>代理&lt;/td>
&lt;td>依旧觉得翻译成“代理”过于字面化&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proposer(s)&lt;/td>
&lt;td>提议者&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>acceptor(s)&lt;/td>
&lt;td>接受者&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>learner(s)&lt;/td>
&lt;td>学习者&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fail / failure&lt;/td>
&lt;td>失效/故障&lt;/td>
&lt;td>意味着系统已经完全不能工作&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>proposal&lt;/td>
&lt;td>提案&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>accept&lt;/td>
&lt;td>接受&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>number&lt;/td>
&lt;td>编号&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>distinguished&lt;/td>
&lt;td>特定的&lt;/td>
&lt;td>文中用于形容某个经过选举而被选中的角色&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="翻译全文">翻译全文&lt;/h2>
&lt;h3 id="paxos-如此简单">Paxos 如此简单&lt;/h3>
&lt;p>2001年11月1日&lt;/p>
&lt;h3 id="摘要">摘要&lt;/h3>
&lt;p>当用浅显易懂的英语来表达的话，Paxos 是非常简单的。&lt;/p>
&lt;h3 id="1-导引">1 导引&lt;/h3>
&lt;p>Paxos 算法——一个用于实现一个容忍错误的分布式系统的算法，让很多人觉得难以理解，这可能是因为对于很多读者们而言，原来的表述太过于让人摸不着头脑&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>了。事实上，它是最简单浅显的分布式算法。它的核心是一个一致性算法——“synod”算法&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。在下一节中，将会看到这个一致性算法不可避免地遵循一些我们希望它能够满足的特性。最后一节阐述了完整的 Paxos 算法，这个算法是通过将一致性（的实现）直接应用到用于构建分布式系统的（多副本）状态机&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>这种方法中得到的——这种所谓的方法应该是众所周知的，因为它是分布式系统理论中最常被引用的论文的主题。&lt;/p>
&lt;h3 id="2-一致性算法">2 一致性算法&lt;/h3>
&lt;h4 id="21-问题描述">2.1 问题描述&lt;/h4>
&lt;p>假设有一个由多个进程组成的集合，集合里的每个进程都可以提议（可能不同的）值&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>。一致性算法保证在被提议的这些值中只有一个值能够被选定。一旦一个值被选定，则所有进程都需要能够获知（learn）这个被选定的值。一致性的安全性要求做到：&lt;/p>
&lt;ul>
&lt;li>只有被提议的值才可以被选定，&lt;/li>
&lt;li>只能有一个值能被选定，&lt;/li>
&lt;li>只有一个值真的已经“确定”被选定，进程才能获知这个值已被选定&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>（译注：只有一致同意后的值，且不可能会被推翻，才能够周知给集合里的进程，结果就能使所有进程达成共识）&lt;/li>
&lt;/ul>
&lt;p>我们不会尝试去明确精准的活性要求&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>。无论如何，（算法的）目标是要保证被提议的值中有某个值能够被选定，并且一旦一个值被选定了，进程最终能够获知这个被选定的值。&lt;/p>
&lt;p>我们让三类代理（agent）来执行这个一致性算法中的三个角色：提议者（proposers）、接受者（acceptors）以及学习者（learners）。在实际实现中，一个独立的进程可以充当不止一个代理，但是从代理到进程之间的映射关系不是我们这里关注的重点。&lt;/p>
&lt;p>设想代理之间可以通过发送消息的方式相互通信。我们使用传统的异步（模型），而不是拜占庭问题模型，也就是说：&lt;/p>
&lt;ul>
&lt;li>代理以任意速度运行，可能因停止而失效（指不能正常工作），也可能重启。由于所有代理都有可能在一个值被选定之后失效再接着重启，除非失效或者重启的代理能够记住一些关键信息，否则没有任何解决方案。&lt;/li>
&lt;li>消息发送的长度可以是任意的，消息也可以重复或者丢失，但消息不会被篡改&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>。&lt;/li>
&lt;/ul>
&lt;h4 id="22-值的选定">2.2 值的选定&lt;/h4>
&lt;p>选定一个值的最简单的方式就是只有一个接受者的代理：一个提议者将一个提案发送给这个接受者，而后者直接选定它收到的第一个提议的值即可。这种方案虽然简单，却是无法叫人满意的，因为这个（唯一的）接受者一旦失效，将导致后续的操作无法继续。&lt;/p>
&lt;p>所以，让我们来尝试选定值的另一种方法吧。不再是单一的接受者，我们现在尝试使用多个接受者代理的方式。一个提议者将一个提议的值发送给一群接受者。一个接受者可能*接受（accept）*这个被提议的值。一旦一个足够大数量的接受者的集合都接受了一个值，那么这个值就可以算是被选定了。多大的数量才算足够大？为了确保有且只有一个值被选定，我们可以让一个所谓足够大的集合等同于这些代理中的“大多数”组成的集合。因为任意两个“大多数”的集合必然拥有至少一个共同的接受者，并且假如一个接受者最多只能接受一个值，这个方法就是行得通的。（在很多的论文中都有对于“大多数”的浅显的概括）&lt;/p>
&lt;p>在不考虑（系统）故障或者消息丢失的情况下，我们期望在哪怕只有一个提议者提出值的时候也能选定一个值。这引出了条件：&lt;/p>
&lt;pre tabindex="0">&lt;code>P1. 接受者必须接受它收到的第一个提案。
&lt;/code>&lt;/pre>&lt;p>但是这个条件引入了另一个问题。在几乎同一时间，多个不同的提议者可能提议多个不同的值，并且发生了一个特殊情况：每个接受者都接受了其中一个值，但是没有任何一个值被接受者中的“大多数”所接受。甚至只有两个提议的值，一旦它们各自被差不多一半的接受者所接受，此时即使只有一个接受者故障都可能使得无法确定该选定哪个提案&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>。&lt;/p>
&lt;p>结合&lt;code>P1&lt;/code>以及“只有被大多数接受者所接受的值才能被选中”的要求，可以发现隐含条件：必须允许接受者接受不止一个提案。我们使用对每个提案进行（自然）编号的方式来跟踪接受者可以接受的不同的提案，这样的话，每个提案都包含了一个提案编号以及对应的值。为了防止混淆，我们要求不同的提案必须要有不同的编号。至于怎么实现不同的编号则取决于实现的方案&lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>，这里我们只要做假设就好了。当一个带有某个值的提案被大多数的接受者接受了之后，这个值就算是被选定了。在这种场景下，我们可以说这个提案（以及它的值）已经被选定了。&lt;/p>
&lt;p>我们可以允许多个提案被选定，但是必须保证所有被选定的提案拥有一样的值。结合提案编号归纳推理，只要保证以下条件就够了：&lt;/p>
&lt;pre tabindex="0">&lt;code>P2. 如果一个拥有值 v 的提案被选定，则每一个（比这个提案）更高编号且被选定的提案也都拥有值 v
&lt;/code>&lt;/pre>&lt;p>由于（提案）编号是完全有序的，条件 P2 保证了至关重要的安全性属性：只有一个值被选定。&lt;/p>
&lt;p>为了被选定，一个提案必须被至少一个接受者所接受。于是，我们通过满足以下条件来满足 P2：&lt;/p>
&lt;pre tabindex="0">&lt;code>P2a. 如果一个拥有值 v 的提案被选定，则每一个（比这个提案）更高编号且被任意一个接受者接受的提案也都拥有值 v
&lt;/code>&lt;/pre>&lt;p>我们仍需坚持 P1 以保证某个提案能被选定。（并且）因为消息通信是异步的，一个提案可能会被某个从来没有收到过任何提案的特殊接受者 &lt;em>c&lt;/em> 所接受。设想一个新的提议者“醒来”并且提议了一个更高编号且值不同的提案的场景。P1要求 &lt;em>c&lt;/em> 不得不接受这个提案，但这又会打破 P2a 的条件。为了同时满足 P1 和 P2a，需要对 P2a 做进一步加强：&lt;/p>
&lt;pre tabindex="0">&lt;code>P2b. 如果一个拥有值 v 的提案被选定，则每一个（比这个提案）更高编号且被任意一个提议者提议的提案也都拥有值 v
&lt;/code>&lt;/pre>&lt;p>由于只有被提议者提议的提案，才可以被接受者接受，所以 P2b 隐含了 P2a，也进一步隐含了 P2。&lt;/p>
&lt;p>为了发现如何满足 P2b，我们考虑如何证明它成立。我们先假设某个编号为&lt;em>m&lt;/em>，且值为 &lt;em>v&lt;/em> 的提案已经被选定，然后证明任何编号为 &lt;em>n&lt;/em> （&lt;em>n&lt;/em> &amp;gt; &lt;em>m&lt;/em>）的提案也都拥有值 &lt;em>v&lt;/em>。我们可以通过对 &lt;em>n&lt;/em> 采用数学归纳法&lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup>以使证明过程更轻松，于是在以下额外的假设下可证明编号为 &lt;em>n&lt;/em> 的提案拥有值 &lt;em>v&lt;/em>：&lt;/p>
&lt;blockquote>
&lt;p>归纳假设：每一个编号在 &lt;em>m&lt;/em>..(&lt;em>n-1&lt;/em>) 之间的提案都拥有值 &lt;em>v&lt;/em>，这里的 &lt;em>i..j&lt;/em> 的记法代表从 &lt;em>i&lt;/em> 到 &lt;em>j&lt;/em> 的一组编号。&lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>&lt;/p>
&lt;/blockquote>
&lt;blockquote>
&lt;p>集合 &lt;em>C&lt;/em> 里的每个接受者都接受了编号在 &lt;em>m&lt;/em>..(&lt;em>n-1&lt;/em>) 之间的一个提案&lt;sup id="fnref:12">&lt;a href="#fn:12" class="footnote-ref" role="doc-noteref">12&lt;/a>&lt;/sup>，并且被任何一个接受者所接受的每一个编号在 &lt;em>m&lt;/em>..(&lt;em>n-1&lt;/em>) 之间的提案都拥有值 v。&lt;/p>
&lt;/blockquote>
&lt;p>由于任意一个由大多数接受者组成的集合 &lt;em>S&lt;/em> 都必然包含集合 &lt;em>C&lt;/em> 的至少一个元素，我们可以通过维护以下不变性以保证编号为 &lt;em>n&lt;/em> 的提案拥有值 &lt;em>v&lt;/em>：&lt;/p>
&lt;pre tabindex="0">&lt;code>P2c. 对于任意的 v 和 n，如果一个编号为 n 且拥有值 v 的提案被提议，则存在一个由大多数接受者组成的集合 S 满足这里其中一个条件：（a）集合 S 里没有接受者接受了任何一个编号小于 n 的提案；或者是：（b）v 是集合 S 中的接受者已经接受过的所有编号小于 n 的提案中编号最高的提案的值。
&lt;/code>&lt;/pre>&lt;p>因此我们可以通过维护 P2c 的不变性来满足 P2b 的条件。&lt;/p>
&lt;p>为了维护 P2c 的不变性，想要提议编号为 &lt;em>n&lt;/em> 的提案的提议者必须获知编号小于 &lt;em>n&lt;/em> 的最大编号的提案，如果存在这样的提案的话，那它肯定是已经或者即将被大多数接受者所接受的提案。获知已经被接受的提案是足够简单的，但是预测未来哪些（提案会被）接受则是困难的。与其尝试去预测未来，不如让提议者通过获取一个**“将不会存在任何一个这样的接受”**的承诺来控制这个过程。换句话说，提议者请求接受者们不再接受任何编号比 &lt;em>n&lt;/em> 小的提案。这就引出了以下用于提议过程的算法：&lt;/p>
&lt;ol>
&lt;li>一个提议者选择一个新的提案编号 &lt;em>n&lt;/em>，然后给由某些接受者组成的集合中的每一个成员发送一个请求，要求它响应以下信息：
a. 一个承诺：不再接受任何一个编号比 *n * 小的提案，并且
b. 如果它已经有接受过提案的话，则还要返回它已经接受过的编号比 &lt;em>n&lt;/em> 小的最大编号的提案&lt;sup id="fnref:13">&lt;a href="#fn:13" class="footnote-ref" role="doc-noteref">13&lt;/a>&lt;/sup>
我把这样一个请求称之为对编号 &lt;em>n&lt;/em> 的 &lt;em>prepare&lt;/em> 请求。&lt;/li>
&lt;li>如果提议者从大多数的接受者成功收到期待的响应，则它可以接着提议一个编号为 &lt;em>n&lt;/em> 且值为 &lt;em>v&lt;/em> 的提案，这里 &lt;em>v&lt;/em> 就是它从1b 中收到的响应里最大编号的提案的值，如果所有响应都表明没有接受过任何提案，则提议者可以自由选择一个值。
提议者通过向一组接受者发送一个请求来提议提案。（这里的这组接受者并不需要和响应 &lt;em>request&lt;/em> 请求的接受者一致）。让我们把这个请求称之为 &lt;em>accept&lt;/em> 请求。&lt;/li>
&lt;/ol>
&lt;p>前面这些内容描述了提议者的算法，但是对于接受者而言又该是怎样子的呢？它可以接收来自提议者的两种请求：&lt;em>prepare&lt;/em> 请求和 &lt;em>accept&lt;/em> 请求。接受者可以忽略任何请求而不影响安全性。所以，我们需要讨论只在哪些情况下它可以响应请求。它总会响应 &lt;em>prepare&lt;/em> 请求；它也可以响应 &lt;em>accept&lt;/em> 请求，接受提案，只要它（事先）没有承诺不这样做。换句话说：&lt;/p>
&lt;pre tabindex="0">&lt;code>P1a. 接受者可以接受编号为 n 的提案，只要它没有响应过编号大于 n 的 prepare 请求
&lt;/code>&lt;/pre>&lt;p>可见 P1a 包含了 P1。&lt;/p>
&lt;p>我们现在已经得到了一个足以满足安全性属性的用于选定值的完整算法——在假设提案号唯一的基础上。最终的算法还需要通过额外的一点优化来得到。&lt;/p>
&lt;p>设想一个接受者收到了一个编号为 &lt;em>n&lt;/em> 的 &lt;em>prepare&lt;/em> 请求，但是它已经响应过一个编号比 &lt;em>n&lt;/em> 大的 &lt;em>prepare&lt;/em> 请求，因此也就承诺了不再接受任何编号为 &lt;em>n&lt;/em> 的新的提案。于是接受者没有理由要去响应这个新的 &lt;em>prepare&lt;/em> 请求，因为它并不会考虑接受编号为 &lt;em>n&lt;/em> 的提案，也就是提议者想要提议的提案。所以我们让接受者直接忽略这样一个 &lt;em>prepare&lt;/em> 请求。我们也让接受者直接忽略它已经接受的提案的 &lt;em>prepare&lt;/em> 请求。&lt;/p>
&lt;p>加上这个优化，接受者只需要记录它已经接受过的最高编号的提案以及它已经响应过的最高编号的 &lt;em>prepare&lt;/em> 请求的编号即可。因为无论失败与否，P2c 都必须保持不变，所以接受者必须能够记录这些信息，哪怕它可能崩溃，以及重启。注意提议者总是可以放弃某个提案并且装作什么都没有发生过——只要提议者不会尝试用相同的编号提议另一个提案。&lt;/p>
&lt;p>将提议者和接受者的行为都放在一起，我们可以看到这个算法的操作可以分为以下两个阶段：&lt;/p>
&lt;pre tabindex="0">&lt;code>阶段 1：
（a）提议者选择一个提案编号 n，向“大多数”接受者发送一个带有编号 n 的 prepare 请求；
（b）如果接受者收到一个编号为 n 的 prepare 请求，且 n 比它已经响应过的任何一个 prepare 请求的编号都大，则它会向这个请求回复响应，内容包括：一个不再接受任何编号小于 n 的提案的承诺，以及它已经接受过的最大编号的提案（假如有的话）。
阶段 2：
（a）如果提议者从“大多数”接受者收到了对它前面发出的 prepare 请求的响应，它就会接着给那每一个接受者发送一个针对编号为 n 且值为 v 的提案的 accept 请求，而 v 就是它所收到的响应中最大编号的提案的值，或者是它在所有响应都表明没有接受过任何提案的前提下自由选择的值 v；
（b）如果接受者收到了一个针对编号为 n 的提案的 accept 请求，它就会接受这个请求，除非它之前已经响应过编号大于 n 的 request 请求。
&lt;/code>&lt;/pre>&lt;p>提议者可以提议多个提案，只要它在每一个提案中都遵循上面的算法。它也可以在协议中间的任何时候丢弃提案。（正确性还会被保持，哪怕是对废弃提案的请求或者响应可能在提案被丢弃很久之后才到达目的地）。在某些提议者已经开始尝试提议更高编号的提案的情况下，（尽早）放弃（当前较低编号的）提案或许是一个好的主意。所以，如果接受者由于它自身已经收到了更高编号的 &lt;em>prepare&lt;/em> 请求而选择忽略（当前的）&lt;em>prepare&lt;/em> 或者 &lt;em>accept&lt;/em> 请求，那它应该通知提议者，提议者应该在收到通知后放弃提案。总体而言，这是一个不会影响正确性的性能优化。&lt;/p>
&lt;h4 id="23-获知选定的值">2.3 获知选定的值&lt;/h4>
&lt;p>为了获知值已被选定，学习者必须找出某个已经被大多数接受者接受的提案。最显而易见的算法就是让每一个接受者一旦接受了提案，就响应给所有学习者，并给它们发送接受了的提案信息。这种方法允许学习者们尽可能快地找出被选定的值，但这种方法也要求每个接受者要响应每个学习者——响应的数量等于接受者数量和学习者数量的乘积。&lt;/p>
&lt;p>没有拜占庭式错误的这样一个假设使得一个学习者可以很容易地通过其他的学习者来获知某个值已被接受的事实。我们可以让接受者将它们的接受事件响应给某个特定的学习者，这个特定的学习者要负责在每次一个值被选定之后通知其他的多个学习者。这种方法要求所有的学习者花费额外一轮的时间用于获知被选定的值，也降低了可靠性，因为那个特定的学习者可能会故障。但是这个方法要求的响应数量只等于接受者的数量和学习者的数量之和。&lt;/p>
&lt;p>更一般的，接受者可以将它们的接受事件响应给由多个特定的学习者组成的某个集合，集合中的每个学习者都会在每次一个值被选定之后通知所有的学习者。使用这样一个较大的特定的学习者组成的集合可以在更大的通信复杂度上提供更大的可靠性。&lt;/p>
&lt;p>由于消息丢失，值可能在学习者无法发现的情况下被选定。学习者可以询问接受者：现在已经接受了什么提案？但是接受者的失效可能导致不可能知道是否有一个大多数的（接受者）已经接受了某个特定的提案。在那种场景下，学习者只能在一个新的提案被选定的情况下才能找出哪个值被选定了。如果学习者需要知道一个值是否已经被选定，它可以让提议者使用上面描述的算法提议一个提案即可。&lt;/p>
&lt;h4 id="24-可进行性">2.4 可进行性&lt;/h4>
&lt;p>构建这样一个场景是容易的：两个提议者相继提议一系列递增编号的提案，但是没有哪一个提案能被选定。提议者 &lt;em>p&lt;/em> 完成了编号 &lt;em>n1&lt;/em> 的提案的阶段1，接着另一个提议者 &lt;em>q&lt;/em> 也完成了编号 &lt;em>n2&lt;/em>（&lt;em>n2 &amp;gt; n1&lt;/em>）的提案的阶段1.由于接受者已经承诺不会再接受任何编号小于 &lt;em>n2&lt;/em> 的新提案，所以提议者 &lt;em>p&lt;/em> 在阶段2为提案 &lt;em>n1&lt;/em> 发送的 &lt;em>accept&lt;/em> 请求会被忽略。所以，提议者 &lt;em>p&lt;/em> 又接着开始并且完成了一个新的提案 &lt;em>n3&lt;/em>（&lt;em>n3 &amp;gt; n2&lt;/em>）的阶段1，导致提案 &lt;em>q&lt;/em> 的阶段2的 &lt;em>accept&lt;/em> 请求也被忽略了，以此类推……&lt;/p>
&lt;p>为了保证（过程）可进行，一个特定的提议者必须被选为唯一一个提议提案的。如果这个特定的提议者可以成功地和大多数接受者通信，并且它使用了编号比任何已经使用的编号大的提案，那么它将会成功完成提议，也就是说，提案会被接受。通过在发现某个请求已经使用了更高的提案编号的情况下主动放弃提案然后重试（阶段1），这个特定的提议者终将能够选到一个足够高的提案编号。&lt;/p>
&lt;p>如果系统有足够多的组件（提议者、接受者以及通信网络）正常工作，那么就可以通过选举一个单一的特定的提议者来实现活性。Fischer, Lynch 和 Patterson 的著名（实验）结果指出：选举一个提议者的可靠算法必须使用随机性或者实时性——举例来说，使用超时机制。无论如何，不管选举成功或者失败，安全性都是可以保证的。&lt;/p>
&lt;h4 id="25-实现">2.5 实现&lt;/h4>
&lt;p>Paxos 算法假设了一个多进程组成的网络。在它的一致性算法里，每个进程同时扮演了提议者、接受者和学习者。这个算法也会选定一个 leader，由它同时扮演特定的提议者以及特定的学习者。Paxos 一致性算法正是上面描述的算法，其中请求和响应都作为普通消息发送。（响应的消息都会用对应的提案的编号做标记，以防混淆。）需要持久化存储器在故障时发挥作用，用于维护接受者必须记住的信息。接受者需要在真正发出响应之前在持久化存储上记录它计划的响应。&lt;/p>
&lt;p>剩下的就是描述一种能够保证不同的提案不会使用相同的编号提议的机制。只要不同的提议者从不相交的编号集合中选择编号，这两个不同的提议者提议的提案就一定不会拥有相同的编号。每个提议者在稳定的存储上记录各自已经尝试提议的最高编号的提案，然后使用一个比它已经用过的编号更高的提案编号再次开始阶段1的过程。&lt;/p>
&lt;h3 id="3-实现一个状态机">3 实现一个状态机&lt;/h3>
&lt;p>实现分布式系统的一种简单方式是作为向中央服务器发出命令的客户端的集合。可以将服务器描述为一个按照时序执行客户端命令的确定状态机。这个状态机拥有一个当前的状态，它通过接受一个命令作为输入来执行一个步骤，然后产生一个相应的输出以及一个新的状态。举个例子：一个分布式的银行系统的客户端可能是出纳员，而状态机的状态则由所有用户的账号余额组成。一个取款操作可以通过运行一个状态机命令来完成：这个命令当且仅当余额大于取款数量的时候才可以扣减账户余额，并生成新旧余额作为输出。&lt;/p>
&lt;p>使用单个中央服务器的实现方案会随着服务器的崩溃而失效。于是，我们想到了可以使用一组服务器，每个服务器彼此独立地实现同样的状态机。由于状态机是确定的，所以如果所有服务器都执行了相同的一系列命令，那么所有服务器都将会产生同样的一系列状态以及输出。一个发出命令的客户端则可以任意采用一台服务器生成的输出。&lt;/p>
&lt;p>为了保证所有服务器运行相同的一系列状态机命令，我们（需要）实现 Paxos 一致性算法的一系列独立的实例，第 &lt;em>i&lt;/em> 个选定的值就是序列中的第 &lt;em>i&lt;/em> 个状态机命令。每一个服务器都在每一个实例中扮演这个算法的所有角色（提议者、接受者和学习者）。就现在而言，我假设服务器的集合是固定的，所以这个一致性算法的所有实例使用相同的一群代理。&lt;/p>
&lt;p>在正常操作中，一个单独的服务器被选举为了 leader，由它在这个一致性算法的所有实例中扮演特定的提议者（只有它会尝试提议提案）。（多个）客户端发送命令到 leader，leader 决定每个命令的时序。假如 leader 决定某条客户端命令应该是第 135 个命令，那么它就会尝试通过这个一致性算法的第135个实例来提议选定一个提案，命令本身就是这个提案的值。这个过程通常会顺利完成。但它也可能因为故障而失败，或者因为有另一个服务器认为它自己才是 leader 并且它认为第 135 个命令应该另有他值。但是这个一致性算法确保第 135 位上最多只有一个命令能够被选定。&lt;/p>
&lt;p>在 Paxos 一致性算法里，这个方法的效率的关键在于，被提议的值要到阶段2才会被选定。回想一下，在完成提议者的算法的阶段1之后，要么要提议的值已经确定下来，要么提议者可以自由提议任何值。&lt;/p>
&lt;p>我现在将要描述 Paxos 状态机的实现是如何在正常操作下发挥作用的。稍后的话，我也将会讨论我们可能会遇到什么问题。我考虑的是在前一个 leader 刚发生故障而新的 leader 已经被选举出来的时候，会有什么事情发生。（系统启动是一个特殊场景，这个时候还没有任何命令被提议）&lt;/p>
&lt;p>这个新的 leader 也是这个一致性算法的所有实例中的学习者，它应该知道大多数已经被选定的命令。假设它知道 1-134、138 以及 139 号命令，也就是一致性算法的 1-134、138 以及 139 号实例的值。（我们稍后将会看到命令序列中的这样一个空缺是如何产生的。）然后它执行实例135-137以及所有大于139的实例的阶段1，假设这些执行的结果只确定了实例 135 和 140 中提议的值，但是其他实例中没有提议值的约束&lt;sup id="fnref:14">&lt;a href="#fn:14" class="footnote-ref" role="doc-noteref">14&lt;/a>&lt;/sup>。leader 执行实例 135 和 140 的阶段2，并因此可以选定 135 和 140 号命令。&lt;/p>
&lt;p>leader 自身就像其他向 leader 学习 leader 所知道的所有命令的别的服务器一样，现在可以运行命令 1-135。因为136号和137号命令还没有选定，所以它还不能运行 138-140 号命令，尽管它知道 138-140 号命令。于是，我们让它通过提议将一个特殊的不会导致状态机状态切换的“no-op”命令作为第136号和137号命令（它可以通过执行一致性算法的 136 号和 137 号实例的阶段 2 来完成），以此快速填补空缺。一旦这些 no-op 命令被选定，那 138-140 号命令就可以被执行了。&lt;/p>
&lt;p>现在从 1 到 140 的命令都被选定了。 leader 完成了一致性算法中大于 140 的所有实例的阶段 1，它可以在这些（完成阶段1的）实例的阶段2中自由地提议任意的值。它给某个客户端请求的下一个命令分配了 141 号命令，把它作为这个一致性算法的 141 号实例的阶段2提议的值。它接着将它收到的下一个客户端命令提议为第 142 号命令，以此类推。&lt;/p>
&lt;p>leader 可以在它获知它提议的 141 号命令已被选定之前提议 142 号命令。它在提议第 141 号命令中发送的所有消息有可能丢失，而第 142 号命令会在其他服务器获知到 leader 提议的第 141 号命令之前被选定。当 leader 在实例 141 中没有收到对它的阶段2的预期响应时，它将会重发这些消息。如果一切顺利，它提议的命令会被选定。无论如何，它还是有可能在前面有失败，在选定的命令的序列上留下一段空缺。一般来说，假设一个 leader 可以提前获得 &lt;em>α&lt;/em> 个命令——也就意味着，它可以在 1 到 i 号命令被选定之后提议第 &lt;em>i&lt;/em> + 1 到 &lt;em>i&lt;/em> + &lt;em>α&lt;/em> 号命令。一个多达 &lt;em>α&lt;/em> - 1 个命令的空缺可能随之形成。&lt;/p>
&lt;p>一个新的被选定的 leader 执行一致性算法中的无限多的实例的阶段1——如果是在上面的场景中，就是实例 135-137，以及所有大于139的实例。让所有实例使用一样的提案编号，它可以通过向其他的服务器发送一个合理的短消息来实现这一点。在阶段1中，接受者当且仅当它已经收到了某个提议者的阶段2的消息的时候，它才会响应不止1个简单的OK。（在这个场景里，这是仅针对实例 135 和 140 的例子。）所以，一个（扮演接受者的）服务器可以用一个单一且合理短的消息回应所有的实例。因此，执行阶段1的无穷多个实例不会带来任何问题。&lt;/p>
&lt;p>由于 leader 的故障以及新 leader 的选举理应很少发生，因此执行状态机命令——对命令/值达成一致的过程的有效成本，仅为运行这个一致性算法的阶段2的成本。可以看出，Paxos 一致性算法的第2阶段在存在故障的情况下，其达成协议的可能代价是所有算法中最小的。于是，Paxos 算法本质上是最优的。&lt;/p>
&lt;p>对于系统正常操作的讨论中假设了总是只有一个单独的 Leader，排除了现任 Leader 故障和新任 Leader 选举之间的一小段时间。在异常的情况下，Leader 选举可能失败。如果没有服务器担任 Leader，也就没有新的认领会被提议。如果多个服务器认为它们自己都是 Leader，则它们都可以在这个一致性算法的同一个实例上提议值，这可能导致没有值能够被选定。尽管如此，安全性还是保证的——两个不同的服务器将不会对被选定的第 &lt;em>i&lt;/em> 个状态机命令持有不同意见。单个 Leader 的选举只有在确保（整个过程）可进行的时候才需要。&lt;/p>
&lt;p>如果服务器的集合可以变化，那必然存在某些方式用于决定哪些服务器实现这个一致性算法的哪些实例。最简单的方式就是通过状态机自己。当前的服务器集合可以成为状态的一部分，并且可以通过普通的状态机命令修改。通过让运行第 &lt;em>i&lt;/em> 个状态机命令后所指明的服务器的集合来运行这个一致性算法的第 &lt;em>i&lt;/em> + &lt;em>α&lt;/em> 号实例，我们可以允许 Leader 提前获得 &lt;em>α&lt;/em> 个命令。这允许了一个任意复杂的支持重配置的算法的简单实现。&lt;/p>
&lt;h2 id="原论文参考文献">原论文参考文献&lt;/h2>
&lt;p>[1]  Michael J. Fischer, Nancy Lynch, and Michael S. Paterson. Impossibility of distributed consensus with one faulty process. Journal of the ACM, 32(2):374–382, April 1985.
[2]  Idit Keidar and Sergio Rajsbaum. On the cost of fault-tolerant consensus when there are no faults—a tutorial. TechnicalReport MIT-LCS-TR-821, Laboratory for Computer Science, Massachusetts Institute Technology, Cambridge, MA, 02139, May 2001. also published in SIGACT News 32(2) (June 2001).
[3]  Leslie Lamport. The implementation of reliable distributed multiprocess systems. Computer Networks, 2:95–114, 1978.
[4]  Leslie Lamport. Time, clocks, and the ordering of events in a distributed system. Communications of the ACM, 21(7):558–565, July 1978. &lt;br>
[5]  Leslie Lamport. The part-time parliament. ACM Transactions on Com- puter Systems, 16(2):133–169, May 1998.&lt;/p>
&lt;h2 id="翻译过程参考资料">翻译过程参考资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.microsoft.com/en-us/research/publication/paxos-made-simple/">Paxos Made Simple&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Paxos_%28computer_science%29">Wikipedia: Paxos (Computer Science)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cstheory.stackexchange.com/questions/33504/paxos-made-simple-invariant-p2c">StackExchange Discussion: Paxos made simple, invariant P2c&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://cstheory.stackexchange.com/questions/27391/the-proof-of-p2b-in-paxos-made-simple">StackExchange Discussion: The proof of P2b in Paxos made simple&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iteblog.com/archives/2337.html">Paxos Made Simple 译文&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6">维基百科: 状态机复制&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.doc.ic.ac.uk/~jnm/book/firstbook/pdf/ch7.pdf">Safety &amp;amp; Liveness Properties&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://dockone.io/article/967">彻底厘清真实世界中的分布式系统&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://baike.baidu.com/item/%E7%AC%AC%E4%BA%8C%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95">百度百科：第二归纳法&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="辅助翻译工具">辅助翻译工具&lt;/h2>
&lt;ul>
&lt;li>有道词典&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>让人摸不着头脑：原文中的词是“Greek”，我个人猜想这里其实是一语双关，一个意思是指 Leslie Lamport 第一次阐述 Paxos 算法的论文《The Part-Time Parliament》里用了古希腊的故事情节来阐述算法思路，另一个意思表达令人摸不着头脑，可参考有道词典双语例句：&lt;em>&lt;!-- raw HTML omitted -->&lt;strong>Reporter&lt;/strong>: The new version will promote &amp;ldquo;The Painted&amp;rdquo; as &amp;ldquo;Eastern magic of the new&amp;rdquo;, is not it a bit &lt;strong>too&lt;/strong> exaggerated and &lt;strong>Greek&lt;/strong>?Positioning yourself how this movie? &lt;!-- raw HTML omitted -->&lt;strong>记者&lt;/strong>：宣传方将新版《画皮》定位为“东方新魔幻”，是不是有点儿太夸张并且令人摸不着头脑?你自己怎么定位这部电影?。&lt;/em>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>synod 算法：论文作者在《The Part-Time Parliament》中对其算法的命名为 synod。&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>来自维基百科的“状态机复制”词条：&lt;em>多个相同状态机的拷贝，从同样的“初始”状态开始，经历了相同的输入序列后，会达到同样的状态，并且输出同样的结果。&lt;/em>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>原文中为单词&lt;code>values&lt;/code>，翻译过程中结合上下文理解，认为加上“可能不同的”会更贴合情境。&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>原文内容为“A process never learns that a value has been chosen unless it actually has been.”&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>关于安全性属性以及活性属性，可查阅“本文参考资料”一节的“Safety &amp;amp; Liveness Properties”&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>原文单词“corrupted”，直译应为“损坏”，但是这里结合个人理解，译作“篡改”更贴切，意为不会发生拜占庭式的问题&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>由于所谓的大多数等于 N/2+1，所以如果有一个接受者故障，可能导致两边提议都只能得到 N/2 票，都无法行成大多数。&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9">
&lt;p>一种常见且可行的方案是使用时间戳+机器ID的形式，但是实际上论文中并没有对提案编号的生成做具体的规定，只要保证编号递增且唯一即可，所以实际的实现中可以有多种多样的实现方式&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10">
&lt;p>论文作者采用了数学上的第二归纳法，亦称“强归纳法”&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11">
&lt;p>结合后面的推理结论，这里是一个闭区间的标记法，即&lt;code>i..j&lt;/code>对应数学记法 &lt;code>[i, j]&lt;/code>。
由于编号为 &lt;em>m&lt;/em> 的提案已经被选定，那就必然存在一个由“大多数”接受者组成的集合 &lt;em>C&lt;/em>，且集合里的每一个接受者都接受了这个提案。结合这个（推理）以及前面的归纳假设，&lt;em>m&lt;/em> 被选定的假设则意味着：&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:12">
&lt;p>至少接受了 &lt;em>m&lt;/em> 号提案，所以这个结论是成立的&amp;#160;&lt;a href="#fnref:12" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:13">
&lt;p>记得一个“提案”始终意味着：一个编号加上一个提案的值。&amp;#160;&lt;a href="#fnref:13" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:14">
&lt;p>回想基本的 Paxos 的两个阶段中的阶段一，只要当前实例中，还没有任何提案被接受者接受过，则提议者可以提出任意值。这种情况下，意味着原来旧的 Leader 还没有来得及开始实例 136 和 137 的阶段二。&amp;#160;&lt;a href="#fnref:14" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>谨防猴子补丁以及Python中排查技巧</title><link>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</link><pubDate>Sun, 22 Sep 2019 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</guid><description>&lt;h3 id="背景">背景&lt;/h3>
&lt;p>前两天晚上线上系统突发故障，在立马打开线上错误日志之后，却只能得到一堆毫无意义的程序调用栈(traceback)的输出，于是团队成员陷入漫长而又抓瞎的问题排查过程中。问题很幸运地得到了解决，但是我一直想不明白为什么日志里打印的调用栈毫无意义，按照经验，它应该打印的是异常产生过程中的调用栈才是。在经过后续的源码分析和排查之后，我才发现其实是因为项目中一个老旧的代码使用了&lt;strong>猴子补丁&lt;/strong>导致，这也是这篇文章想要讨论的内容。&lt;/p>
&lt;h3 id="什么是猴子补丁">什么是猴子补丁&lt;/h3>
&lt;p>猴子补丁是一种用来在运行时修改（增加、变更、删除等）系统软件行为的编程方式。在动态语言里有广泛的猴子补丁应用的影子，比如 Ruby 的打开类的特性支持运行时扩展类的定义甚至替换方法的实现，Python 的方法或者函数由于可以在运行时进行替换而使得猴子补丁的应用非常方便，其他像 JavaScript 语言同样可以应用猴子补丁。&lt;/p>
&lt;h4 id="猴子补丁是把双刃剑">猴子补丁是把双刃剑&lt;/h4>
&lt;p>猴子补丁以其灵活性，可以实现补丁代码和应用代码的完全分离，同时使得应用代码在调用方式上保持调用方式始终不变。
从应用代码的角度来看，它调用的就是某个模块的原始定义的方法或者函数；而从被调用的方法或者函数的角度来看，猴子补丁的存在对它是透明的存在，以下展示一个 Python 语言的 Demo：&lt;/p>
&lt;p>我们从一个极简例子开始，向这个美好的世界问好：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="font-style:italic">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> __name__ == &lt;span style="font-style:italic">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greet()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如执行以上脚本，得到的结果是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ python demo.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个很简单，接下来假如打一个猴子补丁：我们扩充原来的 &lt;code>greet&lt;/code> 的行为，现在除了打印信息，还要打印下当前的时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">datetime&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> datetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="font-style:italic">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># monkey patch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>original_greet = greet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet_with_time():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_greet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(datetime.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>greet = greet_with_time &lt;span style="font-style:italic"># replace the implementation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># monkey patch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> __name__ == &lt;span style="font-style:italic">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greet() &lt;span style="font-style:italic"># 这里的调用和原来没有变化&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行它，得到的结果是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ python demo.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>2019-09-21 23:40:42.575782
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们得到了预期的结果！&lt;br>
从代码分析，我们添加了一个新的函数 &lt;code>greet_with_time&lt;/code>，其会调用原来的 &lt;code>greet&lt;/code> 函数，然后打印当前时间，最后将 &lt;code>greet&lt;/code> 函数通过将函数赋值给变量的方式完成对 &lt;code>greet&lt;/code> 函数的替换。而对于最后的 &lt;code>greet&lt;/code> 函数的调用，却无需任何改动，以此达到了同样还是调用 &lt;code>greet&lt;/code> 函数，行为却大相径庭的目的。&lt;br>
上面的 demo 只是限于篇幅简化了代码，真实项目里的猴子补丁代码总是在另外的模块或者文件里。想象在一个复杂的大型工程里，如果你的代码里猴子补丁泛滥，可想对于系统的行为分析以及问题排查，将是一种灾难性的挑战。&lt;/p>
&lt;p>现在对猴子补丁有了一定的了解之后，我们再来看看我在实际项目中遇到的例子。&lt;/p>
&lt;h3 id="一堆毫无意义的堆栈信息">一堆毫无意义的堆栈信息&lt;/h3>
&lt;p>我在本地重现了我开头提到的我们所遇到的异常，以下是和线上环境一致的堆栈信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-plain" data-lang="plain">&lt;span style="display:flex;">&lt;span>2019-09-19 17:30:11.103|CRITICAL|138:140147476383488|log.py:282|log.log|Task command.celery.crontab_task.some_task[538ddb72-89b0-45fe-811e-107202dc665b] INTERNAL ERROR: AttributeError(&amp;#34;&amp;#39;long&amp;#39; object has no attribute &amp;#39;insert&amp;#39;&amp;#34;,)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Traceback (most recent call last):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/bin/celery&amp;#34;, line 10, in &amp;lt;module&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sys.exit(main())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/__main__.py&amp;#34;, line 30, in main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...... 限于篇幅，这里省略很多无意义的内容
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/worker/job.py&amp;#34;, line 384, in on_success
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return self.on_failure(ret_value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/worker/job.py&amp;#34;, line 443, in on_failure
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self._log_error(exc_info, send_failed_event=send_failed_event)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/worker/job.py&amp;#34;, line 511, in _log_error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &amp;#39;internal&amp;#39;: internal}})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/utils/log.py&amp;#34;, line 282, in log
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return Logger.log(self, *args, **kwargs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>None
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从这个堆栈信息看，它打印的实际上是调用了 &lt;code>Logger.log&lt;/code> 函数的堆栈，其中根本没有任何代码看到有 &lt;code>.insert&lt;/code> 相关字眼，其与 &lt;code>AttributeError(&amp;quot;'long' object has no attribute 'insert'&amp;quot;,)&lt;/code> 根本毫无关系，这样的堆栈信息，有和没有基本一个样。于是乎，我接着通过编辑器通过源码进行了更多的探索。&lt;/p>
&lt;p>首先还是借助上面的堆栈去分析到底哪里出了问题，所以我先看了 &lt;code>celery/worker/job.py:504-511&lt;/code> 处的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> context = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;hostname&amp;#39;&lt;/span>: self.hostname,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;id&amp;#39;&lt;/span>: self.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;name&amp;#39;&lt;/span>: self.name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;exc&amp;#39;&lt;/span>: exception,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;traceback&amp;#39;&lt;/span>: traceback,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;args&amp;#39;&lt;/span>: sargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;kwargs&amp;#39;&lt;/span>: skwargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;description&amp;#39;&lt;/span>: description,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.log(severity, format.strip(), context,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exc_info=exc_info,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extra={&lt;span style="font-style:italic">&amp;#39;data&amp;#39;&lt;/span>: {&lt;span style="font-style:italic">&amp;#39;id&amp;#39;&lt;/span>: self.id,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;name&amp;#39;&lt;/span>: self.name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;args&amp;#39;&lt;/span>: sargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;kwargs&amp;#39;&lt;/span>: skwargs,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;hostname&amp;#39;&lt;/span>: self.hostname,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;internal&amp;#39;&lt;/span>: internal}})
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里调用了 &lt;code>logger.log&lt;/code> 方法（logger 的来源在 Celery 的代码里可分析，但是不是这篇文章的重点，故此不展开）并且通过 &lt;code>context&lt;/code> 对象传入了两个重要的信息：&lt;code>exception&lt;/code> 和 &lt;code>traceback&lt;/code>。在对 &lt;code>logger.log&lt;/code> 源码的进一步阅读中，我确认了这块&lt;strong>日志打印的核心依赖于对 &lt;code>traceback.print_exception&lt;/code> 函数的调用&lt;/strong>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> formatException(self, ei):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> Format and return the specified exception information as a string.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> This default implementation just uses
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> traceback.print_exception()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sio = io.StringIO()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tb = ei[2]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> traceback.print_exception(ei[0], ei[1], tb, &lt;span style="font-weight:bold">None&lt;/span>, sio)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>于是乎，我回到了 &lt;code>celery/worker/job.py:504-511&lt;/code> 处的代码，在 &lt;code>logger.log&lt;/code> 前面插入了两种打印错误堆栈信息的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># context = ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">################################################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-weight:bold">traceback&lt;/span> &lt;span style="font-weight:bold">as&lt;/span> &lt;span style="font-weight:bold">_traceback&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Method 1: like what logger.log does&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _traceback.print_exception(*exc_info)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Method 2: use `format_exception` instead&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>.join(_traceback.format_exception(*exc_info)))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">################################################################&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.log(....
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重新启动 celery 后，执行异步任务后，得到的第一种错误堆栈和前面我贴出来的堆栈信息是完全一致的，这个倒也好理解，毕竟这里的 &lt;code>print_exception&lt;/code> 函数的调用就是 &lt;code>logger.log&lt;/code> 里的核心实现。而 &lt;code>format_exception&lt;/code> 的调用给了我真正有意义的错误堆栈信息：&lt;/p>
&lt;pre tabindex="0">&lt;code>Traceback (most recent call last):
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/app/trace.py&amp;#34;, line 283, in trace_task
uuid, retval, SUCCESS, request=task_request,
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/backends/base.py&amp;#34;, line 271, in store_result
request=request, **kwargs)
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/backends/base.py&amp;#34;, line 505, in _store_result
self.set(self.get_key_for_task(task_id), self.encode(meta))
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/backends/redis.py&amp;#34;, line 161, in set
return self.ensure(self._set, (key, value), **retry_policy)
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/backends/redis.py&amp;#34;, line 150, in ensure
**retry_policy
File &amp;#34;/usr/local/lib/python2.7/dist-packages/kombu/utils/__init__.py&amp;#34;, line 246, in retry_over_time
return fun(*args, **kwargs)
File &amp;#34;/usr/local/lib/python2.7/dist-packages/celery/backends/redis.py&amp;#34;, line 170, in _set
pipe.execute()
File &amp;#34;/usr/local/lib/python2.7/dist-packages/redis/client.py&amp;#34;, line 2879, in execute
return execute(conn, stack, raise_on_error)
File &amp;#34;/usr/local/lib/python2.7/dist-packages/redis/client.py&amp;#34;, line 2785, in _execute_transaction
response.insert(i, e)
AttributeError: &amp;#39;long&amp;#39; object has no attribute &amp;#39;insert&amp;#39;
&lt;/code>&lt;/pre>&lt;p>好家伙，这下就清晰了，原来这个代码的异常真正出处是这里！&lt;br>
但是问题就来了，为什么&lt;code>print_exception&lt;/code>和 &lt;code>format_exception&lt;/code>给出的堆栈信息不一样呢？我充满疑问地去查找了官方文档，但是困惑更重了：&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>traceback.format_exception(etype, value, tb[, limit])&lt;/strong>
Format a stack trace and the exception information. The arguments have the same meaning as the corresponding arguments to print_exception(). The return value is a list of strings, each ending in a newline and some containing internal newlines. When these lines are concatenated and printed, exactly the same text is printed as does print_exception().&lt;/p>
&lt;/blockquote>
&lt;p>重点在最后一句，Python 官方文档说了，两个函数输出的错误堆栈是一样(exactly the same text)的！&lt;/p>
&lt;h3 id="揪出猴子补丁">揪出猴子补丁&lt;/h3>
&lt;p>其实，问题的真正排查过程耗费了我好多时间，我一直没有往猴子补丁上想，最后倒是在出门赴朋友的饭约的地铁上灵机一动，用手机翻看了公司 GitLab 上的项目代码，一下找到了元凶。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> _patch_print_exception():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-weight:bold">traceback&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> custom_print_exception(etype, value, tb, limit=&lt;span style="font-weight:bold">None&lt;/span>, file=&lt;span style="font-weight:bold">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exc_info = sys.exc_info()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = traceback.extract_stack()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ... omit other source codes &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> traceback.print_exception = custom_print_exception
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从补丁代码看，补丁直接覆盖了原版的代码，并且实现上也直接粗暴地无视了传入的几个异常信息参数！所以才会出现这么大的乌龙，出现毫无关系的异常堆栈信息！(╯‵□′)╯︵┻━┻&lt;/p>
&lt;h3 id="排查猴子补丁的技巧">排查猴子补丁的技巧&lt;/h3>
&lt;p>猴子补丁这类编程技巧固然会利弊共存，使用上必然需要额外慎重，但也并非需要敬而远之，重点是掌握必要的排查技巧，以下我针对这次的教训又去找下一些可能有帮助的方法：&lt;/p>
&lt;h4 id="1-通过函数或方法自身属性检查方法或者函数的信息">1. 通过函数或方法自身属性检查方法或者函数的信息&lt;/h4>
&lt;p>众所周知，Python 的所有对象都有一堆&lt;a href="https://docs.python.org/2/library/inspect.html#types-and-members">内置的属性&lt;/a>，函数也不例外，以我项目中的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># django shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [1]: traceback.print_exception.func_code
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[1]: &amp;lt;code object custom_print_exception at 0x109e9f030, file &lt;span style="font-style:italic">&amp;#34;/Users/boy/work_area/project/project-source/lib/common/logger.py&amp;#34;&lt;/span>, line 295&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>一看就知道，这个函数的真实代码其实就是项目中的补丁代码！&lt;/p>
&lt;h4 id="2-借助-inspect-包来检查">2. 借助 inspect 包来检查&lt;/h4>
&lt;p>Python 自身提供的工具包非常多，inspect 自然也是利器之一，其可以用来对几乎所有类型做运行时的检查，还是以我的实际例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># django shell&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [1]: &lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-weight:bold">inspect&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [2]: inspect.getfile(traceback.print_exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[2]: &lt;span style="font-style:italic">&amp;#39;/Users/boy/work_area/project/project-source/lib/common/logger.py&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [3]: inspect.getsource(traceback.print_exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[3]: &lt;span style="font-style:italic">&amp;#39;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\t&lt;/span>&lt;span style="font-style:italic">def custom_print_exception(etype, value, tb, limit=None, file=None): ......&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n&lt;/span>&lt;span style="font-style:italic">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>In [4]: print inspect.getsource(traceback.print_exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Out[4]: &lt;span style="font-weight:bold">def&lt;/span> custom_print_exception(etype, value, tb, limit=&lt;span style="font-weight:bold">None&lt;/span>, file=&lt;span style="font-weight:bold">None&lt;/span>):disable=redefined-builtin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> file &lt;span style="font-weight:bold">is&lt;/span> &lt;span style="font-weight:bold">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file = sys.stderr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exc_info = sys.exc_info()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack = traceback.extract_stack()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>总之，如果遇上代码行为与预期不符却又无法和官方文档或者官方源码对应，那么可能就是依赖的方法或者函数被打了猴子补丁，而最快速确认猴子补丁的方式，就是第一时间检查所调用的函数或者方法的实际定义，即应用上述方法即可！&lt;/p>
&lt;h4 id="题外话">题外话&lt;/h4>
&lt;p>做 Ruby 开发时，我也遇到过猴子补丁的陷阱，Ruby 里也有类似的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>file, line = A.new.method(&lt;span style="font-style:italic">:foo&lt;/span>).source_location
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>puts &lt;span style="font-style:italic">&amp;#34;Method foo is defined in &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>file&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">, line &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>line&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># =&amp;gt; &amp;#34;Method foo is defined in temp.rb, line 2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="参考链接">参考链接&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Monkey_patch">Wikipedia: Monkey patch&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.python.org/2/library/traceback.html#traceback.format_exception">Python&amp;rsquo;s official document: traceback.format_exception&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.python.org/2/library/inspect.html#types-and-members">Python&amp;rsquo;s official document: inspect&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/3393706/2547108">How can I get source code of a method dynamically and also which file is this method locate in&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Mac OS 环境 Rails 6.0 下 webpack-dev-server wrong version 问题解决方案</title><link>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</link><pubDate>Fri, 06 Sep 2019 15:18:30 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</guid><description>&lt;h3 id="错误信息">错误信息&lt;/h3>
&lt;p>昨天装上了 Ruby on Rails 6.0，满心欢喜初始化项目并且按照指引安装了 webpacker 之后，执行熟悉无比的 &lt;code>rails c&lt;/code> 命令，却给了一个报错：&lt;/p>
&lt;pre tabindex="0">&lt;code># 错误信息片段
yarn check v1.7.0
success Folder in sync.
Done in 0.15s.
yarn check v1.7.0
error &amp;#34;webpack-dev-server#yargs#cliui&amp;#34; is wrong version: expected &amp;#34;^4.0.0&amp;#34;, got &amp;#34;5.0.0&amp;#34;
error &amp;#34;webpack-dev-server#yargs#yargs-parser&amp;#34; is wrong version: expected &amp;#34;^11.1.1&amp;#34;, got &amp;#34;13.1.1&amp;#34;
error Found 2 errors.
info Visit https://yarnpkg.com/en/docs/cli/check for documentation about this command.
&lt;/code>&lt;/pre>&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>目前关于 Rails 6.0 相关的资料感觉不多，所幸找到了一篇日文版的帖子，成功解决了上边的问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ brew upgrade yarn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ yarn upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终问题解决，又能愉快地前进了！&lt;/p>
&lt;p>**注意：**我自己已经一年多没怎么开发 Rails 项目了，全栈开发那就更久远了。Rails 6.0 改动比较大，很多新的组件我自己也还没有来得及熟悉，所以这篇文章就先不做上面解决方案的原理分析了，仅为备忘，可能会有其他人遇到一样的问题。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/NaokiIshimura/items/8203f74f8dfd5f6b87a0">Rails6 開発時につまづきそうな webpacker, yarn 関係のエラーと解決方法&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>pymysql 开启调试模式</title><link>https://blog.hackerpie.com/posts/2019/enable-debug-mode-of-pymysql/</link><pubDate>Sun, 18 Aug 2019 18:32:01 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/enable-debug-mode-of-pymysql/</guid><description>&lt;p>今天在排查线上一个奇怪的数据库连接问题，所以打开了 pymysql 的源码在阅读，发现 pymysql 在其 &lt;code>connections&lt;/code> 模块里内置了一个 &lt;code>DEBUG&lt;/code> 变量用于控制是否开启调试模式，是的话，会将当前连接的操作以及报文内容都打印到控制台。&lt;/p>
&lt;h4 id="使用方法">使用方法&lt;/h4>
&lt;p>在你的服务器初始化代码里，加上对 &lt;code>DEBUG&lt;/code> 的设置，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-weight:bold">pymysql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pymysql.install_as_MySQLdb()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pymysql.connections.DEBUG = &lt;span style="font-weight:bold">True&lt;/span> &lt;span style="font-style:italic"># 这是我新加的一行&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启服务器后，访问相关接口，会看到标准输出里有类似下面的一些输出：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/pymysql-debug.png" alt="clipboard.png">
&lt;/p></description></item><item><title>django 快速启动数据库客户端程序</title><link>https://blog.hackerpie.com/posts/2019/quick-launch-database-client-in-django/</link><pubDate>Thu, 15 Aug 2019 08:18:30 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/quick-launch-database-client-in-django/</guid><description>&lt;p>实际工作经历中，免不了有时候需要连接数据库进行问题排查分析的场景，之前一直习惯通过 &lt;code>mysql -uxxx -hxxxx -P1234 ...&lt;/code> 这样的方式来启动命令行形式的 MySQL 数据库客户端程序，只是用起来比较麻烦，每次都要拷贝各个配置参数，还要记得不要在命令里显式打印密码。后来想起来在开发 Ruby on Rails 程序的时候，其提供了 &lt;code>rails dbconsole&lt;/code> 的命令，可以方便直接启动对应的数据库客户端命令行程序，联想到 Django 理论上也有，所以找到了 &lt;code>python manage.py dbshell&lt;/code> 这个命令，使用效果和自己手动敲 mysql 命令行是一样的，省去繁琐的参数设定步骤。&lt;/p>
&lt;h4 id="使用效果">使用效果&lt;/h4>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/dbshell.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="用法">用法&lt;/h4>
&lt;p>其用法可以直接查询命令行帮助文档：&lt;/p>
&lt;pre tabindex="0">&lt;code># python manage.py dbshell -h
Usage: manage.py dbshell [options]
Runs the command-line client for specified database, or the default database if none is provided.
Options:
-v VERBOSITY, --verbosity=VERBOSITY
Verbosity level; 0=minimal output, 1=normal output,
2=verbose output, 3=very verbose output
--settings=SETTINGS The Python path to a settings module, e.g.
&amp;#34;myproject.settings.main&amp;#34;. If this isn&amp;#39;t provided, the
DJANGO_SETTINGS_MODULE environment variable will be
used.
--pythonpath=PYTHONPATH
A directory to add to the Python path, e.g.
&amp;#34;/home/djangoprojects/myproject&amp;#34;.
--traceback Raise on exception
--database=DATABASE Nominates a database onto which to open a shell.
Defaults to the &amp;#34;default&amp;#34; database.
--version show program&amp;#39;s version number and exit
-h, --help show this help message and exit
&lt;/code>&lt;/pre></description></item><item><title>不严谨的不同语言下大 Excel 文件写入的性能比较</title><link>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</link><pubDate>Sat, 23 Mar 2019 21:11:06 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</guid><description>&lt;h3 id="背景">背景&lt;/h3>
&lt;p>去年因为线上系统需要导出大量数据（大概是 11 万行）到 Excel，代码是 Python 2.7 写的，除去数据库查询耗时，整个的 Excel 文件生成也还要耗费几十秒的时间，这听起来真是一个非常夸张的事情。后来为其更换了号称性能表现最好的 pyexcelerate 库，性能确实有提升，但是仍是差强人意的在小几十秒。&lt;/p>
&lt;p>昨天突发奇想，如果是换成其他语言，这个 excel 导出是否还需要这么长时间？于是经过一番试验之后，就有了今天的这篇文章。&lt;/p>
&lt;p>**特别声明：**试验只是为了感官上做个简单对比，测试结果采集数据只考虑了耗时，没有考虑资源消耗等情况，需要严谨的性能对比的读者，可以放弃阅读了。&lt;/p>
&lt;h3 id="测试内容">测试内容&lt;/h3>
&lt;p>使用不同的语言及其版本，测试各自完成包含 100,000 行 x 50 列单元格的 excel 文件的生成，对比其各自耗费时间，3次重复执行取其平均值后进行横向比较。&lt;/p>
&lt;h4 id="已经测试的语言及版本">已经测试的语言及版本&lt;/h4>
&lt;ul>
&lt;li>Ruby 2.6 + axlsx 2.0.1&lt;/li>
&lt;li>Python 2.7 + pyexcelerate 0.7.3&lt;/li>
&lt;li>Python 3.6 + pyexcelerate 0.7.3&lt;/li>
&lt;li>Go 1.10.1 + gooxml 0.8&lt;/li>
&lt;/ul>
&lt;h4 id="测试代码">测试代码&lt;/h4>
&lt;p>&lt;a href="https://github.com/Martin91/excel-writors-benchmark">https://github.com/Martin91/excel-writors-benchmark&lt;/a>&lt;/p>
&lt;h4 id="结果">结果&lt;/h4>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/benchmark-excel.png" alt="benchmark.png">
&lt;/p>
&lt;h4 id="结论">结论&lt;/h4>
&lt;p>就这个测试场景来说：&lt;/p>
&lt;ol>
&lt;li>Go 1.10.1 + gooxml 0.8 是最快的；&lt;/li>
&lt;li>同样是 pyexcelerate 0.7.3，Python 2.7 性能优于 Python 3.6;&lt;/li>
&lt;li>Ruby 2.6 + axlsx 2.0.1 表现最不给力，这里有个题外话，选择的 axlsx 本身并不是性能最好的 gem，只是流行度够高，Ruby 有一个专门针对性能优化后的 gem，但是因为知之甚少，没有采用。&lt;/li>
&lt;/ol></description></item><item><title>利用 Postman Chrome app 和 Chrome 浏览器共享网站 cookie</title><link>https://blog.hackerpie.com/posts/2019/share-cookies-between-chrome-and-postman/</link><pubDate>Mon, 14 Jan 2019 09:22:19 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/share-cookies-between-chrome-and-postman/</guid><description>&lt;h3 id="声明">声明&lt;/h3>
&lt;p>文章内容已过期，Postman 桌面版已实现本文末尾的缺憾，可直接阅读&lt;a href="https://blog.postman.com/introducing-interceptor-integration-for-native-postman-apps/">官方博客&lt;/a>。&lt;/p>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>作为一个Web工程师，最熟悉的日常工作莫过于后台接口开发与联调测试，而在接口测试上，大家最喜爱的工具清单里，必然少不了 Postman 这一利器。然而，有时接口测试需要准备好登录态，或者其他状态数据，而这些数据往往就存在浏览器 Cookie 里边。结合本文介绍的工具，便可以无缝在 Postman Chrome app （为什么强调是 Postman Chrome app，文章末尾会说明）和 Chrome 浏览器之间共享 Cookie，而这个共享过程对用户是透明的。&lt;/p>
&lt;h3 id="工具清单">工具清单&lt;/h3>
&lt;p>以下工具请自行安装，我只贴下官方的软件界面截图。&lt;/p>
&lt;ol>
&lt;li>Chrome 浏览器&lt;/li>
&lt;li>&lt;a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">Postman Chrome app&lt;/a>
&lt;img src="https://blog.hackerpie.com/images/posts/postman-app.png" alt="clipboard.png">
&lt;/li>
&lt;li>&lt;a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=en">Postman Interceptor&lt;/a>
&lt;img src="https://blog.hackerpie.com/images/posts/postman-interceptor.png" alt="clipboard.png">
&lt;/li>
&lt;/ol>
&lt;h3 id="使用步骤">使用步骤&lt;/h3>
&lt;p>以下我们以 Github 网站为例，演示下如何实现 Cookie 共享。&lt;/p>
&lt;h4 id="一确认-postman-interceptor-插件安装成功如图所示">一、确认 &lt;strong>Postman Interceptor&lt;/strong> 插件安装成功（如图所示）&lt;/h4>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/postman-interceptor-installed.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="二启动-postman在右上角的卫星小图标那里开启-chrome-interceptor">二、启动 Postman，在右上角的卫星小图标那里开启 Chrome Interceptor&lt;/h4>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/enable-postman-interceptor.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="三在-chrome-浏览器里正常登陆-github-网站此步骤没什么好演示的-">三、在 Chrome 浏览器里正常登陆 GitHub 网站（此步骤没什么好演示的 ╭(╯^╰)╮）&lt;/h4>
&lt;h4 id="四在-postman-chrome-app-中直接模拟请求通知接口">四、在 Postman Chrome app 中直接模拟请求通知接口&lt;/h4>
&lt;p>接口路径：https://github.com/notifications?_pjax=%23js-pjax-container
&lt;img src="https://blog.hackerpie.com/images/posts/chrome-visit.png" alt="clipboard.png">
也就是说，这个时候，我们虽然没有对 Postman 做特殊的 Cookie 设置，但是它的请求的登录态都被服务器验证通过了，cookie 共享成功！&lt;/p>
&lt;h3 id="假如这个时候退出浏览器的登录态呢">假如这个时候退出浏览器的登录态呢？&lt;/h3>
&lt;p>我们先从 GitHub 退出登录，还是刚才的请求，这个时候的响应是：
&lt;img src="https://blog.hackerpie.com/images/posts/chrome-visit2.png" alt="clipboard.png">
是的，因为 Chrome 里已经退出登录，所以 Postman 这边也自然失去登录态了，说明两边 Cookie 是同步的。&lt;/p>
&lt;h3 id="postman-interceptor-的-bonus">Postman Interceptor 的 Bonus&lt;/h3>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/postman-inteceptor-configuration.png" alt="clipboard.png">
Postman Interceptor 还有一点比较爽的是，它的 &lt;code>Request Capture&lt;/code> 支持捕捉 Chrome 浏览器里的请求记录，并且自动同步到 Postman Chrome app 里边，这样的话，我们就可以方便直接在 Postman 里获取到我们需要测试的网络请求，而不是一个一个自己填写参数之类的了。
&lt;img src="https://blog.hackerpie.com/images/posts/postman-history.png" alt="clipboard.png">
&lt;/p>
&lt;h3 id="缺陷">缺陷&lt;/h3>
&lt;p>遗憾的是，按照官方说明，现在 Postman Interceptor 的这个Cookie 共享还不能支持独立安装的桌面版（从官方下载而不是从 Chrome 应用市场下载）的 Postman Desktop，所以，如果你希望使用上述功能，你只能安装回 Postman Chrome app，而这个版本相对桌面版，功能自然也会少。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>Note&lt;/strong>: Interceptor feature is supported only in our Postman Chrome Apps and is not available in Postman Desktop Apps at the moment.&lt;/p>
&lt;/blockquote>
&lt;p>另一方面，考虑到 Chrome 浏览器将会在不久的将来停掉 Chrome apps 的支持，可能这个方案也撑不了太久。&lt;/p>
&lt;p>如果你真心希望 Postman 将上述功能加到他们的桌面版里，可以到&lt;a href="https://github.com/postmanlabs/postman-app-support/issues/1667">他们的官方GitHub issues&lt;/a>去请愿，他们正在收集大家的意见。但是……这个请愿帖已经两年多了，而就在我表达请求之前的几个小时到几天之前，都有人陆续去请愿，所以也不知道会不会真的如愿了。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>对于确实需要获取网站 cookie 才能完成接口测试的场景，上述方法有一定的便利性，也才有必要使用我的方法，其他场景的接口测试，你们就无视我吧。&lt;/p>
&lt;h3 id="参考链接">参考链接&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="http://blog.getpostman.com/2014/11/28/using-the-interceptor-to-read-and-write-cookies/">Postman: Using the Interceptor to read and write cookies&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://support.getpostman.com/hc/en-us/articles/203779012-How-do-I-access-Chrome-s-cookies-in-Postman-s-Chrome-App-">Postman Help Center: How do I access Chrome&amp;rsquo;s cookies in Postman&amp;rsquo;s Chrome App?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://learning.getpostman.com/docs/postman/sending_api_requests/interceptor_extension/">Postman Learning Center: Interceptor extension&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.engadget.com/2016/08/19/google-ending-chrome-apps-for-mac-and-windows/">Google is phasing out Chrome apps for Mac and Windows&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>记一次Redis数据库配置导致的连接数泄露的问题</title><link>https://blog.hackerpie.com/posts/2018/ji-yi-ci-redisshu-ju-ku-pei-zhi-dao-zhi-de-lian-jie-shu-xie-lou-de-wen-ti/</link><pubDate>Sat, 10 Feb 2018 20:35:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2018/ji-yi-ci-redisshu-ju-ku-pei-zhi-dao-zhi-de-lian-jie-shu-xie-lou-de-wen-ti/</guid><description>&lt;h3 id="问题背景">问题背景&lt;/h3>
&lt;p>去年圣诞节当天，突然收到一个我经手过的项目的告警邮件，错误消息显示**“Redis::CommandError: ERR max number of clients reached”**。
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.002.jpeg" alt="Redis 连接数告警">
&lt;/p>
&lt;p>什么情况？难道这个项目翻车了？第一反应是这台服务器运行着自建的 Redis 数据库，但是客户端只有同个内网的一个 Ruby on Rails 的应用，怎么会有连接数爆掉的可能？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4 id="理论连接数计算">理论连接数计算&lt;/h4>
&lt;p>老衲掐指一算：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>sidekiq 客户端所需连接数&lt;/strong>: 对面 Rails 应用有 10 个 Unicorn 工作进程，每个unicorn进程初始化一个 sidekiq 客户端，一个 sidekiq 客户端默认连接池大小是 5，而且是懒惰策略，按需连接的，最大值是 10 x 5 = 50；&lt;/li>
&lt;li>&lt;strong>显式 Redis 连接&lt;/strong>: 程序代码里有一个 $redis 全局变量，初始化了一个 redis 连接，10个工作进程，也就是 10 个连接；&lt;/li>
&lt;li>&lt;strong>sidekiq 服务端所需连接数&lt;/strong>: sidekiq server 端 concurrency 配置是 10，那么按照官方文档，另有加上 2 个连接，也就是12个连接；&lt;/li>
&lt;li>&lt;strong>Rails cache 所需连接数&lt;/strong>: 按照&lt;code>redis-store&lt;/code> gem 源码，默认连接池大小应该是 5，10个 unicorn 工作进程，按需连接，最大值是 10 x 5 = 50。&lt;/li>
&lt;/ol>
&lt;p>在不考虑其他可能还用到 Redis 连接的情况下，目前已知的最大 Redis 连接数需求是 122，这个数远小于 Redis 理论最大连接数啊，而且当时显示连接数到达上万！而且这个项目已经很少访问，压力极其小，不大可能会达到理论所需连接数啊！&lt;/p>
&lt;p>一定是有&lt;strong>某种神秘力量&lt;/strong>在主导这一切！！！&lt;/p>
&lt;h3 id="监控与分析">监控与分析&lt;/h3>
&lt;p>以上理论最大连接数分析只是定性分析，只能大概说明有一些诡异的东西存在，而想真正确认问题根源，还得做定量分析，只有数据才能说明一切！&lt;/p>
&lt;h4 id="初步观察redis-数据库服务器端监控">初步观察：Redis 数据库服务器端监控&lt;/h4>
&lt;p>事不宜迟，要采集数据，第一步就是加监控，所以当时就紧急写了一个定时采集 Redis 客户端数量（使用 redis 内建 &lt;code>CLIENT LIST&lt;/code> 命令）的脚本，结合 crontab 定时运行，将结果写入文件，作为后续分析的基础。
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.003.jpg" alt="监控脚本">
&lt;/p>
&lt;p>通过监控脚本，发现几个有意思的现象：&lt;/p>
&lt;ol>
&lt;li>从 Redis 数据库服务端采集的数据看，&lt;strong>一直只有来自一台内网机器，也就是我前面说的 Rails 程序所在的服务器的连接&lt;/strong>，说明这个 Redis 数据库不存在共享给其他应用的可能性；&lt;/li>
&lt;li>经过3天左右的监控，即从12.25到12.28，连续3天，Redis 连接数一直稳步上升，平均每日增加 70-80。在典型的系统资源泄露类（比如内存泄露）问题的场景中，这样的线条看起来特别熟悉，所以，真的是&lt;strong>连接数泄露&lt;/strong>了？
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.004.jpeg" alt="连接数数量稳步攀升">
&lt;/li>
&lt;/ol>
&lt;h4 id="进一步分析redis-数据库服务器端与客户端连接数对比分析">进一步分析：Redis 数据库服务器端与客户端连接数对比分析&lt;/h4>
&lt;p>在有了上一步的发现之后，我继续用系统命令 &lt;code>sudo netstat -apnt&lt;/code> 检查 &lt;code>6379&lt;/code> 端口连接数发现，客户端机器也才只有 42 个左右的连接到 redis 服务器端，结合最开始的理论连接数分析，这个数量是比较合理的。&lt;/p>
&lt;p>但是！但是！反过来去服务端机器用同样的命令检查，在服务端视角，却有多达300+个客户端建立的连接，而且都是在 ESTABLISHED 状态！这个数量和上面另一种监控方式得到的数量一致！
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.005.jpeg" alt="服务器端与客户端 TCP 连接数不匹配">
&lt;/p>
&lt;p>到底是什么情况？还能有这种操作？
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.006.jpeg" alt="服务器端与客户端谁真谁假">
&lt;/p>
&lt;h3 id="问题根源">问题根源&lt;/h3>
&lt;p>至此，Redis 连接数泄露是板上钉钉的事情了，可是又是为什么呢？为此，我在网上搜索了很多问答跟文章，后来总算找到了答案，果不其然，还是默认配置的问题。&lt;/p>
&lt;h4 id="redis-默认配置">Redis 默认配置&lt;/h4>
&lt;blockquote>
&lt;p>redis 为了避免客户端连接数过多，有一个timeout配置，意思是如果连接的空闲时间超过了timeout的值，则关闭连接。默认配置是0，意思是没有超时限制，永远不关闭连接。生产上显然不会配置0……
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.007.jpeg" alt="redis timeout配置解释">
&lt;/p>
&lt;/blockquote>
&lt;p>OMG！赶紧打开我们的 redis 的配置文件验证是否如此，果不其然，redis一直保持着默认配置！
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.008.jpeg" alt="redis timeout 默认配置">
&lt;/p>
&lt;p>至此，很好解释为什么连接数会泄露了，因为有很多空闲或者实际上客户端已经断开的连接，在服务器端一侧仍然保持着。那什么情况会导致这样的情况发生呢？&lt;/p>
&lt;p>我猜测：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>网络通信差&lt;/strong>: 按照 TCP 协议，客户端断开连接时，向服务器端发送 FIN 信号，但是服务端未接收到，客户端超时后放弃等待，直接断开，服务端由于通信故障，保持了 ESTABLISHED 状态，不过由于两端机器在同个内网，网络质量没有理由不行；&lt;/li>
&lt;li>&lt;strong>客户端异常&lt;/strong>: 客户端连接之后，由于代码运行过程中产生异常，导致未正常释放或者关闭连接，sidekiq 的worker很可能就有这类问题。这个的可能性非常大，毕竟我日常写 bug (&lt;em>/ω╲&lt;/em>)。&lt;/li>
&lt;/ol>
&lt;h3 id="问题修复">问题修复&lt;/h3>
&lt;p>找到问题根源之后，修复起来就简直太简单了。事实上，开发领域就是如此，绝大部分时间都花在了找 bug 上，而改掉bug，可能只需要一分钟不到。&lt;/p>
&lt;p>首先，修改了下 redis 数据库配置：
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.009.jpeg" alt="redis 修改成建议配置">
&lt;/p>
&lt;p>成功重启 redis 之后，重新运行前面的监控脚本，以便观察修复后情况，初步可以确认这下服务器端和客户端的连接数一致了：&lt;/p>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.010.jpeg" alt="配置生效重启后，多次重新检查两端看到的连接数，都一直保持一致了，说明服务端能正常释放一些 idle 连接了。">
&lt;/p>
&lt;p>再又经过几天的脚本自动采集数据后分析，系统又恢复平稳运行了，连接数一直稳定在理论最大连接数之下。
&lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.011.jpeg" alt="redis 连接数稳定，稳定在理论最大连接数之下">
&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>这个问题的根源其实很小，但是排查过程还是花了挺多时间，主要是需要等待采集到足够的数据后用于分析。其他心得体会：&lt;/p>
&lt;ol>
&lt;li>保护“案发现场”很重要，要想挖掘问题根源，必须保持环境可重现，这次出现问题的时候虽然第一时间重启了 redis 使服务恢复，但是由于没有修改任何配置，所以使得后来的监控能够发现问题根源；&lt;/li>
&lt;li>使用开源软件，必须对默认配置保持警惕，相信应该有人以前听说过 redis 默认监听&lt;code>0.0.0.0&lt;/code>来源请求的安全漏洞；&lt;/li>
&lt;li>这个项目由于开始较早，当时并没有考虑使用 Redis 云数据库，自建数据库有风险，需要慎重对待，尽可能的情况下，专业的事情，交给专业的人去做。&lt;/li>
&lt;/ol></description></item><item><title>解读 Rails: Migrations</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-migrations/</link><pubDate>Sat, 14 Oct 2017 22:29:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-migrations/</guid><description>&lt;p>此文翻译自&lt;a href="http://www.monkeyandcrow.com/blog/reading_rails_migrations/">Reading Rails - Migrations&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>今天我们将会探讨一下 Rails 经常被忽视的可靠的工作伙伴 —— Migrator。它是如何搜寻你的 migrations 并且执行它们的呢？我们将再一次慢慢地挖掘 Rails 的源代码，并在此过程中慧海拾珠。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>为了跟随本文的步骤，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开相关的代码库，或者直接在&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github&lt;/a>上查看这些代码。&lt;/p>
&lt;h3 id="动身启程">动身启程&lt;/h3>
&lt;p>在展开讨论之前，此处并无特殊准备要求。或许你已经创建好了项目所需要的但是仍是空的数据库。如果你执行 &lt;code>rake db:migrate&lt;/code>，所有的未执行的 migrations 就会开始执行。让我们从查看 &lt;code>databases.rake&lt;/code> 里的 Rake 任务的源码开始动起来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>desc &lt;span style="font-style:italic">&amp;#34;Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog).&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>task &lt;span style="font-style:italic">:migrate&lt;/span> =&amp;gt; [&lt;span style="font-style:italic">:environment&lt;/span>, &lt;span style="font-style:italic">:load_config&lt;/span>] &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActiveRecord::Migration.verbose = ENV[&lt;span style="font-style:italic">&amp;#34;VERBOSE&amp;#34;&lt;/span>] ? ENV[&lt;span style="font-style:italic">&amp;#34;VERBOSE&amp;#34;&lt;/span>] == &lt;span style="font-style:italic">&amp;#34;true&amp;#34;&lt;/span> : &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActiveRecord::Migrator.migrate(ActiveRecord::Migrator.migrations_paths, ENV[&lt;span style="font-style:italic">&amp;#34;VERSION&amp;#34;&lt;/span>] ? ENV[&lt;span style="font-style:italic">&amp;#34;VERSION&amp;#34;&lt;/span>].to_i : &lt;span style="">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然我们并不打算揭露 Rake 本身的工作机制，但是值得注意的是，执行 &lt;code>migrate&lt;/code> 要求另外两个任务 &lt;code>[:environment, :load_config]&lt;/code> 的首先执行。这能确保 Rails 的运行环境以及你的 &lt;code>database.yml&lt;/code> 文件被加载进来。&lt;/p>
&lt;p>上面的 rake 任务通过环境变量配置了 &lt;code>ActiveRecord::Migration&lt;/code> 以及 &lt;code>ActiveRecord::Migrator&lt;/code>。环境变量是一种非常有效的可用于向你的应用程序传递信息的方式。缺省地，诸如&lt;code>USER&lt;/code>的很多（环境）变量都是已经设置好的，他们也可以在每个（终端）命令执行时单独设置。举个例子，如果你通过 &lt;code>VERBOSE=false rake db:migrate&lt;/code> 调用了 Rake 任务，&lt;code>ENV[&amp;quot;VERBOSE&amp;quot;]&lt;/code>的值就会是字符串&lt;code>&amp;quot;false&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># 通过环境变量启动 irb：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># &amp;gt; FOOD=cake irb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENV[&lt;span style="font-style:italic">&amp;#39;FOOD&amp;#39;&lt;/span>] &lt;span style="font-style:italic">#=&amp;gt; &amp;#39;cake&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENV[&lt;span style="font-style:italic">&amp;#39;USER&amp;#39;&lt;/span>] &lt;span style="font-style:italic">#=&amp;gt; &amp;#39;adam&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ENV[&lt;span style="font-style:italic">&amp;#39;WAFFLES&amp;#39;&lt;/span>] &lt;span style="font-style:italic">#=&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>migration 的真正工作是从 &lt;code>ActiveRecord::Migrator.migrate&lt;/code> 开始的，这个方法接受了第一个参数，用于表示 migrations 文件可能存在的路径的集合，另外还有一个可选参数，用于表示 migrate 执行的目标版本。&lt;/p>
&lt;h3 id="搜寻-migrations">搜寻 migrations&lt;/h3>
&lt;p>现在就打开 ActiveRecord 里的 &lt;code>migration.rb&lt;/code> 文件，不过在深入探究之前，先查看下在这个文件里最上面定义的异常。定义自定义的异常是非常容易的，&lt;code>migration.rb&lt;/code> 里就有一些不错的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">ActiveRecord&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 可以用于在回滚过程中中止 migrations 的异常类&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">IrreversibleMigration&lt;/span> &amp;lt; ActiveRecordError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">IllegalMigrationNameError&lt;/span> &amp;lt; ActiveRecordError&lt;span style="font-style:italic">#:nodoc:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> initialize(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">super&lt;/span>(&lt;span style="font-style:italic">&amp;#34;Illegal name for migration file: &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n\t&lt;/span>&lt;span style="font-style:italic">(only lower case letters, numbers, and &amp;#39;_&amp;#39; allowed)&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>像我们在之前讲 &lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/">Rails 处理异常&lt;/a> 的文章中一样，自定义异常能够被特别处理。在这个案例里，&lt;code>IrreversibleMigration&lt;/code> 表示当前的 &lt;code>migration&lt;/code> 不能被回滚。另外一个需要定义你自己的异常的原因是，可以像&lt;code>IllegalMigrationNameError&lt;/code>一样，通过重定义&lt;code>initialize&lt;/code>方法来实现生成一致的错误消息。同时，要确保你调用了 &lt;code>super&lt;/code>。&lt;/p>
&lt;p>现在向下滚动（文件），让我们看看 &lt;code>Migrator.migrate&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Migrator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &amp;lt;&amp;lt; self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> migrate(migrations_paths, target_version = &lt;span style="">nil&lt;/span>, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">case&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> target_version.nil?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> up(migrations_paths, target_version, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> current_version &amp;gt; target_version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> down(migrations_paths, target_version, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> up(migrations_paths, target_version, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>取决于 &lt;code>target_version&lt;/code>，我们将通过 &lt;code>up&lt;/code> 或者 &lt;code>down&lt;/code> 完成 migrate。这两个方法遵循了同样的模式，都是扫描了 &lt;code>migration_paths&lt;/code> 里的可执行的 migrations，然后初始化一个新的 &lt;code>Migrator&lt;/code> 的实例。让我们看看这些 migrations 是如何被搜寻到的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Migrator&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &amp;lt;&amp;lt; self
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> migrations(paths)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> paths = Array(paths)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> files = Dir[*paths.map { |p| &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>p&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">/**/[0-9]*_*.rb&amp;#34;&lt;/span> }]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrations = files.map &lt;span style="font-weight:bold">do&lt;/span> |file|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version, name, scope = file.scan(&lt;span style="font-style:italic">/([0-9]+)_([_a-z0-9]*)\.?([_a-z0-9]*)?\.rb\z/&lt;/span>).first
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> IllegalMigrationNameError.new(file) &lt;span style="font-weight:bold">unless&lt;/span> version
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> version = version.to_i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = name.camelize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> MigrationProxy.new(name, version, file, scope)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> migrations.sort_by(&amp;amp;&lt;span style="font-style:italic">:version&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法里满是非常值得学习的实例，让我们停留几分钟并且仔细阅读它。最开始，代码里通过一个 &lt;code>Array()&lt;/code> 方法这样的小技巧，确保了参数始终是数组类型。“你说这（Array）是个方法？”是的！这虽然不是很正统，但定义一个驼峰式命名的方法是合法的，甚至这样的方法名还可以和类同名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Flummox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> Flummox()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;confusing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Flummox &lt;span style="font-style:italic">#=&amp;gt; Flummox&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Flummox.new &lt;span style="font-style:italic">#=&amp;gt; #&amp;lt;Flummox:0x0000000bf0b5d0&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Flummox() &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;confusing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ruby 使用了这个特性定义了一个 &lt;code>Array()&lt;/code> 方法，这个方法始终返回一个数组。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>Array(&lt;span style="">nil&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; []&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Array([]) &lt;span style="font-style:italic">#=&amp;gt; []&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Array(1) &lt;span style="font-style:italic">#=&amp;gt; [1]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Array(&lt;span style="font-style:italic">&amp;#34;Hello&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;Hello&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Array([&lt;span style="font-style:italic">&amp;#34;Hello&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;World&amp;#34;&lt;/span>]) &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;Hello&amp;#34;, &amp;#34;World&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法类似于 &lt;code>to_a&lt;/code>，但是可以在任何（类型的）对象上调用。Rails 通过 &lt;code>paths = Array(paths)&lt;/code>使用了这个（方法），得以确保 &lt;code>paths&lt;/code> 将是一个数组。&lt;/p>
&lt;p>在接下来一行的代码里，Rails 搜寻了指定的路径并且进行了过滤：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>files = Dir[*paths.map { |p| &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>p&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">/**/[0-9]*_*.rb&amp;#34;&lt;/span> }]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们将这个代码分解一下。&lt;code>paths.map { |p| &amp;quot;#{p}/**/[0-9]*_*.rb&amp;quot; }&lt;/code>将每一个路径转换成一个 [&lt;code>shell glob&lt;/code>](&lt;a href="http://en.wikipedia.org/wiki/Glob_(programming">http://en.wikipedia.org/wiki/Glob_(programming&lt;/a>))。一个类似 &lt;code>&amp;quot;db/migrate&amp;quot;&lt;/code> 的路径就变成了 &lt;code>&amp;quot;db/migrate/**/[0-9]*_*.rb&amp;quot;&lt;/code>，这将会在 &lt;code>&amp;quot;db/migrate&amp;quot;&lt;/code> 或者它的所有子目录里匹配所有用数字开头的文件。这些（shell glob 表示的）路径通过 &lt;code>*&lt;/code> 操作符分成（单个元素）并且传递给了 &lt;code>Dir[]&lt;/code>。&lt;/p>
&lt;p>&lt;code>Dir[]&lt;/code> 是非常有用的。它接收类似 &lt;code>&amp;quot;db/migrate/**/[0-9]*_*.rb&amp;quot;&lt;/code> 这样的模式（作为参数），然后返回匹配的文件列表。当你需要在指定路径里查找文件的时候，&lt;code>Dir[]&lt;/code> 就是称手利器。其中，&lt;code>**&lt;/code> 表示递归地在所有子目录中执行匹配，而 &lt;code>*&lt;/code> 则表示一个或多个字符的通配符，也就是说，前面的这个模式就是为了匹配类似 &lt;code>20131127051346_create_people.rb&lt;/code> 的 migrations （文件）。&lt;/p>
&lt;p>Rails 遍历每一个匹配的文件，并且通过 &lt;code>String#scan&lt;/code> 结合正则表达式提取信息。如果你对正则表达式不是很熟悉，那现在就应该抛开一切，先学习好正则表达式再说。&lt;code>String#scan&lt;/code> 以字符串形式返回所有匹配的结果。如果表达式里还包含了 capturing groups（匹配分组），它们将会以内嵌数组（subarrays）的方式返回。比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>s = &lt;span style="font-style:italic">&amp;#34;123 abc 456&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># 没有 capturing groups:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s.scan(&lt;span style="font-style:italic">/\d+/&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;123&amp;#34;, &amp;#34;456&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s.scan(&lt;span style="font-style:italic">/\d+\s\w+/&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;123 abc&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># 先匹配数字，再匹配单词：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>s.scan(&lt;span style="font-style:italic">/(\d+)\s+(\w+)/&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; [[&amp;#34;123&amp;#34;, &amp;#34;abc&amp;#34;]]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以 &lt;code>file.scan&lt;/code> 将会匹配版本号&lt;code>([0-9]+)&lt;/code>，名字&lt;code>([_a-z0-9]*)&lt;/code>，以及一个可选的 scope &lt;code>([_a-z0-9]*)?&lt;/code>。由于 &lt;code>String#scan&lt;/code> 始终返回数组，并且我们知道这个模式只会出现一次，所以 Rails 直接提取第一个匹配结果。Rails 一次性执行了多个变量赋值 &lt;code>version, name, scope = ...&lt;/code>。这是得益于数组的解构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>version, name, scope = [&lt;span style="font-style:italic">&amp;#34;20131127051346&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;create_people&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>version &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;20131127051346&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>name &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;create_people&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope &lt;span style="font-style:italic">#=&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意一下，如果（等号左边）变量的数量大于（等号右边）数组的元素的数量，多余变量的值将会被赋值为&lt;code>nil&lt;/code>。这是一种从正则表达式（匹配后的值）进行多个赋值的快捷技巧。&lt;/p>
&lt;p>匹配的版本号 version 通过 &lt;code>to_i&lt;/code> 方法转换为一个整数（Fixnum），而同时，名字 name 通过 &lt;code>name.camelize&lt;/code> 完成了格式转换。&lt;code>String#camelize&lt;/code>是 &lt;code>ActiveSupport&lt;/code> 里的方法，用于下划线命名 &lt;code>snake_case&lt;/code> 和 驼峰式命名 &lt;code>CamelCase&lt;/code> 之间的相互转换。这个方法可以将 &lt;code>&amp;quot;create_people&amp;quot;&lt;/code> 转换为 &lt;code>CreatePeople&lt;/code>。&lt;/p>
&lt;p>让我们过会再看下 &lt;code>MigrationProxy&lt;/code>，现在先看下 &lt;code>Migrator#migrations&lt;/code> 这个方法的最后一个部分，&lt;code>migrations.sort_by(&amp;amp;:version)&lt;/code>。这个表达式将所有 migrations 基于版本号进行了排序。如何排序的方式会是更有趣的内容。&lt;/p>
&lt;p>从 Ruby 1.9 开始，&lt;code>&amp;amp;&lt;/code>操作将会在被它作用的对象上调用 &lt;code>to_proc&lt;/code> 方法。当在一个 symbol 上调用时，返回的结果是一个代码块里调用与 symbol 同命名的方法的 &lt;code>Proc&lt;/code> 对象。所以 &lt;code>&amp;amp;:version&lt;/code> 等同于某行代码的 &lt;code>{|obj| obj.version }&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>Library = Struct.new(&lt;span style="font-style:italic">:name&lt;/span>, &lt;span style="font-style:italic">:version&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libraries = [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Library.new(&lt;span style="font-style:italic">&amp;#34;Rails&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;4.0.1&amp;#34;&lt;/span>),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Library.new(&lt;span style="font-style:italic">&amp;#34;Rake&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;10.1.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libraries.map{|lib| lib.version } &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;4.0.1&amp;#34;, &amp;#34;10.1.0&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># &amp;amp;:version =&amp;gt; Proc.new{|lib| lib.version } (Roughly)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>libraries.map(&amp;amp;&lt;span style="font-style:italic">:version&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; [&amp;#34;4.0.1&amp;#34;, &amp;#34;10.1.0&amp;#34;]&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在 Rails 里，这种技巧在排序或者映射的时候非常常见。和众多的技巧一样，请确认你的团队能够适应这种语法。如有疑虑，更好的方案就是不再使用（这种技巧），这会让代码更清晰。&lt;/p>
&lt;h3 id="the-migration">The Migration&lt;/h3>
&lt;p>现在，回到 &lt;code>MigrationProxy&lt;/code>。顾名思义，只是一个 &lt;code>Migration&lt;/code> 的实例的代理。代理对象（Proxy objects）是一个常见的用于透明地将一个对象替换为另一个对象的设计模式。在这个例子中，&lt;code>MigrationProxy&lt;/code>代替了一个真正的 &lt;code>Migration&lt;/code> 对象，而且除非必需，它会延缓对 migration 的源码的实际的加载。&lt;code>MigrationProxy&lt;/code> 通过委托方法（delegating methods）达到目的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">MigrationProxy&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delegate &lt;span style="font-style:italic">:migrate&lt;/span>, &lt;span style="font-style:italic">:announce&lt;/span>, &lt;span style="font-style:italic">:write&lt;/span>, &lt;span style="font-style:italic">:disable_ddl_transaction&lt;/span>, &lt;span style="font-style:italic">to&lt;/span>: &lt;span style="font-style:italic">:migration&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">private&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> migration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @migration ||= load_migration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> load_migration
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require(File.expand_path(filename))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name.constantize.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>delegate&lt;/code> 方法将它的每一个参数都发送给了 &lt;code>to:&lt;/code> 选项返回的对象，在这里，这个对象就是我们的 &lt;code>migration&lt;/code>。如果 &lt;code>@migration&lt;/code> 实例变量尚未定义或赋值，&lt;code>migration&lt;/code> 方法将会执行懒加载migration &lt;code>load_migration&lt;/code>。&lt;code>load_migration&lt;/code> 方法按序加载(require) ruby 源码，然后使用 &lt;code>name.constantize.new&lt;/code> 创建一个新的实例。&lt;code>String#constantize&lt;/code> 是 ActiveSupport 中定义的方法，用于返回名字与字符串相同的常量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&amp;#34;Person&amp;#34;&lt;/span>.constantize &lt;span style="font-style:italic">#=&amp;gt; Person&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&amp;#34;Person&amp;#34;&lt;/span>.constantize.class &lt;span style="font-style:italic">#=&amp;gt; Class&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&amp;#34;person&amp;#34;&lt;/span>.constantize &lt;span style="font-style:italic">#=&amp;gt; NameError: wrong constant name person&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你想要动态地引用一个类时，这个技巧非常有效。&lt;/p>
&lt;p>通过 &lt;code>MigrationProxy&lt;/code>，Rails 只加载并且实例化必要的 migrations，这能为 migration 的处理提速，同时节约更多内存。&lt;/p>
&lt;p>真正的 &lt;code>Migration&lt;/code> 类在代理委托了 &lt;code>migrate&lt;/code> 方法的时候才被 &lt;code>Migrator&lt;/code> 调用。这个按序调用 &lt;code>Migration#up&lt;/code> 或者 &lt;code>Migration#down&lt;/code> 取决于 migration 是在先前执行，还是在执行回滚。&lt;/p>
&lt;h3 id="总结recap">总结（Recap）&lt;/h3>
&lt;p>我们仅仅只是一瞥了 Rails 的 migration 机制的源码的表面，但是我们却已经学到了一些有趣的知识。Migrations 由一个调用了 &lt;code>Migrator&lt;/code> 的 Rake 任务启动，&lt;code>Migrator&lt;/code> 又按序查找到了我们的 migrations，并且使用了 &lt;code>MigrationProxy&lt;/code> 对象对这些 migrations 进行了包装，直到真正的 &lt;code>Migration&lt;/code> 需要被执行的时候。&lt;/p>
&lt;p>一如既往，我们已经了解了一些有趣的方法、习惯以及技巧：&lt;/p>
&lt;ul>
&lt;li>环境变量可以通过 &lt;code>ENV&lt;/code> 常量访问；&lt;/li>
&lt;li>定义自定义的异常类，是一种常见的对异常进行处理的手段；&lt;/li>
&lt;li>&lt;code>Array()&lt;/code> 方法将任意对象转换为数组；&lt;/li>
&lt;li>&lt;code>Dir[]&lt;/code> 使用 &lt;code>shell glob&lt;/code> 语法搜索文件；&lt;/li>
&lt;li>&lt;code>String#scan&lt;/code> 返回字符串里所有匹配的结果，并且支持匹配分组（capturing groups）；&lt;/li>
&lt;li>&lt;code>String#camelize&lt;/code> 将下划线形式（snake_case）字符串转换为驼峰式（CamelCase）;&lt;/li>
&lt;li>&lt;code>&amp;amp;&lt;/code> 操作符在符号类型的对象上调用时，会创建一个 &lt;code>Proc&lt;/code> 对象&lt;/li>
&lt;li>&lt;code>delegate&lt;/code> 可以用于实现代理的设计模式&lt;/li>
&lt;li>可以通过 &lt;code>String#contantize&lt;/code> 方法动态加载常量&lt;/li>
&lt;/ul>
&lt;p>下一次，或许我们就能弄明白 &lt;code>Migrator&lt;/code> 是如何确切知道哪些 migrations 已经在你的数据库里执行过。&lt;/p>
&lt;h3 id="喜欢这篇文章">喜欢这篇文章？&lt;/h3>
&lt;p>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多&lt;/a>“解读Rails”中的文章。“解读Rails”中的文章。&lt;/p></description></item><item><title>动态密码算法介绍与实现</title><link>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</link><pubDate>Sat, 18 Feb 2017 09:54:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</guid><description>&lt;p>动态密码，亦称一次性密码（One Time Password, 简称 OTP），是一种高效简单又比较安全的密码生成算法，在我们的生活以及工作中随处可见，身为开发者，也或多或少在自己的业务系统中集成了二步验证机制，那么，技术运用，既要知其然，更要知其所以然，动态密码算法是怎样的？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="读前指引">读前指引&lt;/h2>
&lt;ul>
&lt;li>通过这篇文章，你可以了解以下知识：
&lt;ul>
&lt;li>动态密码的背景知识&lt;/li>
&lt;li>动态密码的分类&lt;/li>
&lt;li>不同动态密码的生成算法，HOTP 以及 TOTP&lt;/li>
&lt;li>HOTP 以及 TOTP 的简单的 Ruby 编程语言的实现&lt;/li>
&lt;li>两类算法各自注意事项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>限于篇幅，我不会讨论以下几点，有兴趣的同学可以参考我文章末尾给出的参考资料了解：
&lt;ul>
&lt;li>不同动态密码的安全性分析&lt;/li>
&lt;li>计时动态密码如何确保有效期间内，密码不被二次使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="动态密码背景介绍">动态密码背景介绍&lt;/h2>
&lt;p>从我的角度理解，动态密码是指随着某一事件（密码被使用、一定的时间流逝等）的发生而重新生成的密码，因为动态密码本身最大优点是防重复执行攻击(replay attack)，它能很好地避免类似静态密码可能被暴力破解等的缺陷，现实运用中，一般采用“静态密码+动态密码”相结合的双因素认证，我们也称二步验证。&lt;/p>
&lt;p>而动态密码其实很早就出现在我们的生活里了，在移动支付发展起来之前，网银是当时最为流行的在线支付渠道，当时银行为了确保大家的网银账号支付安全，都会给网银客户配发动态密码卡，比如中国银行电子口令卡（按时间差定时生成新密码，口令卡自带电池，可保证连续使用几年），或者工商银行的电子银行口令卡（网银支付网页每次生成不同的行列序号，用户根据指定行列组合刮开密码卡上的涂层获取密码，密码使用后失效），又或者银行强制要求的短信验证码，这些都可以纳入动态密码的范畴。&lt;br>
&lt;img src="https://blog.hackerpie.com/images/secureRSA.jpeg" alt="中行电子口令卡">
&lt;img src="https://blog.hackerpie.com/images/password_card.jpg" alt="工行电子银行口令卡">
&lt;/p>
&lt;p>而随着移动互联网的发展以及移动设备的智能化的不断提高，设备间的同步能力大幅提升，以前依赖独立设备的动态密码生成技术很快演变成了手机上的动态密码生成软件，以手机软件的形式生成动态密码的方式极大提高了动态密码的便携性，一个用户一个手机就可以管理任意多个动态密码的生成，这也使得在网站上推动二步验证减少了很多阻力，因为以往客户可能因为使用口令卡太麻烦，而拒绝打开二步验证机制，从而让自己的账号暴露在风险之下。最为知名的动态密码生成软件，当属 Google 的 Authenticator APP。&lt;br>
&lt;img src="https://blog.hackerpie.com/images/google-auth.jpeg" alt="Google Authenticator">
&lt;/p>
&lt;h2 id="动态密码算法探索之旅">动态密码算法探索之旅&lt;/h2>
&lt;h3 id="动态密码的分类">动态密码的分类&lt;/h3>
&lt;p>一般来说，常见的动态密码有两类：&lt;/p>
&lt;ul>
&lt;li>**计次使用：**计次使用的OTP产出后，可在不限时间内使用，知道下次成功使用后，计数器加 1，生成新的密码。用于实现计次使用动态密码的算法叫 HOTP，接下来会对这个算法展开介绍；&lt;/li>
&lt;li>**计时使用：**计时使用的OTP则可设定密码有效时间，从30秒到两分钟不等，而OTP在进行认证之后即废弃不用，下次认证必须使用新的密码。用于实现计时使用动态密码的算法叫 TOTP，接下来会对这个算法展开介绍。&lt;/li>
&lt;/ul>
&lt;p>在真正开展算法介绍之前，需要补充介绍的是：动态密码的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值进行密码算法计算，使用的算法有对称算法、HASH、HMAC等。记住这一点，这个是所有动态密码算法实现的基础。&lt;/p>
&lt;h3 id="hotp">HOTP&lt;/h3>
&lt;p>HOTP 算法，全称是“An HMAC-Based One-Time Password Algorithm”，是一种基于事件计数的一次性密码生成算法，详细的算法介绍可以查看 &lt;a href="https://tools.ietf.org/html/rfc4226">RFC 4226&lt;/a>。其实算法本身非常简单，算法本身可以用两条简短的表达式描述：&lt;/p>
&lt;blockquote>
&lt;p>HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
PWD(K,C,digit) = HOTP(K,C) mod 10^Digit&lt;/p>
&lt;/blockquote>
&lt;p>上式中：&lt;/p>
&lt;ul>
&lt;li>K 代表我们在认证服务器端以及密码生成端（客户设备）之间共享的密钥，在 RFC 4226 中，作者要求共享密钥最小长度是 128 位，而作者本身推荐使用 160 位长度的密钥&lt;/li>
&lt;li>C 表示事件计数的值，8 字节的整数，称为移动因子（moving factor），需要注意的是，这里的 C 的整数值需要用二进制的字符串表达，比如某个事件计数为 3，则C是 &lt;code>&amp;quot;11&amp;quot;&lt;/code>（此处省略了前面的二进制的数字0）&lt;/li>
&lt;li>HMAC-SHA-1 表示对共享密钥以及移动因子进行 HMAC 的 SHA1 算法加密，得到 160 位长度（20字节）的加密结果&lt;/li>
&lt;li>Truncate 即截断函数，后面会详述&lt;/li>
&lt;li>digit 指定动态密码长度，比如我们常见的都是 6 位长度的动态密码&lt;/li>
&lt;/ul>
&lt;h4 id="truncate-截断函数">Truncate 截断函数&lt;/h4>
&lt;p>由于 SHA-1 算法是既有算法，不是我们讨论重点，故而 Truncate 函数就是整个算法中最为关键的部分了。以下引用 Truncate 函数的步骤说明：&lt;/p>
&lt;blockquote>
&lt;p>DT(String) // String = String[0]&amp;hellip;String[19]
Let OffsetBits be the low-order 4 bits of String[19]
Offset = StToNum(OffsetBits) // 0 &amp;lt;= OffSet &amp;lt;= 15
Let P = String[OffSet]&amp;hellip;String[OffSet+3]
Return the Last 31 bits of P&lt;/p>
&lt;/blockquote>
&lt;p>结合上面的公式理解，大概的描述就是：&lt;/p>
&lt;ol>
&lt;li>先从第一步通过 SHA-1 算法加密得到的 20 字节长度的结果中选取最后一个字节的低字节位的 4 位（注意：动态密码算法中采用的大端(big-endian)存储）；&lt;/li>
&lt;li>将这 4 位的二进制值转换为无标点数的整数值，得到 0 到 15（包含 0 和 15）之间的一个数，这个数字作为 20 个字节中从 0 开始的偏移量；&lt;/li>
&lt;li>接着从指定偏移位开始，连续截取 4 个字节（32 位），最后返回 32 位中的后面 31 位。&lt;/li>
&lt;/ol>
&lt;p>回到算法本身，在获得 31 位的截断结果之后，我们将其又转换为无标点的大端表示的整数值，这个值的取值范围是 0 ~ 2^31，也即 0 ~ 2.147483648E9，最后我们将这个数对10的乘方（digit 指数范围 1-10）取模，得到一个余值，对其前面补0得到指定位数的字符串。&lt;/p>
&lt;h4 id="代码示例">代码示例&lt;/h4>
&lt;p>以下代码示例也可访问 &lt;a href="https://gist.github.com/Martin91/15a3a29acd9d138b0d6e125d8fbd5ab0">Gist&lt;/a> 获取。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;openssl&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> hotp(secret, counter, digits = 6)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hash = OpenSSL::HMAC.digest(OpenSSL::Digest.new(&lt;span style="font-style:italic">&amp;#39;sha1&amp;#39;&lt;/span>), secret, int_to_bytestring(counter)) &lt;span style="font-style:italic"># SHA-1 算法加密&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;%0&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>digits&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">i&amp;#34;&lt;/span> % (truncate(hash) % 10**digits) &lt;span style="font-style:italic"># 取模获取指定长度数字密码&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> truncate(string)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> offset = string.bytes.last &amp;amp; 0xf &lt;span style="font-style:italic"># 取最后一个字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> partial = string.bytes[offset..offset+3] &lt;span style="font-style:italic"># 从偏移量开始，连续取 4 个字节&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> partial.pack(&lt;span style="font-style:italic">&amp;#34;C*&amp;#34;&lt;/span>).unpack(&lt;span style="font-style:italic">&amp;#34;N&amp;#34;&lt;/span>).first &amp;amp; 0x7fffffff &lt;span style="font-style:italic"># 取后面 31 位结果后得到整数&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> int_to_bytestring(int, padding = 8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">until&lt;/span> int == 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result &amp;lt;&amp;lt; (int &amp;amp; 0xFF).chr
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> int &amp;gt;&amp;gt;= 8
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result.reverse.join.rjust(padding, 0.chr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的算法实现代码量很少，核心都是按照算法描述进行多个掩码运算跟位操作而已。&lt;/p>
&lt;h4 id="密码失效机制">密码失效机制&lt;/h4>
&lt;p>从上面的分析可以看到，一个动态密码的生成，取决于共享密钥以及移动因子的值，而共享密钥是保持不变的，最终就只有移动因子决定了密码的生成结果。所以在 HOTP 算法中，要求每次密码验证成功后，认证服务器端以及密码生成器（客户端）都要将计数器的值加1，已确保得到新的密码。&lt;/p>
&lt;p>但是在这里就会引入一个问题，假如认证服务器端与密码生成器之间由于通信故障或者其他意外情况，导致两边计数器的值不同步了，那么就会导致两边生成的密码无法正确匹配。为了解决这个问题，算法在分析中建议认证服务器端在验证密码失败后，可以主动尝试计数器减1之后重新生成的新密码是否与客户端提交密码一致，如果是，则可以认定是客户端计数器未同步导致，这种情况下可以通过验证，并且要求客户端重新同步计数器的值。&lt;/p>
&lt;p>出了上面提到的计数器不同步的问题，我另外想的是，如果客户有多个密码生成器（假设 iPad 和 iPhone）为同个账号生成密码，那么计数器在多个设备间的同步可能就需要另外考虑的方案了。&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;p>其实 HOTP 的算法比我在阅读算法前所想象的要简洁得多，而且仍然足够强健。算法本身巧妙利用了加密算法对共享密钥和计数器进行加密，确保这两个动态密码生成因子不被篡改，接着通过一个 truncate 函数随机得到一个最长 10 位的 10 进制整数，最终实现对 1 - 10 位长度动态密码的支持。算法本身的简洁也确保了算法本身可以在各种设备上实现。&lt;/p>
&lt;h3 id="totp">TOTP&lt;/h3>
&lt;p>TOTP 算法，全称是 TOTP: Time-Based One-Time Password Algorithm，其基于 HOTP 算法实现，核心是将移动因子从 HOTP 中的事件计数改为时间差。完整的 TOTP 算法的说明可以查看 &lt;a href="https://tools.ietf.org/html/rfc6238">RFC 6238&lt;/a>，其公式描述也非常简单：&lt;/p>
&lt;blockquote>
&lt;p>TOTP = HOTP(K, T) // T is an integer
and represents the number of time steps between the initial counter
time T0 and the current Unix time
More specifically, T = (Current Unix time - T0) / X, where the
default floor function is used in the computation.&lt;/p>
&lt;/blockquote>
&lt;p>通常来说，TOTP 中所使用的时间差都是当前时间戳，TOTP 将时间差除以时间窗口（密码有效期，默认 30 秒）得到时间窗口计数，以此作为动态密码算法的移动因子，这样基于 HOTP 算法就能方便得到基于时间的动态密码了。&lt;br>
&lt;strong>注意:&lt;/strong> RFC 6238 提到，在 TOTP 算法中，可以指定不同的键控哈希算法，比如在 HOTP 中使用的是 HMAC-SHA1 算法，而在 TOTP，除此之外，还可以使用 HMAC-SHA256 或者 HMAC-SHA512。&lt;/p>
&lt;blockquote>
&lt;p>TOTP implementations MAY use HMAC-SHA-256 or HMAC-SHA-512 functions,
based on SHA-256 or SHA-512 [SHA2] hash functions, instead of the
HMAC-SHA-1 function that has been specified for the HOTP computation
in [RFC4226].&lt;/p>
&lt;/blockquote>
&lt;h4 id="代码示例-1">代码示例&lt;/h4>
&lt;p>以下代码示例也可访问 &lt;a href="https://gist.github.com/Martin91/15a3a29acd9d138b0d6e125d8fbd5ab0">Gist&lt;/a> 获取。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;hotp&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> totp(secret, digits = 6, step = 30, initial_time = 0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> steps = (Time.now.to_i - initial_time) / step
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hotp(secret, steps, digits)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到了吧，极其简短的实现代码！一个时间计数的动态密码算法就此诞生，如此简单的算法，却是支撑多少业务系统安全运作的基石，颇有四两拨千斤的快感！&lt;/p>
&lt;h4 id="问题探讨">问题探讨&lt;/h4>
&lt;ol>
&lt;li>ROTP 算法中的主要问题是计数器的同步，而 TOTP 也不例外，只是问题在于服务器端与客户端之间时间的同步，由于现在互联网的发达，加上移动设备一般都会按照网络时间设置设备时间，基本上时间的相对同步都不是问题；&lt;/li>
&lt;li>时间同步的另一个问题其实是边界问题，假如客户端生成密码的时间刚好是第 29 秒，而由于网络延迟等原因，服务器受理验证时刚好是下一个时间窗口的第 1 秒，这个时候会导致密码验证失效。于是，TOTP 算法在其算法讨论中，也建议服务器在验证密码失败之后，可以尝试将自身的时间窗口值减 1 之后重新生成密码比对，如果验证通过，说明验证不通过是时间窗口的边界问题导致，这个时候可以认为密码验证通过。&lt;/li>
&lt;li>基于时间的动态密码的另一个好处是避免了基于计数器的多设备间的计数器同步问题，因为每台设备以及服务端都可以自行与网络时间（共同时间标准）校准，而无需依赖服务端的时间。&lt;/li>
&lt;/ol>
&lt;h2 id="google-authenticator">Google Authenticator&lt;/h2>
&lt;p>在 Google Authenticator 的&lt;a href="https://github.com/google/google-authenticator">开源项目&lt;/a>的 README 里有明确提到：&lt;/p>
&lt;blockquote>
&lt;p>These implementations support the HMAC-Based One-time Password (HOTP) algorithm specified in RFC 4226 and the Time-based One-time Password (TOTP) algorithm specified in RFC 6238.&lt;/p>
&lt;/blockquote>
&lt;p>也就是说，至此，我们也明白了，其实 Google Authenticator 算法核心也是 HOTP 以及 TOTP ，在明白了整个动态密码算法的核心之后，有没有一种豁然开朗的感觉呢？既知其然，又知其所以然了，对吧？每次看着应用定时生成密码，&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这篇文章简单介绍了两类常见的动态密码的生成算法，算法本身简洁不复杂，效率并且足够强健。这篇文章的目的是方便跟我一样希望了解算法核心的小伙伴，而在 RFC 文档中，仍有大量关于算法本身的安全性方面的探讨，有兴趣的小伙伴可以去看一下。&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zh.wikipedia.org/zh/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A2%BC">Wikipedia: 一次性密码&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/mdp/rotp">github: rotp&lt;/a>，HOTP 以及 TOTP 的算法实现以及其他封装&lt;/li>
&lt;li>&lt;a href="http://blog.csdn.net/goldboar/article/details/7065948">动态口令（OTP）认证技术概览&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc4226">RFC 4226 - HOTP: An HMAC-Based One-Time Password Algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc6238">RFC 6238 - TOTP: Time-Based One-Time Password Algorithm&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.csdn.net/article/2014-09-23/2821808-Google-Authenticator">详解Google Authenticator工作原理&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="示例源码">示例源码&lt;/h2>
&lt;p>&lt;a href="https://gist.github.com/Martin91/15a3a29acd9d138b0d6e125d8fbd5ab0">Gist: OTP algorithms in Ruby&lt;/a>&lt;/p></description></item><item><title>周末到了，来段代码压压惊</title><link>https://blog.hackerpie.com/posts/archive/zhou-mo-dao-le-lai-duan-dai-ma-ya-ya-jing/</link><pubDate>Sat, 26 Nov 2016 21:43:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhou-mo-dao-le-lai-duan-dai-ma-ya-ya-jing/</guid><description>&lt;p>最近一段时间，写了两篇关于 sidekiq 的源码分析，但是一直想要补充的一段 sidekiq 里边的代码其实是挺有趣也挺逗的，所以这个星期就不要长篇大论的源码分析，来点轻松点的吧。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>这个代码是这样的 o(╯□╰)o：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L51-L53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Sidekiq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> self.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Haha, are you kidding me? 见过用特殊字符或者特殊语言文字做方法名的，但是用颜文字，我还是第一次见。但是别笑，本着工科男严谨与求知的精神，我全局搜索了下这个方法的调用，结果更搞笑的结果来了，这个方法根本就没有真实调用，但是相应的测试用例同样非常逗 2333333333！！！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>describe &lt;span style="font-style:italic">&amp;#34;❨╯°□°❩╯︵┻━┻&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before { $stdout = StringIO.new }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> after { $stdout = STDOUT }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="font-style:italic">&amp;#34;allows angry developers to express their emotional constitution and remedies it&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_equal &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>, $stdout.string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，这只是难道为了方便程序员怒火中烧的时候表达想掀桌的内心吗？&lt;/p>
&lt;p>当然，这个问题其实早就有很多人发现了，Ruby China 上也有好多的讨论了。今天是个快乐周六，让我再从网络上搜罗多一些搞笑的代码吧，哈哈~~~&lt;/p>
&lt;h2 id="精彩段子时间">精彩段子时间&lt;/h2>
&lt;p>每一个在注释或者代码里藏段子的程序员上辈子都是折翼的逗逼，不信，你看！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Exception up = &lt;span style="font-weight:bold">new&lt;/span> Exception(&lt;span style="font-style:italic">&amp;#34;Something is really wrong.&amp;#34;&lt;/span>);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">throw&lt;/span> up; &lt;span style="font-style:italic">//ha ha
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个程序猿写代码时到底什么心态啊，故意抛个异常，还在注释里如此狂妄？墙头草可除了？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//When I wrote this, only God and I understood what I was doing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//Now, God only knows
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，这个是我看的时候感觉比较搞笑的了，有种代码叫做天知地知我知，后来变成只有天知道了。。。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// drunk, fix later
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好自觉的程序猿啊，酒后不宜改代码，多提倡，建议立法机关考虑加条规定，凡是酒后写代码的，一律立案侦办！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="">#define TRUE FALSE
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以想象当这个 commit 被 merge 进生产环境之后。。。哈哈，整个世界黑白颠倒！对的就是错的，错的就是对的！！！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">return&lt;/span> 1; &lt;span style="font-style:italic"># returns 1&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这。。。不。。。是。。。废。。。话。。。吗。。。？！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-java" data-lang="java">&lt;span style="display:flex;">&lt;span>Catch (Exception e) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">//who cares?
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，我知道系统有异常啊，但是我才不管呢，哼~~~ ╭(╯^╰)╮&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// I am not responsible of this code.
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>o(╯□╰)o 这个。。。不是我干的~~~真的！！！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// it was hard to write
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// so it should be hard to read
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以不能怪我咯，代码本来就不好写，你还想我让你好读？？？ &lt;strong>╭(╯^╰)╮&lt;/strong> 来啊，互相伤害啊！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// I have to find a better job
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这位哥意识到自己职业生涯的终结了吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// If this code works, it was written by Paul DiLascia. If not, I don&amp;#39;t know
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// who wrote it
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>反正我不管，好的代码跟我有关，不好的代码肯定不是我写的！！！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Linux Sex&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ date ; unzip ; strip ; touch ; grep ; finger ; mount ; fsck ; more ; yes ; umount ; sleep
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好污的一段代码！！！天哪，我的眼睛! &lt;code>(*/ω╲*)&lt;/code>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="">long&lt;/span> &lt;span style="">long&lt;/span> ago; &lt;span style="font-style:italic">/* in a galaxy far far away */&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我有故事你有酒，我来给你讲一宿！ O(∩_∩)O&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">/**
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> * Always returns true.
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"> */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">public&lt;/span> boolean isAvailable() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> false;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我读书少，你别骗我！（这段代码据说是真的跟注释说的一样的~~~）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Dear maintainer:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Once you are done trying to &amp;#39;optimize&amp;#39; this routine,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// and have realized what a terrible mistake that was,
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// please increment the following counter as a warning
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// to the next guy:
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// total_hours_wasted_here = 42
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">//
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，这是受害者联盟吗？来来来，你掉坑里了吗？签个字登记一下吧！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c++" data-lang="c++">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">return&lt;/span> true; &lt;span style="font-style:italic">//true my ass! this doesn&amp;#39;t work
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，童话里都是骗人的 o(╯□╰)o&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// Peter wrote this, nobody knows what it does, don&amp;#39;t change it!
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>编程界网红&lt;strong>Peter&lt;/strong>又中招……&lt;/p>
&lt;p>**注意：**上面所有有趣的代码片段跟注释都是从以下帖子或者讨论中摘录，欢迎点击链接阅读原文：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="http://fuzzzyblog.blogspot.hk/2014/09/40-most-funny-code-comments.html">Fuzzzy blog: 40 most funny code comments ever&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.quora.com/What-are-some-of-the-funniest-comments-in-source-code">What are some of the funniest comments in source code?&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="写在最后">写在最后&lt;/h2>
&lt;p>大多数程序猿的日常工作繁重辛苦，加班跟高度的精神压力都是家常便饭，如果你的身边有这样的程序猿，请一定要多多珍惜他们！也祝愿看到这篇帖子的程序猿们开怀一笑，生活已经如此多艰，快快休息放松一下吧！&lt;/p></description></item><item><title>Sidekiq 信号处理源码分析</title><link>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</link><pubDate>Sun, 20 Nov 2016 10:08:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</guid><description>&lt;h3 id="引言">引言&lt;/h3>
&lt;p>在之前的文章&lt;a href="https://blog.hackerpie.com/blog/articles/2016/10/29/sidekiqren-wu-diao-du-liu-cheng-fen-xi/">《Sidekiq任务调度流程分析》&lt;/a>中，我们一起仔细分析了 Sidekiq 是如何基于多线程完成队列任务处理以及调度的。我们在之前的分析里，看到了不管是 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 还是 &lt;code>Sidekiq::Processor&lt;/code> 的核心代码里，都会有一个由 &lt;code>@done&lt;/code> 实例变量控制的循环体：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;scheduler&amp;#34;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done &lt;span style="font-style:italic"># 这是 poller 的循环控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info(&lt;span style="font-style:italic">&amp;#34;Scheduler exiting...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done &lt;span style="font-style:italic"># 这是我们常说的 worker 循环控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_died(self, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，这些 &lt;code>@done&lt;/code> 实例变量决定了 &lt;code>poller&lt;/code> 线程跟 &lt;code>worker&lt;/code> 线程是否循环执行？一旦 &lt;code>@done&lt;/code> 被改为 &lt;code>true&lt;/code>，那循环体就不再执行，线程自然也就是退出了。于是，单从这些代码，我们可以断定， Sidekiq 就是通过设置 &lt;code>@done&lt;/code> 的值来通知一个线程安全退出（graceful exit）的。我们也知道，生产环境中，我们是通过发送信号的方式来告诉 sidekiq 退出或者进入静默(quiet)状态的，那么，这里的 &lt;code>@done&lt;/code> 是怎么跟信号处理联系起来的呢？这些就是今天这篇文章的重点了！&lt;/p>
&lt;h3 id="注意">注意&lt;/h3>
&lt;ol>
&lt;li>今天的分析所参考的 sidekiq 的源码对应版本是 4.2.3；&lt;/li>
&lt;li>今天所讨论的内容，将主要围绕系统信号处理进行分析，无关细节将不赘述，如有需要，请自行翻阅 sidekiq 源码；&lt;/li>
&lt;li>今天的文章跟上篇的《Sidekiq任务调度流程分析》紧密相关，上篇文章介绍的启动过程跟任务调度会帮助这篇文章的理解，如果还没有阅读上篇文章的，建议先阅读后再来阅读这一篇信号处理的文章。&lt;/li>
&lt;/ol>
&lt;h3 id="你将了解到什么">你将了解到什么？&lt;/h3>
&lt;ol>
&lt;li>Sidekiq 信号处理机制；&lt;/li>
&lt;li>为什么重启 Sidekiq 时，&lt;code>USR1&lt;/code> 信号（即进入 &lt;code>quiet&lt;/code> 模式）需要尽可能早，而进程的退出重启需要尽可能晚。&lt;/li>
&lt;/ol>
&lt;h3 id="从头再来">从头再来&lt;/h3>
&lt;p>因为前一篇文章着眼于任务调度，所以略过了其他无关细节，包括信号处理，这篇文章则将镜头对准信号处理，所以让我们从头再来一遍，只是这一次，我们只关心与信号处理有关的代码。&lt;/p>
&lt;p>依旧是从 &lt;code>cli.rb&lt;/code> 文件开始，它是 Sidekiq 核心代码的生命起点，因为 Sidekiq 命令行启动后，它是第一个被执行的代码，Sidekiq 启动过程中调用了 &lt;code>Sidekiq::CLI#run&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L49-L106&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> boot_system
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print_banner
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self_read, self_write = IO.pipe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">%w(INT TERM USR1 USR2 TTIN)&lt;/span>.each &lt;span style="font-weight:bold">do&lt;/span> |sig|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap sig &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self_write.puts(sig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> ArgumentError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Signal &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sig&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> not supported&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ... other codes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> readable_io = IO.select([self_read])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signal = readable_io.first[0].gets.strip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handle_signal(signal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Interrupt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#39;Shutting down&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.stop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Explicitly exit so busy Processor threads can&amp;#39;t block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># process shutdown.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#34;Bye!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上的代码就是整个 Sidekiq 最顶层的信号处理的核心代码了，让我们慢慢分析！
首先，&lt;code>self_read, self_write = IO.pipe&lt;/code> 创建了一个模拟管道的 IO 对象，并且同时返回这个 管道的一个写端以及一个读端，通过这两端，就可以实现对管道的读写了。需要注意的是，&lt;code>IO.pipe&lt;/code> 创建的读端在读的时候不会自动生成 &lt;code>EOF&lt;/code> 符，所以这就要求读时，写端是关闭的，而写时，读端是关闭的，一句话说，就是这样的管道不允许读写端同时打开。关于 &lt;code>IO.pipe&lt;/code> 还有挺多细节跟需要注意的点，如果还需要了解，请阅读&lt;a href="https://ruby-doc.org/core-2.3.1/IO.html#method-c-pipe">官方文档&lt;/a>。&lt;/p>
&lt;p>上面说的管道本质上只是一个 IO 对象而已，暂时不用纠结太多，让我们接着往下读：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">%w(INT TERM USR1 USR2 TTIN)&lt;/span>.each &lt;span style="font-weight:bold">do&lt;/span> |sig|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> trap sig &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self_write.puts(sig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> ArgumentError
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Signal &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sig&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> not supported&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码就比较有意思了，最外层遍历了一个系统信号的数组，然后逐个信号进行监听（trap，或者叫捕捉？）。让我们聚焦在 &lt;code>trap&lt;/code> 方法的调用跟其 block 上，查阅 &lt;a href="https://ruby-doc.org/core-2.2.0/Signal.html#method-c-trap">Ruby 文档&lt;/a>，发现 &lt;code>trap&lt;/code> 是 &lt;code>Signal&lt;/code> 模块下的一个方法，&lt;code>Signal&lt;/code> 主要是处理与系统信号有关的任务，然后 &lt;code>trap&lt;/code> 的作用是：&lt;/p>
&lt;blockquote>
&lt;p>Specifies the handling of signals. The first parameter is a signal name (a string such as “SIGALRM”, “SIGUSR1”, and so on) or a signal number&amp;hellip;&lt;/p>
&lt;/blockquote>
&lt;p>所以，前面的那段代码的意思就很容易理解了，Sidekiq 注册了对 &lt;code>INT&lt;/code>、&lt;code>TERM&lt;/code>、&lt;code>USR1&lt;/code>、&lt;code>USR2&lt;/code>以及&lt;code>TTIN&lt;/code>等系统信号的处理，而在进程收到这些信号时，就会执行 &lt;code>self_write.puts(sig)&lt;/code>，也就是将收到的信号通过之前介绍的管道写端 &lt;code>self_write&lt;/code> 记录下来。什么？只记录下来，那还得处理啊？！&lt;/p>
&lt;p>稍安勿躁，让我们接着往下分析 &lt;code>Sidekiq::CLI#run&lt;/code> 方法末尾的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> readable_io = IO.select([self_read])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signal = readable_io.first[0].gets.strip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handle_signal(signal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Interrupt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#39;Shutting down&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.stop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Explicitly exit so busy Processor threads can&amp;#39;t block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># process shutdown.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#34;Bye!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到没有，这里有个循环，循环控制条件里，&lt;code>readable_io = IO.select([self_read])&lt;/code> 是从前面的管道的读端 &lt;code>self_read&lt;/code> 阻塞地等待信号的到达。对于 &lt;code>IO.select&lt;/code>，&lt;a href="https://ruby-doc.org/core-2.3.1/IO.html#method-c-select">Ruby 官方文档&lt;/a>介绍如下：&lt;/p>
&lt;blockquote>
&lt;p>Calls select(2) system call. It monitors given arrays of IO objects, waits until one or more of IO objects are ready for reading, are ready for writing, and have pending exceptions respectively, and returns an array that contains arrays of those IO objects.&lt;/p>
&lt;/blockquote>
&lt;p>所以这里就是说 Sidekiq 主线程首先负责执行完其他初始化工作，最后阻塞在信号等待以及处理。在其等到新的信号之后，进入上面代码展示的循环体：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>signal = readable_io.first[0].gets.strip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>handle_signal(signal)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里语法细节先不深究，我们看下这两行代码第一行是从前面说的管道中读取信号，并且将信号传递给 &lt;code>handle_signal&lt;/code> 方法，让我们接着往下看 &lt;code>handle_signal&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L125-L153&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> handle_signal(sig)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.debug &lt;span style="font-style:italic">&amp;#34;Got &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sig&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> signal&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">case&lt;/span> sig
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> &lt;span style="font-style:italic">&amp;#39;INT&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Handle Ctrl-C in JRuby like MRI&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># http://jira.codehaus.org/browse/JRUBY-4637&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> Interrupt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> &lt;span style="font-style:italic">&amp;#39;TERM&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Heroku sends TERM and then waits 10 seconds for process to exit.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> Interrupt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> &lt;span style="font-style:italic">&amp;#39;USR1&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info &lt;span style="font-style:italic">&amp;#34;Received USR1, no longer accepting new work&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> &lt;span style="font-style:italic">&amp;#39;USR2&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> Sidekiq.options[&lt;span style="font-style:italic">:logfile&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info &lt;span style="font-style:italic">&amp;#34;Received USR2, reopening log file&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq::Logging.reopen_logs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">when&lt;/span> &lt;span style="font-style:italic">&amp;#39;TTIN&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Thread.list.each &lt;span style="font-weight:bold">do&lt;/span> |thread|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.warn &lt;span style="font-style:italic">&amp;#34;Thread TID-&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>thread.object_id.to_s(36)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>thread[&lt;span style="font-style:italic">&amp;#39;label&amp;#39;&lt;/span>]&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> thread.backtrace
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.warn thread.backtrace.join(&lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.warn &lt;span style="font-style:italic">&amp;#34;&amp;lt;no backtrace available&amp;gt;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的代码挺长，但是一点都不难理解，我简单解释下就够了。当进程：&lt;/p>
&lt;ol>
&lt;li>收到 &lt;code>TERM&lt;/code> 或者 &lt;code>INT&lt;/code>信号时，直接抛出 &lt;code>Interrupt&lt;/code> 中断；&lt;/li>
&lt;li>收到 &lt;code>USR1&lt;/code> 信号时，则通知 &lt;code>launcher&lt;/code> 执行 &lt;code>.quiet&lt;/code> 方法，Sidekiq 在这里进入 Quiet 模式（怎么进入？）；&lt;/li>
&lt;li>收到 &lt;code>USR2&lt;/code> 信号时，重新打开日志；&lt;/li>
&lt;li>收到 &lt;code>TTIN&lt;/code> 信号时，打印所有线程当前正在执行的代码列表。&lt;/li>
&lt;/ol>
&lt;p>到此，一个信号从收到被存下，到被取出处理的大致过程就是这样的，至于具体的处理方式，我们下个章节详细展开。现在有一点需要补充的是，上面讲当 Sidekiq 收到 &lt;code>TERM&lt;/code> 或者 &lt;code>INT&lt;/code> 信号时，都会抛出 &lt;code>Interrupt&lt;/code> 中断异常，那这个异常又是如何处理的呢？我们回过头去看刚才最开始的 &lt;code>Sidekiq::CLI#run&lt;/code> 方法末尾的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> readable_io = IO.select([self_read])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> signal = readable_io.first[0].gets.strip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handle_signal(signal)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Interrupt
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#39;Shutting down&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.stop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Explicitly exit so busy Processor threads can&amp;#39;t block&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># process shutdown.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info &lt;span style="font-style:italic">&amp;#34;Bye!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exit(0)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原来是 &lt;code>run&lt;/code> 方法在处理信号时，声明了 &lt;code>rescue Interrupt&lt;/code>，捕捉了 &lt;code>Interrupt&lt;/code> 中断异常，并且在异常处理时打印必要日志，同时执行 &lt;code>launcher.stop&lt;/code> 通知各个线程停止工作，最后调用 &lt;code>exit&lt;/code> 方法强制退出进程，到此，一个 Sidekiq 进程就彻底退出了。
但是问题又来了，信号处理的大致过程我是知道了，但是具体的 &lt;code>launcher.quiet&lt;/code> 跟 &lt;code>launcher.stop&lt;/code> 都干了些什么呢？&lt;/p>
&lt;h3 id="sidekiqlauncherquiet-源码探索">Sidekiq::Launcher#quiet 源码探索&lt;/h3>
&lt;p>老规矩，先上代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L32-L36&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @manager.quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @poller.terminate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码只有短短三行。 Launcher 对象首先设置自己的实例变量 &lt;code>@done&lt;/code> 的值为 &lt;code>true&lt;/code>，接着执行 &lt;code>@manager.quiet&lt;/code> 以及 &lt;code>@poller.terminate&lt;/code>。看方法命名上理解，应该是 Luancher 对象又将 quiet 的消息传递给了 &lt;code>@manager&lt;/code> 即 &lt;code>Sidekiq::Manager&lt;/code> 对象，同时通知 &lt;code>@poller&lt;/code> 即 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 对象结束工作。那到底是不是真的这样呢？让我们继续深挖！&lt;/p>
&lt;h4 id="sidekiqmanagerquiet">Sidekiq::Manager#quiet&lt;/h4>
&lt;p>让我们来看看 &lt;code>Sidekiq::Manager#quiet&lt;/code> 方法的代码&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L51-L58&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> @done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info { &lt;span style="font-style:italic">&amp;#34;Terminating quiet workers&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @workers.each { |x| x.terminate }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fire_event(&lt;span style="font-style:italic">:quiet&lt;/span>, &lt;span style="">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码也很短，首先将 &lt;code>Sidekiq::Manager&lt;/code> 对象自身的 &lt;code>@done&lt;/code> 实例变量的值设置为 &lt;code>true&lt;/code>，接着对其所管理的每一个 worker，都发出一个 &lt;code>terminate&lt;/code> 消息。让我们接着往下看 worker 对象（&lt;code>Sidekiq::Processor&lt;/code> 对象）的 &lt;code>#terminate&lt;/code> 方法定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L42-L46&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> terminate(wait=&lt;span style="">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> !@thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread.value &lt;span style="font-weight:bold">if&lt;/span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的代码依然保持了精短的特点！跟上一层逻辑一样，worker 在处理 &lt;code>terminate&lt;/code> 时，同样设置自己的 &lt;code>@done&lt;/code> 实例变量为 &lt;code>true&lt;/code> 后返回，但是，如果其参数 &lt;code>wait&lt;/code> 为 &lt;code>true&lt;/code>，则会保持主线程等待，直到 &lt;code>@thread&lt;/code> 线程退出（&lt;code>@thread.value&lt;/code> 相当于执行 &lt;code>@thread.join&lt;/code>并且返回线程的返回值，可参考 &lt;a href="https://ruby-doc.org/core-2.2.0/Thread.html#method-i-value">Ruby 文档&lt;/a>）。&lt;/p>
&lt;p>那么，这里就要问了，worker 设置 &lt;code>@done&lt;/code> 为 true 是要干嘛？这里好像也没有做什么特别的事啊？！勿急，还记得上篇文章介绍 worker 运行时的核心代码吗？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_died(self, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到了吧，&lt;code>@done&lt;/code> 变量可是一个重要的开关，当 &lt;code>@done&lt;/code> 为 &lt;code>false&lt;/code> 时，worker 一直周而复始地从队列中取任务并且老老实实干活；而当 &lt;code>@done&lt;/code> 为 &lt;code>true&lt;/code> 时，worker 在处理完当前的任务之后，便不再执行新的任务，执行 &lt;code>@msg.processor_stopped(self)&lt;/code> 通知 worker 管理器自己已经退出工作，最终 &lt;code>#run&lt;/code> 方法返回。由于 &lt;code>#run&lt;/code> 方法是在独立线程里执行的，所以当 &lt;code>#run&lt;/code> 方法返回时，其所在的线程自然也就退出了。&lt;/p>
&lt;p>那关于 worker 的 quiet 模式进入过程就是这么简单，通过一个共享变量 &lt;code>@done&lt;/code> 便实现了对工作线程的控制。&lt;/p>
&lt;h4 id="sidekiqscheduledpollerterminate">Sidekiq::Scheduled::Poller#terminate&lt;/h4>
&lt;p>前面说到 &lt;code>Sidekiq::Launcher#quiet&lt;/code> 执行时，先将消息传递给了 worker 管理器，随后执行了 &lt;code>@poller.terminate&lt;/code>，那我们来看看 &lt;code>#terminate&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L53-L61&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> terminate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> @thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t = @thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread = &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @sleeper &amp;lt;&amp;lt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> t.value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>又是如此简短的代码。poller 退出的逻辑跟 worker 退出的逻辑非常一致，都是同样先设置自己的 &lt;code>@done&lt;/code> 实例变量的值为 &lt;code>true&lt;/code>，接着等待线程 &lt;code>@thread&lt;/code> 退出，最后 poller 返回。&lt;/p>
&lt;p>那么，poller 的 &lt;code>@done&lt;/code> 是不是也是用来控制线程退出呢？答案是肯定的！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;scheduler&amp;#34;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info(&lt;span style="font-style:italic">&amp;#34;Scheduler exiting...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>还记得上面这段代码吗？ poller 在每次将定时任务压回任务队列之后，等待一定时间，然后重新检查 &lt;code>@done&lt;/code> 的值，如果为 &lt;code>true&lt;/code>，则 poller 直接返回退出，因为 &lt;code>#start&lt;/code> 方法里的循环体在新线程中执行，当循环结束时，线程自然也退出了。&lt;/p>
&lt;h4 id="小结">小结&lt;/h4>
&lt;ol>
&lt;li>当 Sidekiq 收到 &lt;code>USR1&lt;/code> 系统信号时，Sidekiq 主线程向 &lt;code>@launcher&lt;/code> 发送 &lt;code>quiet&lt;/code> 消息，&lt;code>@launcher&lt;/code> 又将消息传递给 &lt;code>@manager&lt;/code> ，同时向 &lt;code>@poller&lt;/code> 发出 &lt;code>terminate&lt;/code> 消息；&lt;/li>
&lt;li>&lt;code>@manager&lt;/code> 在收到 &lt;code>quiet&lt;/code> 消息时，逐一对运行中的 worker 发送 &lt;code>terminate&lt;/code> 消息，worker 收到消息后，设置自己的 &lt;code>@done&lt;/code> 为 &lt;code>true&lt;/code>，标识不再处理新任务，当前任务处理完成后退出线程；&lt;/li>
&lt;li>&lt;code>@poller&lt;/code> 在收到 &lt;code>terminate&lt;/code> 消息后，也是设置自己的 &lt;code>@done&lt;/code> 为 &lt;code>true&lt;/code>，在本次任务执行完毕后，线程也退出；&lt;/li>
&lt;li>Sidekiq 进入 quiet 模式之后，所有未处理任务以及新任务都不再处理，直到 sidekiq 的下一次重启。&lt;/li>
&lt;/ol>
&lt;h3 id="sidekiqlauncherstop-源码探索">Sidekiq::Launcher#stop 源码探索&lt;/h3>
&lt;p>前面介绍的是 Sidekiq 进入 quiet 模式的过程，那 Sidekiq 的停止过程又是怎样的呢？&lt;/p>
&lt;p>让我们从 &lt;code>Sidekiq::Launcher#stop&lt;/code> 方法开始寻找答案：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L41-L56&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> stop
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> deadline = Time.now + @options[&lt;span style="font-style:italic">:timeout&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @manager.quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @poller.terminate
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @manager.stop(deadline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Requeue everything in case there was a worker who grabbed work while stopped&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># This call is a no-op in Sidekiq but necessary for Sidekiq Pro.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy = (@options[&lt;span style="font-style:italic">:fetch&lt;/span>] || Sidekiq::BasicFetch)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy.bulk_requeue([], @options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> clear_heartbeat
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，&lt;code>Sidekiq::Launcher&lt;/code> 对象设定了一个强制退出的 &lt;code>deadline&lt;/code>，时间是以当前时间加上配置的 &lt;code>timeout&lt;/code>，这个时间&lt;a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L23">默认是 8 秒&lt;/a>。&lt;/p>
&lt;p>接着，设定对象本身的 &lt;code>@done&lt;/code> 变量的值为 &lt;code>true&lt;/code>，然后分别对 &lt;code>@manager&lt;/code> 和 &lt;code>@poller&lt;/code> 发送 &lt;code>quiet&lt;/code> 和 &lt;code>terminate&lt;/code> 消息，这个过程就是我们上面说的 &lt;code>Sidekiq::Launcher#quiet&lt;/code> 的过程，所以，这里的代码主要是 Sidekiq 要确保退出前已经通知各个线程准备退出。&lt;/p>
&lt;p>接下来的代码就比较重要了，我们先看这一行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>@manager.stop(deadline)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在通知完 &lt;code>@manager&lt;/code> 进入 quiet 模式之后，launcher 向 &lt;code>@manager&lt;/code> 发送了 &lt;code>stop&lt;/code> 消息，并且同时传递了 &lt;code>deadline&lt;/code> 参数。让我们接着继续往下看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L61-L83&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PAUSE_TIME = STDOUT.tty? ? 0.1 : 0.5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> stop(deadline)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quiet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fire_event(&lt;span style="font-style:italic">:shutdown&lt;/span>, &lt;span style="">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># some of the shutdown events can be async,&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># we don&amp;#39;t have any way to know when they&amp;#39;re done but&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># give them a little time to take effect&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep PAUSE_TIME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> @workers.empty?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.info { &lt;span style="font-style:italic">&amp;#34;Pausing to allow workers to finish...&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remaining = deadline - Time.now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> remaining &amp;gt; PAUSE_TIME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> @workers.empty?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sleep PAUSE_TIME
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remaining = deadline - Time.now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> @workers.empty?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hard_shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码，manager 首先调用了自身的 &lt;code>quiet&lt;/code> 方法（这里就真的多此一举了，因为外层的 launcher 已经调用过一次了），然后 manager 执行 &lt;code>sleep&lt;/code> 系统调用进入休眠，持续时间为 0.5 秒，休眠结束后检查所有 worker 是否已经都退出，如果退出，则直接返回，任务提前结束；如果仍有 worker 未退出，则检查当前时间是否接近强制退出的 deadline，如果不是，则重复“检查所有 worker 退出 - 休眠” 的过程，直到 deadline 来临，或者 worker 线程都已经全部退出。如果最后到达 deadline，仍有 worker 线程未退出，则最后执行 &lt;code>hard_shutdown&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L108-L135&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> hard_shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cleanup = &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @plock.synchronize &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cleanup = @workers.dup
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> cleanup.size &amp;gt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jobs = cleanup.map {|p| p.job }.compact
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ... other codes&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy = (@options[&lt;span style="font-style:italic">:fetch&lt;/span>] || Sidekiq::BasicFetch)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> strategy.bulk_requeue(jobs, @options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cleanup.each &lt;span style="font-weight:bold">do&lt;/span> |processor|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> processor.kill
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里 &lt;code>hard_shutdown&lt;/code> 方法在执行时，首先克隆了当前仍未退出的 &lt;code>@workers&lt;/code> 列表，接着获取每个 worker 当前正在处理的任务，将这些正在执行中的任务数据通过 &lt;code>strategy.bulk_requeue(jobs, @options)&lt;/code> 重新写回队列，而最后对每一个 worker 发送 &lt;code>kill&lt;/code> 消息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L48-L58&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> kill(wait=&lt;span style="">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> !@thread
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread.raise ::Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread.value &lt;span style="font-weight:bold">if&lt;/span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>worker 在收到 &lt;code>kill&lt;/code> 消息时，首先设置自己的 &lt;code>@done&lt;/code> 为 &lt;code>true&lt;/code>，最后向 worker 所关联的线程抛出 &lt;code>::Sidekiq::Shutdown&lt;/code> 异常。让我们看看 worker 的线程又是如何处理异常的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_died(self, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>又回到 worker 的 &lt;code>run&lt;/code> 方法这里，可以看到，&lt;code>run&lt;/code> 方法捕捉了 &lt;code>Sidekiq::Shutdown&lt;/code> 异常，并且在处理异常时，只是执行 &lt;code>@mgr.processor_stopped(self)&lt;/code>，通知 manager 自己已经退出，由于已经跳出正常流程，worker 的 &lt;code>run&lt;/code> 方法返回，线程也因此得以退出。至此，worker 也都正常退出了。&lt;/p>
&lt;h4 id="小结-1">小结&lt;/h4>
&lt;ol>
&lt;li>launcher 在执行退出时，首先按照 quiet 的流程先通知各个线程准备退出；&lt;/li>
&lt;li>接着 launcher 向 manager 下达 &lt;code>stop&lt;/code> 指令，并且给出最后期限（&lt;code>deadline&lt;/code>）；&lt;/li>
&lt;li>manager 在给定的限时内，尽可能等待所有 worker 执行完自己退出，对于到达限时仍未退出的 worker，manager 备份了每个 worker 的当前任务，重新加入队列，确保任务至少完整执行一次，然后通过向线程抛出异常的方式，迫使 worker 的线程被动退出。&lt;/li>
&lt;/ol>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ol>
&lt;li>Sidekiq 简单高效利用了系统信号，并且有比较清晰明了的信号处理过程；&lt;/li>
&lt;li>Sidekiq 在信号处理的过程中，各个组件协调很有条理，消息逐级传递，而且对被强制停止的任务也有备份方案；&lt;/li>
&lt;li>我们可以从 Sidekiq 的系统信号处理机制上借鉴不少东西，比如常用系统信号的分类处理等；&lt;/li>
&lt;li>对于多线程的控制，通过共享变量以及异常的方式做到 &lt;code>graceful&lt;/code> 以及 &lt;code>hard&lt;/code> 两种方式的退出处理。&lt;/li>
&lt;li>还有很多，一百个人心中有一百个哈姆莱特，同样一份代码，不同的人学习阅读，肯定收获不同，你可以在评论区留下你的感悟，跟看到这篇文章的人一起分享！&lt;/li>
&lt;/ol>
&lt;h3 id="问题思考">问题思考&lt;/h3>
&lt;ol>
&lt;li>为了尽可能确保所有 Sidekiq 的任务能够正常主动退出，所以在部署脚本中，都会尽可能早地让 Sidekiq 进入 quiet 模式，但是 Sidekiq 的 quiet 是不可逆的，所以一旦部署脚本中途失败，Sidekiq 得不到重启，将会一直保持 quiet 状态，如果长时间未重启，任务就会积压。所以，一般我都会在部署脚本中，额外捕捉部署脚本失败异常，然后主动执行 sidekiq 的重启。&lt;strong>如果你的部署脚本中有涉及 Sidekiq 的，一定要注意检查部署失败是否会影响 Sidekiq 的状态&lt;/strong>&lt;/li>
&lt;li>虽然 Sidekiq 在强制退出当前长时间未退出的任务时，会将 job 的数据写回队列，等待重启后重新执行，那么这里就有个细节需要注意了，就是你的 job 必须是幂等的，否则就不能允许重新执行了。所以，请注意，&lt;strong>如果你有需要长时间运行的 job，请注意检查其幂等性&lt;/strong>。&lt;/li>
&lt;/ol>
&lt;p>好了，今天就写到这吧！仍然挺长一篇，啰嗦了。感谢看到这里！&lt;/p></description></item><item><title>sidekiq任务调度流程分析</title><link>https://blog.hackerpie.com/posts/archive/sidekiqren-wu-diao-du-liu-cheng-fen-xi/</link><pubDate>Sat, 29 Oct 2016 16:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sidekiqren-wu-diao-du-liu-cheng-fen-xi/</guid><description>&lt;p>&lt;a href="http://sidekiq.org/">sidekiq&lt;/a>是 Ruby 中一个非常优秀而且可靠的后台任务处理软件，其依赖 Redis 实现队列任务的增加、重试以及调度等。而 sidekiq 从启动到开始不断处理任务、定时任务以及失败任务的重试，都是如何调度的呢？遇到问题的时候，又该如何调优呢？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="注意">注意&lt;/h3>
&lt;ol>
&lt;li>今天的分析所参考的 sidekiq 的源码对应版本是 4.2.3；&lt;/li>
&lt;li>今天所讨论的内容，将主要围绕任务调度过程进行分析，无关细节将不赘述，如有需要，请自行翻阅 sidekiq 源码；&lt;/li>
&lt;li>文章内容真的很长，请做好心理准备。&lt;br>
&lt;img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/0fc8f347a4c7cba67066b2527bdb8f94.png!large" alt="">
&lt;/li>
&lt;/ol>
&lt;h3 id="你将了解到什么">你将了解到什么？&lt;/h3>
&lt;ol>
&lt;li>sidekiq 的任务调度机制：定时任务、重试任务的检查机制，队列任务的排队以及队列权重对处理优先级的影响；&lt;/li>
&lt;li>sidekiq 的中间件机制以及在此基础上实现的任务重试机制。&lt;/li>
&lt;/ol>
&lt;h2 id="先抛结论">先抛结论&lt;/h2>
&lt;h3 id="时序图">时序图&lt;/h3>
&lt;p>对于复杂的调用关系，我习惯用时序图帮助我理解其中各部分代码之间相互协作的关系（注意：为了避免太多细节造成阅读负担，我将参数传递以及返回值等冗杂过程去除了，只保留与任务调度相关的关键调用）：
![sidekiq 任务调度时序图](/images/medias/sidekiq job dispatcher.png)&lt;/p>
&lt;h3 id="人话">人话&lt;/h3>
&lt;p>Sidekiq 整个任务调度过程中依赖几个不同角色的代码共同协作，其分工如下：
&lt;img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/fe43bace416ba3bb7f7d77b397683bf4.png!large" alt="">
&lt;/p>
&lt;h2 id="源码之旅--启动">源码之旅 —— 启动&lt;/h2>
&lt;p>当我们在执行 &lt;code>sidekiq&lt;/code> 时，源码中的 &lt;code>bin/sidekiq.rb&lt;/code> 文件便是第一个开始执行的文件，让我们看看&lt;a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12">里边的主要代码&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli = Sidekiq::CLI.instance
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli.parse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli.run &lt;span style="font-style:italic"># &amp;lt;===== 这边走&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>紧靠 &lt;code>begin&lt;/code> 后边的两行代码首先创建 &lt;code>Sidekiq::CLI&lt;/code> 类的一个实例，接着调用实例方法 &lt;code>#parse&lt;/code> 解析 sidekiq 的配置参数，其中包括队列的配置、worker 数量的配置等，在此不展开了。接着实例方法 &lt;code>#run&lt;/code> 将带着我们继续往下走，让我们继续看 &lt;code>lib/sidekiq/cli.rb&lt;/code> 里边的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L46-L106&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 这里打印控制台欢迎信息、打印日志以及运行环境（不同 Rails 版本）加载等&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> require &lt;span style="font-style:italic">&amp;#39;sidekiq/launcher&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @launcher = Sidekiq::Launcher.new(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launcher.run &lt;span style="font-style:italic"># &amp;lt;===== 这边走&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 进程接收到的信号处理以及退出处理&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码主要是实例化了一个 &lt;code>Sidekiq::Launcher&lt;/code> 的对象，紧随其后又调用了实例方法 &lt;code>#run&lt;/code>，所以让我们继续顺藤摸瓜，看看 &lt;code>Sidekiq::Launcher#run&lt;/code> 方法到底做了哪些事情？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L24-L28&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread = safe_thread(&lt;span style="font-style:italic">&amp;#34;heartbeat&amp;#34;&lt;/span>, &amp;amp;method(&lt;span style="font-style:italic">:start_heartbeat&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @poller.start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @manager.start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>#run&lt;/code> 方法首先通过 &lt;code>safe_thread&lt;/code> 创建了一个新的线程，线程主要负责执行 &lt;code>start_heartbeat&lt;/code> 方法的代码，从方法名称上，我们猜测其主要是心跳代码，负责定时检查 sidekiq 健康状态，跟之前一样，这里不往下挖，我们继续看后边的两行代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>@poller.start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@manager.start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>@poller&lt;/code> 跟 &lt;code>@manager&lt;/code> 都是什么呢？让我们回头看一下，前面讲到 &lt;code>lib/cli.rb&lt;/code> 的 &lt;code>#run&lt;/code> 方法会负责创建 &lt;code>Sidekiq::Launcher&lt;/code> 的实例，那让我们看下后者的 &lt;code>initialize&lt;/code> 方法定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/launcher.rb#L17-L22&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initialize(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @manager = Sidekiq::Manager.new(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @poller = Sidekiq::Scheduled::Poller.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @options = options
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，实际上，&lt;code>@manager&lt;/code>是在创建 &lt;code>Sidekiq::Launcher&lt;/code> 实例的过程中同步创建的 &lt;code>Sidekiq::Manager&lt;/code> 的实例，同理，&lt;code>@poller&lt;/code> 是同步创建的 &lt;code>Sidekiq::Scheduled::Poller&lt;/code>的实例。那我们按照代码执行顺序，先看下 &lt;code>@poller.start&lt;/code> 也就是 &lt;code>Sidekiq::Scheduled::Poller#start&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;scheduler&amp;#34;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info(&lt;span style="font-style:italic">&amp;#34;Scheduler exiting...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里看到，&lt;code>#start&lt;/code>方法也创建了一个线程，在线程里执行了两个部分代码：1. 初始化等待；2. 循环里的 &lt;code>enqueue&lt;/code> 与 &lt;code>wait&lt;/code>。这都是什么呢？&lt;/p>
&lt;p>&lt;strong>注意&lt;/strong>: &lt;code>#start&lt;/code> 方法在线程创建完成后就立刻返回了，至于 &lt;code>#start&lt;/code> 方法里的逻辑，请移步后面章节“继续深挖 Sidekiq::Scheduled::Poller#start”作更深一步分析。这里，我们先继续接着看看 &lt;code>#start&lt;/code> 方法返回后接下来执行的 &lt;code>@manager.start&lt;/code> 方法又做了什么：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L45-L49&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @workers.each &lt;span style="font-weight:bold">do&lt;/span> |x|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x.start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>@workers&lt;/code> 又是什么？一个数组？怎样的数组？我们回顾下，前面说在创建 &lt;code>Sidekiq::Launcher&lt;/code> 实例的过程中同步创建了 &lt;code>Sidekiq::Manager&lt;/code> 的实例，让我们就看看 &lt;code>Sidekiq::Manager&lt;/code> 的 &lt;code>#initialize&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L31-L43&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initialize(options={})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.debug { options.inspect }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @options = options
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @count = options[&lt;span style="font-style:italic">:concurrency&lt;/span>] || 25
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> ArgumentError, &lt;span style="font-style:italic">&amp;#34;Concurrency of &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>@count&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> is not supported&amp;#34;&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> @count &amp;lt; 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @done = &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @workers = Set.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @count.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @workers &amp;lt;&amp;lt; Processor.new(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @plock = Mutex.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，在创建了 &lt;code>Sidekiq::Manager&lt;/code> 的实例之后，又同步创建了多个 &lt;code>Sidekiq::Processor&lt;/code> 的实例，实例的个数取决于 &lt;code>options[:concurrency] || 25&lt;/code>，也就是配置的 &lt;code>:concurrency&lt;/code> 的值，缺省值为 &lt;code>25&lt;/code>。至此，我们知道，sidekiq 中的 worker 的数量就是在此其作用的，&lt;code>Sidekiq::Manager&lt;/code> 按照配置的数量创建指定数量的 worker。
往回看刚才的 &lt;code>#start&lt;/code> 方法中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/manager.rb#L46-L48&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@workers.each &lt;span style="font-weight:bold">do&lt;/span> |x|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> x.start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>简言之，就是 &lt;code>Sidekiq::Manager&lt;/code> 在 &lt;code>start&lt;/code> 的时候只做一件事：分别调用其管理的所有 worker 的 &lt;code>#start&lt;/code> 方法，也就是 &lt;code>Sidekiq::Processor#start&lt;/code>。继续往下走：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L60-L62&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;processor&amp;#34;&lt;/span>, &amp;amp;method(&lt;span style="font-style:italic">:run&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>又是我们熟悉的 &lt;code>safe_thread&lt;/code> 方法，同样是创建了一个新的线程，意味着每一个 worker 都是基于自己的一个新线程的，而这个线程里执行的代码是私有方法 &lt;code>#run&lt;/code> 里的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_died(self, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以发现，又是一个 while 循环！而这个循环体里只调用了一个 &lt;code>#process_one&lt;/code> 实例方法，顾名思义，这里是说每个 worker 在没被结束之前，都重复每次处理一个新的任务，那这个 &lt;code>#process_one&lt;/code> 里又做了什么呢？怎么决定该先做哪个任务呢？别急，请看后面章节“继续深挖 Sidekiq::Processor#process_one”。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>sidekiq 在启动后（此处可借文章开头的时序图辅助理解）：&lt;/p>
&lt;ol>
&lt;li>首先创建了 &lt;code>Sidekiq::CLI&lt;/code> 的实例，并调用其 &lt;code>run&lt;/code> 方法；&lt;/li>
&lt;li>&lt;code>Sidekiq::CLI&lt;/code> 的实例在 &lt;code>#run&lt;/code> 的过程中，创建了 &lt;code>Sidekiq::Launcher&lt;/code> 的实例，并调用其 &lt;code>run&lt;/code> 方法；&lt;/li>
&lt;li>&lt;code>Sidekiq::Launcher&lt;/code> 的实例在创建后，同步创建了一个 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 的实例以及 &lt;code>Sidekiq::Manager&lt;/code> 的实例，而在其执行 &lt;code>#run&lt;/code> 的过程中，则分别调用了这两个实例的 &lt;code>start&lt;/code> 方法；&lt;/li>
&lt;li>&lt;code>Sidekiq::Scheduled::Poller&lt;/code> 的实例在执行 &lt;code>start&lt;/code> 过程中，创建了一个内部循环执行的线程，周而复始地执行 &lt;code>enqueue&lt;/code> -&amp;gt; &lt;code>wait&lt;/code>；&lt;/li>
&lt;li>&lt;code>Sidekiq::Manager&lt;/code> 的实例在创建后，同步创建若干个指定的 worker，也就是 &lt;code>Sidekiq::Processor&lt;/code> 的实例，并在执行 &lt;code>start&lt;/code> 方法的过程中对每一个 worker 发起 &lt;code>start&lt;/code> 调用；&lt;/li>
&lt;li>&lt;code>Sidekiq::Processor&lt;/code> 实例在执行 &lt;code>start&lt;/code> 方法的过程中创建了一个新的线程，新的线程里同样有一个 &lt;code>while&lt;/code> 循环，反复执行 &lt;code>process_one&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>以上就是 Sidekiq 的主要启动过程，以下分别针对 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 以及 &lt;code>Sidekiq::Manager&lt;/code> 展开源码分析。&lt;/p>
&lt;h2 id="定时任务拉取器的工作-sidekiqscheduledpollerstart">定时任务拉取器的工作 Sidekiq::Scheduled::Poller#start&lt;/h2>
&lt;p>经过前面较表层的代码分析，我们接下来继续展开 &lt;code>Sidekiq::Scheduled::Poller#start&lt;/code> 方法的探索之旅，首先重温下其代码定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;scheduler&amp;#34;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info(&lt;span style="font-style:italic">&amp;#34;Scheduler exiting...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，&lt;code>#start&lt;/code> 方法的核心就是中间的 &lt;code>while&lt;/code> 循环，在循环前面，执行了 &lt;code>#initial_wait&lt;/code> 方法，让我们先看看这个方法到底是干些什么的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L133-L143&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Have all processes sleep between 5-15 seconds. 10 seconds&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># to give time for the heartbeat to register (if the poll interval is going to be calculated by the number&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># of workers), and 5 random seconds to ensure they don&amp;#39;t all hit Redis at the same time.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total = 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total += INITIAL_WAIT &lt;span style="font-weight:bold">unless&lt;/span> Sidekiq.options[&lt;span style="font-style:italic">:poll_interval_average&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> total += (5 * rand)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @sleeper.pop(total)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Timeout::Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结合注释理解，原来私有方法 &lt;code>#initial_wait&lt;/code> 只是为了避免所有进程在后续逻辑中同时触发 Redis IO 而做的设计，如果对大型系统有过架构经验的童鞋就会明白，这里其实就是为了防止类似雪崩之类的系统故障出现。让当前进程随机等待一定范围的时间，从而就可以跟其他进程错开了。&lt;/p>
&lt;p>在理解完 &lt;code>initial_wait&lt;/code> 之后，我们接着看到循环体里的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L68-L69&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>wait
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>enqueue&lt;/code>？干嘛呢？为什么是入队列呢？带着疑问往下看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L75-L86&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @enq.enqueue_jobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里看到 &lt;code>#enqueue&lt;/code> 代码非常简单，只是调用了实例变量 &lt;code>@enq&lt;/code> 的 &lt;code>#enqueue_jobs&lt;/code> 方法而已，那么，&lt;code>@enq&lt;/code> 是什么类型的实例呢？它的 &lt;code>#enqueue_jobs&lt;/code> 方法又做了什么呢？让我们回过头来看一遍 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 的 &lt;code>#initialize&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L45-L50&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initialize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @enq = (Sidekiq.options[&lt;span style="font-style:italic">:scheduled_enq&lt;/span>] || Sidekiq::Scheduled::Enq).new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @sleeper = ConnectionPool::TimedStack.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>原来缺省情况下，&lt;code>@enq&lt;/code> 就是 &lt;code>Sidekiq::Scheduled::Enq&lt;/code> 的实例。而代码上看的话，sidekiq 支持用户通过 &lt;code>:scheduled_enq&lt;/code> 配置项自定义 &lt;code>@enq&lt;/code> 的类型，但是官方文档未对此参数提及以及说明，这里其实是一种策略模式的实现，用户自定义的类型必须实现 &lt;code>enqueue_jobs&lt;/code> 方法。我估计，是 sidekiq pro 里边才会用到的配置项吧。&lt;/p>
&lt;p>知道了 &lt;code>@enq&lt;/code> 的类型后，让我们继续看下 &lt;code>Sidekiq::Scheduled::Enq#enqueue_jobs&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L11-L33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> enqueue_jobs(now=Time.now.to_f.to_s, sorted_sets=SETS)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># A job&amp;#39;s &amp;#34;score&amp;#34; in Redis is the time at which it should be processed.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Just check Redis for the set of jobs with a timestamp before now.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.redis &lt;span style="font-weight:bold">do&lt;/span> |conn|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted_sets.each &lt;span style="font-weight:bold">do&lt;/span> |sorted_set|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Get the next item in the queue if it&amp;#39;s score (time to execute) is &amp;lt;= now.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># We need to go through the list one at a time to reduce the risk of something&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># going wrong between the time jobs are popped from the scheduled queue and when&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># they are pushed onto a work queue and losing the jobs.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> job = conn.zrangebyscore(sorted_set, &lt;span style="font-style:italic">&amp;#39;-inf&amp;#39;&lt;/span>.freeze, now, &lt;span style="font-style:italic">:limit&lt;/span> =&amp;gt; [0, 1]).first &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Pop item off the queue and add it to the work queue. If the job can&amp;#39;t be popped from&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># the queue, it&amp;#39;s because another process already popped it so we can move on to the&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># next one.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> conn.zrem(sorted_set, job)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq::Client.push(Sidekiq.load_json(job))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq::Logging.logger.debug { &lt;span style="font-style:italic">&amp;#34;enqueued &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sorted_set&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">: &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>job&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实这里这个方法的寓意，通过代码里的注释都已经很明晰了，不过我觉得还是有几个点需要强调下。
首先，在无参数调用 &lt;code>#enqueue_jobs&lt;/code> 方法时，定义中的参数 &lt;code>now&lt;/code> 缺省为当前时间，而 &lt;code>sorted_sets&lt;/code> 缺省为 &lt;code>Sidekiq::Scheduled::SETS&lt;/code> 的值，其值定义为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SETS = &lt;span style="font-style:italic">%w(retry schedule)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是数组 &lt;code>[&amp;quot;retry&amp;quot;, &amp;quot;schedule&amp;quot;]&lt;/code>，而这两个队列名称所对应的队列就是 sidekiq 的重试以及定时任务队列，在 sidekiq 里边，重试任务以及定时任务本质上都是 scheduled jobs，这两个队列使用了特殊的 Redis 的数据结构，进入队列的任务以其执行时间作为数据的 score，写入 Redis 之后按照 score 排序，也就是按任务的计划时间排序。&lt;/p>
&lt;p>接着往下看：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L14-L30&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sidekiq.redis &lt;span style="font-weight:bold">do&lt;/span> |conn|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sorted_sets.each &lt;span style="font-weight:bold">do&lt;/span> |sorted_set|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> job = conn.zrangebyscore(sorted_set, &lt;span style="font-style:italic">&amp;#39;-inf&amp;#39;&lt;/span>.freeze, now, &lt;span style="font-style:italic">:limit&lt;/span> =&amp;gt; [0, 1]).first &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> conn.zrem(sorted_set, job)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq::Client.push(Sidekiq.load_json(job))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq::Logging.logger.debug { &lt;span style="font-style:italic">&amp;#34;enqueued &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sorted_set&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">: &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>job&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，sidekiq 分别针对 &lt;code>&amp;quot;retry&amp;quot;&lt;/code> 和 &lt;code>&amp;quot;schedule&amp;quot;&lt;/code> 队列做了一个循环，循环体里每次通过 Redis 的 &lt;a href="http://redis.io/commands/ZRANGEBYSCORE">&lt;code>ZRANGEBYSCORE&lt;/code>&lt;/a>命令取出一个计划时间小于等于当前时间的任务，并且调用 &lt;code>Sidekiq::Client&lt;/code> 的 &lt;code>.push&lt;/code> 方法将此任务加到指定队列中（job 中包含队列名称等信息，在此不展开，有兴趣的同学请自行阅读 &lt;code>Sidekiq::Client&lt;/code> 的代码）。&lt;/p>
&lt;p>至此，可以明白，&lt;code>enqueue_jobs&lt;/code> 就是分别从 &lt;code>&amp;quot;retry&amp;quot;&lt;/code> 和 &lt;code>&amp;quot;schedule&amp;quot;&lt;/code> 队列中取出已经到达计划时间的任务，将其一一加入原来队列。注意，定时任务以及重试任务的计划时间只是计划加进执行中队列的时间，并非执行时间，执行的时间就只能取决于队列的长度以及队列执行速度了。&lt;/p>
&lt;p>接着往回点，继续看 &lt;code>enqueue_jobs&lt;/code> 之后的 &lt;code>wait&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L90-L100&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @sleeper.pop(random_poll_interval)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Timeout::Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># expected&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里的 &lt;code>wait&lt;/code> 方法只是做一个休眠，休眠的实现依赖于 &lt;code>@sleeper&lt;/code> 的 &lt;code>#pop&lt;/code> 方法调用，回顾 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 的 &lt;code>#initialize&lt;/code> 方法的实现可以确认 &lt;code>@sleeper&lt;/code> 是 &lt;code>ConnectionPool::TimedStack&lt;/code> 的实例，而后者是 Ruby gem &lt;a href="https://github.com/mperham/connection_pool/blob/master/lib/connection_pool/timed_stack.rb">connection_pool&lt;/a> 里的实现，其 &lt;code>pop&lt;/code> 方法会阻塞当前代码的执行，直到有值返回或者到达指定的超时时间，这里 sidekiq 利用了其阻塞的特性，作为 &lt;code>wait&lt;/code> 方法休眠器的实现。&lt;/p>
&lt;p>而代码里的休眠时间则不是固定的，依赖 &lt;code>#random_poll_interval&lt;/code> 方法的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L103-L105&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Calculates a random interval that is ±50% the desired average.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> random_poll_interval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> poll_interval_average * rand + poll_interval_average.to_f / 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实现依赖一个 &lt;code>#poll_interval_average&lt;/code> 方法的返回值，顾名思义，这个方法将决定定时任务定期检查的平均时间周期。让我们继续深挖下去：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L107-L122&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># We do our best to tune the poll interval to the size of the active Sidekiq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># cluster. If you have 30 processes and poll every 15 seconds, that means one&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Sidekiq is checking Redis every 0.5 seconds - way too often for most people&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># and really bad if the retry or scheduled sets are large.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Instead try to avoid polling more than once every 15 seconds. If you have&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># 30 Sidekiq processes, we&amp;#39;ll poll every 30 * 15 or 450 seconds.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># To keep things statistically random, we&amp;#39;ll sleep a random amount between&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># 225 and 675 seconds for each poll or 450 seconds on average. Otherwise restarting&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># all your Sidekiq processes at the same time will lead to them all polling at&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># the same time: the thundering herd problem.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># We only do this if poll_interval_average is unset (the default).&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> poll_interval_average
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.options[&lt;span style="font-style:italic">:poll_interval_average&lt;/span>] ||= scaled_poll_interval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法的重要性通过其几倍于代码的注释就可以看出来，大概意思是，sidekiq 为了避免在进程重启后，有大量的进程同时密集地访问 redis，所以设计了这个机制，就是每个进程对定时任务的检查都是按照一个公式来计算的，保证每个进程两次检查之间的平均休眠时间能够在一个范围内动态变化，从而将所有进程的 Redis IO 均匀错开。
从代码上看，sidekiq 的这个平均拉取时间支持配置项配置，但是目前也并没有在 wiki 上有所提及。而缺省情况下，其值由方法 &lt;code>#scaled_poll_interval&lt;/code> 决定：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L124-L131&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> scaled_poll_interval
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pcount = Sidekiq::ProcessSet.new.size
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pcount = 1 &lt;span style="font-weight:bold">if&lt;/span> pcount == 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pcount * Sidekiq.options[&lt;span style="font-style:italic">:average_scheduled_poll_interval&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>正如前面一段代码的注释所说，缺省情况下，sidekiq 认为定时任务拉取器的平均休眠时间正是：&lt;/p>
&lt;pre tabindex="0">&lt;code>sidekiq 进程数量 x 平均拉取时间 average_scheduled_poll_interval
&lt;/code>&lt;/pre>&lt;p>而 &lt;code>:average_scheduled_poll_interval&lt;/code> 的缺省配置是 15 秒：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/master/lib/sidekiq.rb#L25&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>DEFAULTS = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">average_scheduled_poll_interval&lt;/span>: 15,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以回过头来，在没有相关自定义配置的情况下，假设你只开启了一个 sidekiq 进程，那么 sidekiq 的定时任务拉取器的拉取时间平均间隔为 1 x 15 = 15 秒，那按照上面的 &lt;code>#random_poll_interval&lt;/code> 方法的定义，则实际每次拉取的时间间隔则是在 7.5 秒到 22.5 秒之间！&lt;/p>
&lt;h3 id="小结-1">小结&lt;/h3>
&lt;p>从这个章节的分析，我们可以明白 Sidekiq 对定时任务和重试任务是一视同仁的，其处理流程都是：&lt;/p>
&lt;ol>
&lt;li>所有定时任务（包括重试任务，本质上重试任务也是定时的，后边会单独讲解）以其计划时间为 score，加入特殊的 &lt;code>&amp;quot;retry&amp;quot;&lt;/code> 或 &lt;code>&amp;quot;schedule&amp;quot;&lt;/code> 有序队列中；&lt;/li>
&lt;li>sidekiq 的定时任务拉取器从 &lt;code>&amp;quot;retry&amp;quot;&lt;/code> 和 &lt;code>&amp;quot;schedule&amp;quot;&lt;/code> 队列中一一取出已到达计划时间的任务，将其加入该任务计划的队列中，后续的执行则跟其他普通队列中的任务一致；&lt;/li>
&lt;li>拉取器休眠一定时间（&lt;code>random_poll_interval&lt;/code>）后，从步骤 2 重新开始，周而复始。&lt;/li>
&lt;/ol>
&lt;p>所以，定时任务的计划时间不是确切的任务时间！只是允许加回队列的时间，具体执行时间还得另外看队列长度以及队列处理速度！&lt;/p>
&lt;h2 id="sidekie-worker-的秘密-sidekiqprocessorprocess_one">Sidekie worker 的秘密： Sidekiq::Processor#process_one&lt;/h2>
&lt;p>前面我们分析过 sidekiq 的 worker 的核心代码就是在线程里循环执行 &lt;code>#process_one&lt;/code> 方法，那么这个方法到底做了些什么啊？别急，现在就来一探究竟：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @job = fetch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(@job) &lt;span style="font-weight:bold">if&lt;/span> @job
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @job = &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码中，&lt;code>#process_one&lt;/code> 先通过 &lt;code>#fetch&lt;/code> 方法获取一个任务，当任务获取成功后，就将其作为参数调用 &lt;code>#process&lt;/code> 方法，完成对任务的处理；如果没有获取到任务，则直接重新尝试获取新的任务。&lt;/p>
&lt;p>首先让我们看看 &lt;code>#fetch&lt;/code> 方法的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L96-L104&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> fetch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j = get_one &lt;span style="font-style:italic"># 吐槽一下这个 `j` 变量，命名真的不敢恭维，这个库就这里写得不雅&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> j &amp;amp;&amp;amp; @done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j.requeue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>#fetch&lt;/code> 方法通过 &lt;code>#get_one&lt;/code> 方法从队列中获取任务，当获取到任务后，判断当前 worker 是否已经停止(&lt;code>@done&lt;/code> 为 &lt;code>true&lt;/code>)，是则将任务重新压回队列。&lt;/p>
&lt;p>让我们接着看 &lt;code>#get_one&lt;/code> 方法的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L85-L94&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> get_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> work = @strategy.retrieve_work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (logger.info { &lt;span style="font-style:italic">&amp;#34;Redis is online, &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>Time.now - @down&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> sec downtime&amp;#34;&lt;/span> }; @down = &lt;span style="">nil&lt;/span>) &lt;span style="font-weight:bold">if&lt;/span> @down
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handle_fetch_exception(ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>核心代码则是 &lt;code>work = @strategy.retrieve_work&lt;/code>，为了了解 &lt;code>@strategy&lt;/code>，我们仍旧往回看&lt;code>#initialize&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L32-L40&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initialize(mgr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @strategy = (mgr.options[&lt;span style="font-style:italic">:fetch&lt;/span>] || Sidekiq::BasicFetch).new(mgr.options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>又是一个策略模式，缺省下，使用了 &lt;code>Sidekiq::BasicFetch&lt;/code> 生成实例，并且通过实例变量 &lt;code>@strategy&lt;/code> 引用。&lt;/p>
&lt;p>回到前面的 &lt;code>@strategy.retrieve_work&lt;/code>，让我们继续看看 &lt;code>Sidekiq::BasicFetch#retrieve_work&lt;/code> 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L35-L38&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> retrieve_work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> work = Sidekiq.redis { |conn| conn.brpop(*queues_cmd) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UnitOfWork.new(*work) &lt;span style="font-weight:bold">if&lt;/span> work
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过上面的代码，可以知道 &lt;code>Sidekiq::BasicFetch&lt;/code> 的取任务逻辑比较直接，是通过 Redis 的 &lt;a href="http://redis.io/commands/brpop">&lt;code>BRPOP&lt;/code> 命令&lt;/a>从“所有队列”中阻塞地取出第一个任务：&lt;/p>
&lt;blockquote>
&lt;p>BRPOP is a blocking list pop primitive. It is the blocking version of RPOP because it blocks the connection when there are no elements to pop from any of the given lists. An element is popped from the tail of the first list that is non-empty, with the given keys being checked in the order that they are given.&lt;/p>
&lt;/blockquote>
&lt;p>所以，理解了 &lt;code>BRPOP&lt;/code> 命令的工作细节之后，我们把注意力缩放到 &lt;code>#queues_cmd&lt;/code> 方法上：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L40-L53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> queues_cmd
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> @strictly_ordered_queues
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @queues
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queues = @queues.shuffle.uniq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queues &amp;lt;&amp;lt; TIMEOUT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queues
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，代码中检查了 &lt;code>@strictly_ordered_queues&lt;/code> 这个实例变量的值，让我们回头看下这个变量的值的来源，也就是 &lt;code>#initialize&lt;/code> 方法的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/d8f11c26518dbe967880f76fd23bb99e9d2411d5/lib/sidekiq/fetch.rb#L26-L33&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> initialize(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @strictly_ordered_queues = !!options[&lt;span style="font-style:italic">:strict&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @queues = options[&lt;span style="font-style:italic">:queues&lt;/span>].map { |q| &lt;span style="font-style:italic">&amp;#34;queue:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>q&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> @strictly_ordered_queues
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @queues = @queues.uniq
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @queues &amp;lt;&amp;lt; TIMEOUT
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>缺省情况下，此值为 &lt;code>false&lt;/code>。所以让我们看 &lt;code>#queues_cmd&lt;/code> 方法的 &lt;code>else&lt;/code> 分支里的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>queues = @queues.shuffle.uniq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而这里的 &lt;code>@queues&lt;/code> 就是来自 &lt;code>options[:queues]&lt;/code> 中的配置： &lt;code>options[:queues].map { |q| &amp;quot;queue:#{q}&amp;quot; }&lt;/code>。那么，这个 &lt;code>options[:queues]&lt;/code> 的值又是什么呢？
让我们一步一步沿着调用链上参数往回走：&lt;/p>
&lt;ol>
&lt;li>&lt;code>Sidekiq::BasicFetch.new&lt;/code> 的参数 &lt;code>options&lt;/code> 来自 worker 在 &lt;code>Sidekiq::Processor#initialize&lt;/code> 方法中的参数 &lt;code>mgr&lt;/code> 的 &lt;code>options&lt;/code> 属性；&lt;/li>
&lt;li>worker 的 mgr 参数正是 &lt;code>Sidekiq::Manager&lt;/code> 的实例，其 &lt;code>options&lt;/code> 属性则是 &lt;code>Sidekiq::Launcher&lt;/code> 创建 &lt;code>Sidekiq::Manager&lt;/code> 实例时传入的 &lt;code>options&lt;/code> 变量；&lt;/li>
&lt;li>而 &lt;code>Sidekiq::Launcher#initialize&lt;/code> 接收到的 &lt;code>options&lt;/code> 变量则是更外层的 &lt;code>Sidekiq::CLI&lt;/code> 的实例方法 &lt;code>options&lt;/code> 的值；&lt;/li>
&lt;li>而 &lt;code>Sidekiq::CLI&lt;/code> 的实例的 &lt;code>options&lt;/code> 则是在其接收到 &lt;code>#parse&lt;/code> 调用时设置的。
为了节省篇幅，省略这里其中的太多调用栈，我们直接看最根源代码：&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/cli.rb#L389-L399&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> parse_queues(opts, queues_and_weights)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queues_and_weights.each { |queue_and_weight| parse_queue(opts, *queue_and_weight) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> parse_queue(opts, q, weight=&lt;span style="">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [weight.to_i, 1].max.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (opts[&lt;span style="font-style:italic">:queues&lt;/span>] ||= []) &amp;lt;&amp;lt; q
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> opts[&lt;span style="font-style:italic">:strict&lt;/span>] = &lt;span style="">false&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> weight.to_i &amp;gt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，sidekiq 在解析 &lt;code>:queues&lt;/code> 的相关配置时，按照每个队列以及其权重，生成了一个重复次数等于队列权重的队列的新数组，假设用户提供如下配置：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">:queues&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - default
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - [myqueue, 2]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>则此处生成的 &lt;code>options[:queues]&lt;/code> 则为 &lt;code>[&amp;quot;default&amp;quot;, &amp;quot;myqueue&amp;quot;, &amp;quot;myqueue&amp;quot;]&lt;/code>。所以，这里权重主要用于后边确定各个不同队列被处理到的优先权的比重。&lt;/p>
&lt;p>了解了 &lt;code>@queues&lt;/code> 的来源之后，我们回到最开始讨论的地方：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>queues = @queues.shuffle.uniq
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，每次 worker 在请求新的任务时，sidekiq 都按照原来的 &lt;code>@queues&lt;/code> 执行 &lt;code>shuffle&lt;/code> 方法，而 &lt;code>shuffle&lt;/code> 则表示将数组元素重新随机排序，亦即“洗牌”。结合前面的权重，那么每个队列洗牌后排在第一位的概率与其权重挂钩。最后的 &lt;code>#uniq&lt;/code> 方法确保队列名称没有重复，避免 Redis 在执行 &lt;code>BRPOP&lt;/code> 命令时重复检查同一队列。这里使用 &lt;code>BRPOP&lt;/code> 还有个好处就是，加入当前面优先的队列里边没有任务时，可以依次将机会让给后面的队列。&lt;/p>
&lt;p>而后边的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>queues &amp;lt;&amp;lt; TIMEOUT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>则是在命令末尾追加超时设定，即 Redis 的 &lt;code>BRPOP&lt;/code> 命令最多阻塞 2 秒，超时则直接放弃。&lt;/p>
&lt;p>了解了任务的获取之后，我们接着看 sidekiq 如何处理获取到的任务，回到 &lt;code>retrieve_work&lt;/code> 的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/fetch.rb#L36-L37&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>work = Sidekiq.redis { |conn| conn.brpop(*queues_cmd) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>UnitOfWork.new(*work) &lt;span style="font-weight:bold">if&lt;/span> work
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到在获取到任务之后，任务通过 &lt;code>Sidekiq::BasicFetch::UnitOfWork&lt;/code> 结构体实例化后返回给调用方。&lt;/p>
&lt;p>直接回到 &lt;code>Sidekiq::Processor#process_one&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L79-L83&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @job = fetch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process(@job) &lt;span style="font-weight:bold">if&lt;/span> @job
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @job = &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以明白，@job 就是返回的 &lt;code>UnitOfWork&lt;/code> 实例，那么 &lt;code>process(@job)&lt;/code> 会做些什么呢？&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L118-L152&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> process(work)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> jobstr = work.job
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> queue = work.queue_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @reloader.call &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ack = &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> job = Sidekiq.load_json(jobstr)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass = job[&lt;span style="font-style:italic">&amp;#39;class&amp;#39;&lt;/span>.freeze].constantize
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker = klass.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker.jid = job[&lt;span style="font-style:italic">&amp;#39;jid&amp;#39;&lt;/span>.freeze]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stats(worker, job, queue) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.server_middleware.invoke(worker, job, queue) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Only ack if we either attempted to start this job or&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># successfully completed it. This prevents us from&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># losing jobs if a middleware raises an exception before yielding&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ack = &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> execute_job(worker, cloned(job[&lt;span style="font-style:italic">&amp;#39;args&amp;#39;&lt;/span>.freeze]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面代码中，sidekiq 从 &lt;code>work&lt;/code> 中获取任务的相关信息，包括队列名称，任务对应的类型（&lt;code>job['class'.freeze]&lt;/code>）、任务调用所需的参数等，根据这些信息重新实例化任务对象，并且将实例化的任务对象 &lt;code>worker&lt;/code> 以及任务参数都传递给对 &lt;code>execute_job&lt;/code> 的调用。让我们看看 &lt;code>#execute_job&lt;/code> 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L154-L156&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> execute_job(worker, cloned_args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker.perform(*cloned_args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看到了吧？我们最熟悉的 &lt;code>#perform&lt;/code> 方法！这下知道我们为什么需要在每个 sidekiq Worker 或者 ActiveJob 的 Job 类中定义这个方法了吧？因为这个方法就是最终任务执行时所需调用的方法，这就是约定！&lt;/p>
&lt;p>至此，任务的调度过程就到此为止了，剩下的就是周而复始的重复了。&lt;/p>
&lt;h3 id="小结-2">小结&lt;/h3>
&lt;p>经过上面的分析，我们可以明白 sidekiq 中 worker 的工作流程：&lt;/p>
&lt;ol>
&lt;li>按照所有队列以及其权重，每次重新排列待处理队列顺序，高权重的队列有更高的优先级；&lt;/li>
&lt;li>将重新排好的队列顺序传递给 Redis 的 BRPOP 命令，同时设置 2 秒超时；&lt;/li>
&lt;li>sidekiq 将从队列中获取到的任务实例化，并且根据携带的参数调用了任务的 &lt;code>#perform&lt;/code> 方法。&lt;/li>
&lt;/ol>
&lt;p>等等，上面都只是正常流程，那如果任务执行过程中出错了怎么办？？？重试的机制是如何运转的呢？&lt;/p>
&lt;h2 id="重试机制基于中间件的实现">重试机制：基于中间件的实现&lt;/h2>
&lt;p>**注意：**阅读本章节前，建议先阅读官方 Wiki 的 &lt;a href="https://github.com/mperham/sidekiq/wiki/Error-Handling">Error Handling&lt;/a>。&lt;/p>
&lt;p>细心的童鞋肯定发现了上面的 &lt;code>Sidekiq::Processor#process&lt;/code> 方法中有个关键的代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L131-L137&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Sidekiq.server_middleware.invoke(worker, job, queue) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> execute_job(worker, cloned(job[&lt;span style="font-style:italic">&amp;#39;args&amp;#39;&lt;/span>.freeze]))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个 &lt;code>server_middleware&lt;/code> 是什么呢？让我们来简单过一下吧：&lt;/p>
&lt;p>全局搜索了代码，发现 &lt;code>Sidekiq.server_middleware&lt;/code> 的来源是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L140-L144&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> &lt;span style="font-weight:bold">self&lt;/span>.server_middleware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @server_chain ||= default_server_middleware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">yield&lt;/span> @server_chain &lt;span style="font-weight:bold">if&lt;/span> block_given?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @server_chain
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>缺省情况下，&lt;code>.server_middleware&lt;/code> 依赖 &lt;code>.default_server_middleware&lt;/code> 的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L146-L154&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> &lt;span style="font-weight:bold">self&lt;/span>.default_server_middleware
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Middleware::Chain.new &lt;span style="font-weight:bold">do&lt;/span> |m|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m.add Middleware::Server::Logging
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> m.add Middleware::Server::RetryJobs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以明白 &lt;code>Sidekiq.default_server_middleware&lt;/code> 返回一个 &lt;code>Middleware::Chain&lt;/code> 实例，并且调用了其 &lt;code>#add&lt;/code> 方法将 &lt;code>Middleware::Server::Logging&lt;/code> 以及 &lt;code>Middleware::Server::RetryJobs&lt;/code> 两个中间件加到中间件的 Chain 上。此中间件的实现以及实现类似 rackup，有兴趣的童鞋自行&lt;a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/chain.rb">阅读源码&lt;/a>，在此不展开，让我们直接跳到 &lt;code>Middleware::Server::RetryJobs&lt;/code> 的 &lt;code>call&lt;/code> 方法中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L73-L84&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> call(worker, msg, queue)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">yield&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ignore, will be pushed back onto queue during hard_shutdown&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; e
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ignore, will be pushed back onto queue during hard_shutdown&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> Sidekiq::Shutdown &lt;span style="font-weight:bold">if&lt;/span> exception_caused_by_shutdown?(e)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> e &lt;span style="font-weight:bold">unless&lt;/span> msg[&lt;span style="font-style:italic">&amp;#39;retry&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attempt_retry(worker, msg, queue, e)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们聚焦方法的最后一行代码 &lt;code>attempt_retry(worker, msg, queue, e)&lt;/code>，此处表示当执行中的任务出现异常时，除去停机的因素以及禁用了重试机制后，尝试进行下次重试运行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L88-L137&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attempt_retry(worker, msg, queue, exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> max_retry_attempts = retry_attempts_from(msg[&lt;span style="font-style:italic">&amp;#39;retry&amp;#39;&lt;/span>], @max_retries)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> count = &lt;span style="font-weight:bold">if&lt;/span> msg[&lt;span style="font-style:italic">&amp;#39;retry_count&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg[&lt;span style="font-style:italic">&amp;#39;retried_at&amp;#39;&lt;/span>] = Time.now.to_f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg[&lt;span style="font-style:italic">&amp;#39;retry_count&amp;#39;&lt;/span>] += 1
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg[&lt;span style="font-style:italic">&amp;#39;failed_at&amp;#39;&lt;/span>] = Time.now.to_f
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> msg[&lt;span style="font-style:italic">&amp;#39;retry_count&amp;#39;&lt;/span>] = 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> count &amp;lt; max_retry_attempts
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay = delay_for(worker, count, exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.debug { &lt;span style="font-style:italic">&amp;#34;Failure! Retry &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>count&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> in &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>delay&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> seconds&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> retry_at = Time.now.to_f + delay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload = Sidekiq.dump_json(msg)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.redis &lt;span style="font-weight:bold">do&lt;/span> |conn|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> conn.zadd(&lt;span style="font-style:italic">&amp;#39;retry&amp;#39;&lt;/span>, retry_at.to_s, payload)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Goodbye dear message, you (re)tried your best I&amp;#39;m sure.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> retries_exhausted(worker, msg, exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从上面的代码中看出，sidekiq 在捕捉到异常后，首先检查此任务此前是否已经重试过，是的话，则在重试累计次数上加 1，更新最后重试时间；否则初始化重试累计次数为 0，设定初次失败时间。接着，sidekiq 检查重试累计次数是否超过限定最大重试次数，是的话则放弃重试，任务从此不再重试，进入 Dead 状态，sidekiq 抛出异常；否则计算任务下次重试时间，将任务按照计划的下次重试时间加到 &lt;code>retry&lt;/code> 有序队列中，最后抛出异常。关于重试任务的检查跟执行，请阅读前面的相关章节，接下来我们主要分析 sidekiq 如何计算任务的下次重试时间 &lt;code>delay&lt;/code>。&lt;/p>
&lt;p>让我们展开对 &lt;code>#delay_for&lt;/code> 方法的探索：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L172-L174&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> delay_for(worker, count, exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> worker.sidekiq_retry_in_block? &amp;amp;&amp;amp; retry_in(worker, count, exception) || seconds_to_delay(count)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先了解下 &lt;code>worker.sidekiq_retry_in_block?&lt;/code> 的定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L32&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>base.class_attribute &lt;span style="font-style:italic">:sidekiq_retry_in_block&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其定义了每个 Worker 类的 &lt;code>sidekiq_retry_in_block&lt;/code> 属性，而其又可以通过 Worker 类的 &lt;code>#sidekiq_retry_in&lt;/code> 方法完成赋值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/worker.rb#L96-L98&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> sidekiq_retry_in(&amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.sidekiq_retry_in_block = block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>回过头来，前面的&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>worker.sidekiq_retry_in_block? &amp;amp;&amp;amp; retry_in(worker, count, exception) || seconds_to_delay(count)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>表示当具体的 Worker 配置了 &lt;code>:sidekiq_retry_in_block&lt;/code> 时，则直接使用这个配置的 block 执行的值作为失败任务下次重试的时间间隔；否则使用缺省的计算公式：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/middleware/server/retry_jobs.rb#L177-L179&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> seconds_to_delay(count)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (count ** 4) + 15 + (rand(30)*(count+1))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>count&lt;/code> 为任务累计重试次数，从公式上看，随着失败重试次数的累计增加，任务的下次重试时间间隔也会指数式增长，按照官方文档说法：&lt;/p>
&lt;blockquote>
&lt;p>Sidekiq will retry failures with an exponential backoff using the formula (retry_count ** 4) + 15 + (rand(30) * (retry_count + 1)) (i.e. 15, 16, 31, 96, 271, &amp;hellip; seconds + a random amount of time). It will perform 25 retries over approximately 21 days.&lt;/p>
&lt;/blockquote>
&lt;p>更多失败任务重试的相关配置请看文档：&lt;a href="https://github.com/mperham/sidekiq/wiki/Error-Handling#configuration">Error Handling: Configuration&lt;/a>。&lt;/p>
&lt;h3 id="小结-3">小结&lt;/h3>
&lt;ol>
&lt;li>sidekiq 在执行任务时，通过自行实现的中间件架构以及对应的简单的中间件，及时捕捉失败的任务，针对允许再次重试的任务，按失败次数计算新的重试时间，缺省为指数增长的时间间隔；&lt;/li>
&lt;li>用户可以通过配置修改缺省的公式，也可以指定最大重试次数等。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>注意&lt;/strong>：结合失败任务捕捉处理以及重试任务的检查，缺省情况下，一个首次失败任务下次重回队列（不是执行）的理论最大时间间隔大概是 67.5 秒！（固定的 15 秒 + 最大随机时间 30 秒 + 最大理论检查时间 22.5 秒）。所以，如果你的任务很重要，又需要尽快重试，就需要对几部分时间的相关配置参数进行调优了哦！在我自己的工作中，我针对某个队列任务设置的 &lt;code>sidekiq_retry_in&lt;/code> 公式为线性时间，即1s、2s、&amp;hellip;50s，然后在重试检查那里设置了 &lt;code>:poll_interval_average&lt;/code> 为 5 秒，新的下次执行时间理论最大时间间隔就是 8.5 秒！不过这些配置需要慎重调整，综合考虑业务以及业务量，既要尽可能保证任务尽早处理完，又得保证 Redis 没被 IO 压垮。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;h3 id="关于-sidekiq-项目代码">关于 sidekiq 项目代码&lt;/h3>
&lt;ol>
&lt;li>sidekiq 的源码比较简洁，很少看到长方法定义，大部分方法都在几行之内，读的过程中非常舒服；&lt;/li>
&lt;li>sidekiq 的注释也很充足，比较重要又比较核心的代码都有大量详细的注释跟例子，除此之外大部分重点在 Wiki 中都有提及，非常好的一份代码库；&lt;/li>
&lt;li>sidekiq 将 Redis 的各种数据结构用得都恰到好处，可以通过 sidekiq 加深对 Redis 的印象以及学习到如何恰当高效地结合 Redis 实现业务逻辑；&lt;/li>
&lt;li>正是因为 sidekiq 将 Redis 充分利用以及高度结合，我终于理解 sidekiq 的作者为什么表示 sidekiq 不考虑其他数据库了；&lt;/li>
&lt;li>sidekiq 的代码没有太多花俏的代码，非常推荐各位童鞋仔细研读。&lt;/li>
&lt;/ol>
&lt;h3 id="关于源码阅读">关于源码阅读&lt;/h3>
&lt;ol>
&lt;li>带着问题去阅读，效率通常很高；&lt;/li>
&lt;li>读的过程中适当放弃无关细节，只追击与问题相关的线索；&lt;/li>
&lt;li>有些文档中没有提及的配置项，往往都藏匿在代码之中；&lt;/li>
&lt;li>只有充分了解了工具的运行机制，在遇到问题调优的时候才能得心应手。&lt;/li>
&lt;/ol>
&lt;h3 id="最后">最后&lt;/h3>
&lt;p>如果你能从头看到这里，那么非常感谢你的时间，毕竟这篇文章确实不短，尽管我已经尽量去除无用的部分，一些代码也直接跳过了，但是系统得了解一个框架或者一个软件，确实也是很多细节。&lt;/p>
&lt;p>这是今年第二篇博客，今年的产出远不比去年，然而去年的产出远不比千年，所以，可能这篇也是今年最后一篇了。洋洋洒洒几万字，从下午两三点写到现在，七个多小时，难得可以静下心来写这么多，哎，这两年心态太浮躁，技术路上，还是继续保持“stay foolish, stay hungry”的好。&lt;/p></description></item><item><title>嘿，小心你的双等号==</title><link>https://blog.hackerpie.com/posts/archive/pay-attention-to-your-double-equals/</link><pubDate>Sun, 17 Jan 2016 01:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/pay-attention-to-your-double-equals/</guid><description>&lt;p>前两天在写代码的时候，突然收到警告说项目代码中存在 XSS 漏洞，遂立即根据报告的 URL 排查页面代码，虽然很快就修复了，而且同样问题的讨论两年前就有了，看&lt;a href="https://ruby-china.org/topics/16633">RubyChina: 别用 raw 和 html_safe&lt;/a>，一般来说相对有经验的老鸟也应该都知道这个点，但是还是觉得有必要写出来，再次提醒一下其他小伙伴，避免踩坑。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="问题根源">问题根源&lt;/h2>
&lt;p>其中，在找到的漏洞出现的地方，都存在类似以下这样的 slim 代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value==params[&lt;span style="font-style:italic">:account&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题就出在双等号 &lt;code>==&lt;/code> 上，因为在 &lt;strong>slim&lt;/strong> 跟 &lt;strong>ERB&lt;/strong> 模板（其他模板比如 HAML 之类的就不清楚了）中，双等号其实是 Rails 的 &lt;code>raw&lt;/code> 这个 helper 方法的缩写，&lt;a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html#output-safety">参考链接&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>To insert something verbatim use the raw helper rather than calling html_safe:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>&amp;lt;%= raw @cms.current_template %&amp;gt; &amp;lt;%# inserts @cms.current_template as is %&amp;gt;
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>or, equivalently, use &lt;code>&amp;lt;%==&lt;/code>:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>&amp;lt;%== @cms.current_template %&amp;gt; &amp;lt;%# inserts @cms.current_template as is %&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>也就是说上面的代码等同于：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value=raw(params[&lt;span style="font-style:italic">:account&lt;/span>])
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中 &lt;code>raw&lt;/code> 方法在 &lt;a href="http://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw">Rails 文档&lt;/a>中的解释是这样子的：&lt;/p>
&lt;blockquote>
&lt;p>This method outputs without escaping a string. Since escaping tags is now default, this can be used when you don&amp;rsquo;t want Rails to automatically escape tags. This is not recommended if the data is coming from the user&amp;rsquo;s input.&lt;/p>
&lt;/blockquote>
&lt;p>大概意思就是，这个方法将会跳过对传入的字符串进行标签过滤以及其他处理，直接将字符串输出到 HTML 中。&lt;br>
所以到现在原因就很清晰了，因为不小心在代码里多加了一个等号，变成了双等号，导致将会直接把用户的输入输出到待渲染的 HTML 中，在不自知的情况下留下了 XSS 漏洞。于是乎，修复方案仅需去掉一个等号即可：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value=params[&lt;span style="font-style:italic">:account&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样，Rails 就能继续自动过滤输入的 &lt;code>:account&lt;/code> 的参数并且自动过滤恶意内容了。&lt;/p>
&lt;h2 id="rawstringhtml_safe-以及--">raw、String#html_safe 以及 &amp;lt;%== %&amp;gt;&lt;/h2>
&lt;p>在查看 &lt;code>raw&lt;/code> 方法的文档时，顺便看了其源码，极其简单，只有一行：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># File actionview/lib/action_view/helpers/output_safety_helper.rb, line 16&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> raw(stringish)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stringish.to_s.html_safe
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>raw&lt;/code> 只是先确保将 &lt;code>stringish&lt;/code> 参数转化为字符串，然后调用了 &lt;a href="http://api.rubyonrails.org/classes/String.html#method-i-html_safe">&lt;code>String#html_safe&lt;/code>&lt;/a> 方法而已。而且在 &lt;code>String#html_safe&lt;/code> 的文档中，同样反复强调慎重使用这两个方法：&lt;/p>
&lt;blockquote>
&lt;p>It will be inserted into HTML with no additional escaping performed. It is your responsibilty to ensure that the string contains no malicious content. This method is equivalent to the &lt;code>raw&lt;/code> helper in views.&lt;/p>
&lt;/blockquote>
&lt;p>所以，可以总结一下，以下三种写法的代码都是等价的，都是不安全的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value==params[&lt;span style="font-style:italic">:account&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value=raw(params[&lt;span style="font-style:italic">:account&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value=params[&lt;span style="font-style:italic">:account&lt;/span>].html_safe
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>那在切实需要输出包含 HTML 内容比如富文本编辑器编辑的内容时，如何保证安全？&lt;br>
方案很简单，只需要使用文档中推荐的 &lt;a href="http://api.rubyonrails.org/classes/ActionView/Helpers/SanitizeHelper.html#method-i-sanitize">&lt;code>sanitize&lt;/code>&lt;/a> helper 方法：&lt;/p>
&lt;blockquote>
&lt;ol>
&lt;li>It is recommended that you use &lt;code>sanitize&lt;/code> instead of this method(html_safe).&lt;/li>
&lt;li>(#sanitize)Sanitizes HTML input, stripping all tags and attributes that aren&amp;rsquo;t whitelisted.&lt;/li>
&lt;/ol>
&lt;/blockquote>
&lt;p>或者使用一些其他第三方的 gem 用来做过滤处理。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;ol>
&lt;li>不要使用双等号缩写的方式，以避免其他人（比如项目里的 Rails 新手）在不了解的情况下照着滥用；&lt;/li>
&lt;li>尽可能不用 &lt;code>raw&lt;/code> helper 或者 &lt;code>String#html_safe&lt;/code> 方法，尽可能使用 &lt;code>#sanitize&lt;/code>；&lt;/li>
&lt;li>多借助工具进行自动扫描，比如 &lt;a href="http://brakemanscanner.org/">&lt;code>brakeman&lt;/code>&lt;/a>，能够快速高效检测出包括 XSS 漏洞在内的多种安全隐患。&lt;/li>
&lt;/ol>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://ruby-china.org/topics/16633">别用 raw 和 html_safe&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://brakemanscanner.org/">BrakemanScanner&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://guides.rubyonrails.org/active_support_core_extensions.html#safe-strings">Rails Guides: Safe Strings&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://wiki.open.qq.com/wiki/Web%E6%BC%8F%E6%B4%9E%E6%A3%80%E6%B5%8B%E5%8F%8A%E4%BF%AE%E5%A4%8D#1.2_XSS.E6.BC.8F.E6.B4.9E">腾讯开放平台：XSS漏洞&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Cross-site_scripting">Wikipedia: Cross-site scripting&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://api.rubyonrails.org/classes/ActionView/Helpers/OutputSafetyHelper.html#method-i-raw">Rails API: #raw&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://api.rubyonrails.org/classes/String.html#method-i-html_safe">Rails API: String#html_safe&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>谨防 ActiveSupport::Cache::Store 缓存 nil 值</title><link>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</link><pubDate>Fri, 30 Oct 2015 20:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</guid><description>&lt;p>Rails 中的 &lt;strong>&lt;a href="https://github.com/rails/rails/tree/master/activesupport">active_support&lt;/a>&lt;/strong> 组件主要基于 Rails 需要提供了很多非常有用的基础工具以及对 Ruby 内置类进行扩展。其中的 cache 模块主要提供了 Rails 中底层缓存的定义以及简单实现。今天要跟大家探讨的是之前在使用此模块所遇到的一个坑，有兴趣学习其基本用法的可以点击以下两个链接：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store">Rails Guides: ActiveSupport::Cache::Store&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html">Rails API: ActiveSupport::Cache::Store&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h3 id="从-activesupportcachestorefetch-聊起">从 ActiveSupport::Cache::Store#fetch 聊起&lt;/h3>
&lt;p>之前在实现一个需要从外部服务请求数据的功能时，处于性能考虑，我在代码中使用了缓存，并且设置缓存失效时间为 7 天，示例代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> read_external_service(params)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 这段代码稍微解释下：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 当缓存命中时，则直接读取缓存，如果无期待缓存，则通过 HTTP 向外请求结果，并且将结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 缓存下来，这样子，当下次继续调用时，则可直接返回缓存内容，而无需重复向外请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rails.cache.fetch &lt;span style="font-style:italic">&amp;#39;example_cache_key_here&amp;#39;&lt;/span>, &lt;span style="font-style:italic">expires_in&lt;/span>: 7.days &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response = HTTParty.get &lt;span style="font-style:italic">&amp;#39;https://example.com/example/request/path&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.parse(response.body)[&lt;span style="font-style:italic">&amp;#34;data&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码其实不复杂，核心代码就是使用了 &lt;a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch">&lt;code>ActiveSupport::Cache::Store#fetch&lt;/code>&lt;/a> 方法。&lt;/p>
&lt;p>一切都很正常地运行着，直到有一天，线上系统不断报警，出错原因就是这段代码总是返回 &lt;code>nil&lt;/code> ，而调用者又因为没有判断 &lt;code>nil&lt;/code> 值，就会出现 &lt;code>undefined method 'xxx' for nil:NilClass&lt;/code> 错误。在 debug 时，我尝试了直接调用外部服务接口，发现请求都有正确返回数据，不可能返回 &lt;code>nil&lt;/code> 啊，难道是缓存了 &lt;code>nil&lt;/code> 值？下面就直接通过代码验证一下！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>[1] pry(main)&amp;gt; require &lt;span style="font-style:italic">&amp;#39;active_support&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[2] pry(main)&amp;gt; cache = ActiveSupport::Cache::MemoryStore.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &amp;lt;&lt;span style="font-style:italic">#ActiveSupport::Cache::MemoryStore entries=0, size=0, options={}&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[3] pry(main)&amp;gt; cache.read &lt;span style="font-style:italic">:nil_value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[4] pry(main)&amp;gt; cache.exist? &lt;span style="font-style:italic">:nil_value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)&amp;gt; cache.fetch &lt;span style="font-style:italic">:nil_value&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)* &lt;span style="">nil&lt;/span> &lt;span style="font-style:italic"># this `nil` value will be cached&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)* &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[6] pry(main)&amp;gt; cache.read &lt;span style="font-style:italic">:nil_value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[7] pry(main)&amp;gt; cache.exist? &lt;span style="font-style:italic">:nil_value&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>看吧， &lt;code>fetch&lt;/code> 方法确实会缓存 &lt;code>nil&lt;/code> 值（通过 &lt;code>exist?&lt;/code> 方法可以判断是否缓存了指定的 key ），所以系统出错原因就清晰了：在某次代码执行中，我的缓存刚好失效了，所以系统向外部发送了请求，恰巧这时候外部系统因为故障或者其他可能原因，没有返回期待数据，导致代码中最终缓存了 &lt;code>nil&lt;/code> 值，在接下来的时间里，虽然外部系统可能恢复了正确服务，可是这时候因为我们的系统已经缓存了 &lt;code>nil&lt;/code>值，所以在每次调用时都返回缓存的 &lt;code>nil&lt;/code>，而不是重新请求正确结果，导致最后不停的报错告警。&lt;/p>
&lt;p>这里插播一句，通过后来仔细查阅文档，才发现文档里已经注明：&lt;/p>
&lt;blockquote>
&lt;p>Nil values can be cached.&lt;/p>
&lt;/blockquote>
&lt;p>&lt;strong>╮(╯▽╰)╭ 怪我咯~&lt;/strong>&lt;/p>
&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>意识到这个问题之后，解决思路简单粗暴，就是在可能返回 &lt;code>nil&lt;/code> 值的地方放弃写入缓存：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> read_external_service(params)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cache_key = &lt;span style="font-style:italic">&amp;#39;example_cache_key_here&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = Rails.cache.read(cache_key)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 缓存命中，且内容不为 nil ，直接返回缓存内容&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> result &lt;span style="font-weight:bold">if&lt;/span> result.present?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 缓存失效，只能重新请求了~&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response = HTTParty.get &lt;span style="font-style:italic">&amp;#39;https://example.com/example/request/path&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = JSON.parse(response.body)[&lt;span style="font-style:italic">&amp;#34;data&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 请求结果正确，写入缓存；否则，放弃之~~~&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rails.cache.write(cache_key, result, &lt;span style="font-style:italic">expires_in&lt;/span>: 7.days) &lt;span style="font-weight:bold">if&lt;/span> result.present?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>呃~~~虽然解决问题了，可是，就为了告诉系统不要相信 &lt;code>nil&lt;/code>，就写得这么繁琐，好么？好么？好么？&lt;/p>
&lt;h3 id="踏上阅读源码之路">踏上阅读源码之路&lt;/h3>
&lt;p>我尝试搜索了 &lt;code>#fetch&lt;/code> 方法是否有支持比如 &lt;code>reject_nil&lt;/code> 这样的 option，可惜的是，没有！可是真的没有吗？我不信！看源码去！&lt;/p>
&lt;p>首先还是拜访下 &lt;a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L154">&lt;code>ActiveSupport::Cache::Store&lt;/code>&lt;/a> 这个类啦，它可是所有缓存实现类的抽象类，别问我抽象类是什么，就是它明明只说话不干活，但是其他干活的都得向它看齐！好啦，说人话，其实就是说，我们在调用 &lt;code>Rails.cache.read&lt;/code>、&lt;code>Rails.cache.fetch&lt;/code> 等读写方法时，这些方法都是在 &lt;code>ActiveSupport::Cache::Store&lt;/code> 中定义的，但是它只定义逻辑，而实际底层的读写实现，则都是交由其各种子类实现的，比如前面的 &lt;code>ActiveSupport::Cache::MemoryStore&lt;/code>。&lt;/p>
&lt;p>首先让我们来看看 &lt;a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L275">&lt;code>fetch&lt;/code>&lt;/a>方法的全部内容：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> fetch(name, options = &lt;span style="">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> block_given?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options = merged_options(options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = namespaced_key(name, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> instrument(&lt;span style="font-style:italic">:read&lt;/span>, name, options) &lt;span style="font-weight:bold">do&lt;/span> |payload|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cached_entry = read_entry(key, options) &lt;span style="font-weight:bold">unless&lt;/span> options[&lt;span style="font-style:italic">:force&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload[&lt;span style="font-style:italic">:super_operation&lt;/span>] = &lt;span style="font-style:italic">:fetch&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> entry = handle_expired_entry(cached_entry, key, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> entry
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload[&lt;span style="font-style:italic">:hit&lt;/span>] = &lt;span style="">true&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> get_entry_value(entry, name, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload[&lt;span style="font-style:italic">:hit&lt;/span>] = &lt;span style="">false&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> save_block_result_to_cache(name, options) { |_name| &lt;span style="font-weight:bold">yield&lt;/span> _name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> read(name, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>从代码中可以看到，当 &lt;code>#fetch&lt;/code> 方法调用时没有传递 block 的话，它本质上就是 &lt;code>read&lt;/code> 方法的别名而已。而当调用时传递了 block 的话，即如我前面的示例代码，让我们把代码分开看下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>cached_entry = read_entry(key, options) &lt;span style="font-weight:bold">unless&lt;/span> options[&lt;span style="font-style:italic">:force&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>payload[&lt;span style="font-style:italic">:super_operation&lt;/span>] = &lt;span style="font-style:italic">:fetch&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>entry = handle_expired_entry(cached_entry, key, options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它首先判断是否设置了 &lt;code>force&lt;/code> 选项，如果有，则不读取缓存，由此模拟缓存强制失效；如果未设置 &lt;code>force&lt;/code> 选项或者该选项不等于 true value，则尝试读取缓存，并且调用 &lt;a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L564-L578">&lt;code>handle_expired_entry&lt;/code>&lt;/a>判断缓存是否仍旧有效。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> entry
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload[&lt;span style="font-style:italic">:hit&lt;/span>] = &lt;span style="">true&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> get_entry_value(entry, name, options)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这三行代码，则是在缓存命中时，直接读取缓存内容并且返回。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> payload[&lt;span style="font-style:italic">:hit&lt;/span>] = &lt;span style="">false&lt;/span> &lt;span style="font-weight:bold">if&lt;/span> payload
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> save_block_result_to_cache(name, options) { |_name| &lt;span style="font-weight:bold">yield&lt;/span> _name }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>else&lt;/code> 的代码则表示，在缓存无命中时， &lt;code>#fetch&lt;/code> 代码直接调用 &lt;a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L585-L592">&lt;code>#save_block_result_to_cache&lt;/code>&lt;/a> 方法，并且向其传递了一个 block，这个 block 没有干别的事情，它只会执行我们传递给 &lt;code>#fetch&lt;/code> 方法的 block，让我们接着往下看看相关的实现：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> save_block_result_to_cache(name, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = instrument(&lt;span style="font-style:italic">:generate&lt;/span>, name, options) &lt;span style="font-weight:bold">do&lt;/span> |payload|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">yield&lt;/span>(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write(name, result, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，&lt;code>#save_block_result_to_cache&lt;/code> 方法首先执行传递进来的代码块，实际上也就是我们期待在缓存失效时执行的代码，而在获得执行结果 &lt;code>result&lt;/code> 后，方法通过调用 &lt;a href="https://github.com/rails/rails/blob/edd33c08d98723ae9bb89cf7f019277117ed6414/activesupport/lib/active_support/cache.rb#L384-L391">&lt;code>#write&lt;/code>&lt;/a> 方法将结果写入缓存，最后将 &lt;code>result&lt;/code> 返回。&lt;/p>
&lt;p>通过上面的源码分析，我们可以知道，当缓存失效时，&lt;code>#fetch&lt;/code> 方法会直接将其代码块中的代码的返回值&lt;strong>不加判断&lt;/strong>地写入缓存，并且返回该返回值。这里，或许我们可以做点什么，来实现我们想要支持 &lt;code>:reject_nil&lt;/code> 的需求？&lt;/p>
&lt;h3 id="支持-reject_nil-option">支持 &lt;code>:reject_nil&lt;/code> option&lt;/h3>
&lt;p>为了支持 &lt;code>:reject_nil&lt;/code>，我们只需要在写入缓存前判断是否真的需要 &lt;code>nil&lt;/code> 值即可，于是我们只需要在 &lt;code>#save_block_result_to_cache&lt;/code> 中加入 &lt;code>#write&lt;/code> 的前置条件：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> save_block_result_to_cache(name, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = instrument(&lt;span style="font-style:italic">:generate&lt;/span>, name, options) &lt;span style="font-weight:bold">do&lt;/span> |payload|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">yield&lt;/span>(name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># options[:reject_nil] &amp;amp;&amp;amp; result.nil? 作为前置条件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> write(name, result, options) &lt;span style="font-weight:bold">unless&lt;/span> result.nil? &amp;amp;&amp;amp; options[&lt;span style="font-style:italic">:reject_nil&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>话不多说，让我们来重新试验一番：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>[1] pry(main)&amp;gt; require &lt;span style="font-style:italic">&amp;#39;active_support&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[2] pry(main)&amp;gt; cache = ActiveSupport::Cache::MemoryStore.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &amp;lt;&lt;span style="font-style:italic">#ActiveSupport::Cache::MemoryStore entries=0, size=0, options={}&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[3] pry(main)&amp;gt; cache.fetch &lt;span style="font-style:italic">:nil_key1&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[3] pry(main)* &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[3] pry(main)* &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[4] pry(main)&amp;gt; cache.exist? &lt;span style="font-style:italic">:nil_key1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)&amp;gt; cache.fetch &lt;span style="font-style:italic">:nil_key2&lt;/span>, &lt;span style="font-style:italic">reject_nil&lt;/span>: &lt;span style="">true&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)* &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[5] pry(main)* &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[6] pry(main)&amp;gt; cache.exist? &lt;span style="font-style:italic">:nil_key2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，当我们调用 &lt;code>#fetch&lt;/code> 方法时，如果没有传递 &lt;code>reject_nil: true&lt;/code>，则 &lt;code>#fetch&lt;/code> 方法会默认缓存 &lt;code>nil&lt;/code> 值；而如果我们设置 &lt;code>reject_nil: true&lt;/code> 的话，则 &lt;code>#fetch&lt;/code> 就会放弃写入 &lt;code>nil&lt;/code> 值到缓存中。试验成功！！！&lt;/p>
&lt;p>基于这样的实现，我的代码就又可以改为如下了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> read_external_service(params)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 所有改动只是加了一个 `reject_nil: true`，多方便，妈妈再也不用担心我掉到坑里去了&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rails.cache.fetch &lt;span style="font-style:italic">&amp;#39;example_cache_key_here&amp;#39;&lt;/span>, &lt;span style="font-style:italic">expires_in&lt;/span>: 7.days, &lt;span style="font-style:italic">reject_nil&lt;/span>: &lt;span style="">true&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response = HTTParty.get &lt;span style="font-style:italic">&amp;#39;https://example.com/example/request/path&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.parse(response.body)[&lt;span style="font-style:italic">&amp;#34;data&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>待会去给 Rails 提交 Pull Request 去 &lt;strong>O(∩_∩)O~~&lt;/strong>&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;ul>
&lt;li>缓存是好个东西，用得好能够让应用性能表现突飞猛进&lt;/li>
&lt;li>要注意缓存写入的边界条件，要注意避免缓存了空值，但也并非所有空值都不能缓存（比如有些接口确实就是有可能返回空值嘛），具体看业务，没有绝对的要与不要，反正 &lt;code>:reject_nil&lt;/code> 给你了，看你要不要&lt;/li>
&lt;/ul></description></item><item><title>Apdex——衡量服务器性能的标准</title><link>https://blog.hackerpie.com/posts/archive/the-correct-way-to-metric-server-response-time/</link><pubDate>Thu, 30 Jul 2015 12:12:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/the-correct-way-to-metric-server-response-time/</guid><description>&lt;p>日常工作中，我们总是习惯于通过量化的标准去衡量我们对事物的评价，比如美食点评的星级、酒店的星级、每个个人的信用评分等等。而作为一个 Web 工程师，我们也总是在意于我们网站的性能，因为网站的性能会最直接地影响用户的体验。今天要介绍的就是一种同样能够帮助工程师对应用性能进行量化评估的标准 —— Apdex 。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Apdex 全称是 Application Performance Index，是由 Apdex 联盟开放的用于评估应用性能的工业标准。Apdex 联盟起源于 2004 年，由 &lt;a href="http://apdex.org/bios.html">Peter Sevcik&lt;/a>发起。Apdex 标准从用户的角度出发，将对应用响应时间的表现，转为用户对于应用性能的可量化为范围为 0-1 的满意度评价。&lt;/p>
&lt;h3 id="术语">术语&lt;/h3>
&lt;p>Apdex 定义了应用响应时间的最优门槛为T，另外根据应用响应时间结合 T 定义了三种不同的性能表现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Satisfied（满意）&lt;/strong>：应用响应时间低于或等于 T（T 由性能评估人员根据预期性能要求确定），比如 T 为 1.5s，则一个耗时 1s 的响应结果则可以认为是 satisfied 的。&lt;/li>
&lt;li>&lt;strong>Tolerating（可容忍）&lt;/strong>：应用响应时间大于 T，但同时小于或等于 4T。假设应用设定的 T 值为 1s，则 4 * 1 = 4 秒极为应用响应时间的容忍上限。&lt;/li>
&lt;li>&lt;strong>Frustrated（烦躁期）&lt;/strong>：应用响应时间大于 4T。&lt;/li>
&lt;/ul>
&lt;h3 id="公式">公式&lt;/h3>
&lt;p>&lt;!-- raw HTML omitted -->Apdex&lt;!-- raw HTML omitted -->t&lt;!-- raw HTML omitted --> = (Satisfied Count + Tolerating Count / 2) / Total Samples&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>其中 &lt;code>Satisfied Count&lt;/code> 就是指定采样时间内响应时间满足 &lt;code>Satisfied&lt;/code> 要求的应用响应次数；而 &lt;code>Tolerating Count&lt;/code> 就是指定采样时间内响应时间满足 &lt;code>Tolerating&lt;/code> 要求的应用响应次数；最后的 &lt;code>Total Samples&lt;/code> 就是总的采样次数总数。从公式可以看出，应用的 Apdex 得分与采样持续时间无关，与目标响应时间 T 相关（在采用总数固定的情况下，T 通过影响 &lt;code>Satisfied Count&lt;/code>以及 &lt;code>Tolerating Count&lt;/code>的值间接影响最终的得分）。&lt;/p>
&lt;p>举例来说，假设你的应用期待的响应时间能够在 1000 ms 内，在 100 次采样中，有 50 次应用响应时间低于 1000 ms，30 次应用响应时间处于 1000 ms 到 4000 ms（ 4 * 1000ms） 之间，剩下 20 次响应时间长于 4000 ms，那么，该应用在 T = 1000ms 的情况下的 Apdex 值为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>(50 + 30 / 2) / 100 = 0.65
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="apdex-与-new-relic">Apdex 与 New Relic&lt;/h3>
&lt;p>在 New Relic 的 APM（Application Performance Management）功能中，就提供了各个维度的 Apdex 统计结果，比如 Server Apdex(服务器性能评分)以及 Browser Apdex(终端用户性能体验评分)，如图：
&lt;img src="http://7xj84e.com1.z0.glb.clouddn.com/blog/apdex%20overview.png" alt="Apdex 统计报表(T=0.5s)">
&lt;/p>
&lt;p>其中可以看到应用服务器在 &lt;code>T=0.5s&lt;/code> 的情况下得到的 Apdex 分数为 0.76，而 Browser（Browser 更多的是静态文件加载） 在 &lt;code>T=7s&lt;/code>的情况下得到的 Apdex 分数为 0.94。结合两者可以判断，目前应用到达终端用户性能表现比较优秀（0.94，比较接近最大值 1），但是其中影响总体性能的瓶颈则在于服务器性能（仅仅只有 0.76 分），通过这样的数据，我们就能知道下一步性能优化的方向了——服务器端性能优化。&lt;/p>
&lt;p>实际上，上面展示的只是 New Relic 的一种粒度比较粗的针对整个应用的 Apdex 报表，New Relic 同样提供了很多细粒度的 Apdex 数据，比如下面展示的针对具体的请求入口的 Apdex 报表：
&lt;img src="http://7xj84e.com1.z0.glb.clouddn.com/blog/detailed_apdex.png" alt="具体请求入口的 Apdex">
这样，通过逐步的细化，我们就可以进一步定位性能瓶颈，通过不断优化 Apdex 评分低的入口逐步提升应用整体性能体验。&lt;/p>
&lt;h3 id="apdex-与-t-值">Apdex 与 T 值&lt;/h3>
&lt;p>从公式中其实可以非常明显地看出来，T 值的选择对于最终的 Apdex 值也会有直接影响，越大的 T 值理论上来说会有更大的 Apdex 得分。比如我们可以在 New Relic 中将应用的 Apdex T 值改为 1s，以下是设定过程中看到的原来的值是 0.5s：
&lt;img src="http://7xj84e.com1.z0.glb.clouddn.com/blog/apdex%20setting.png" alt="T 值设定">
而改为 1s 后，跟上面同样的采样数据得到的新的平均 Apdex 值则高于原来的 0.76。
所以，在对应用性能进行评估的时候，首先需要确保结合应用具体情况设定一个相对合理的 T 值，太大的 T 值会导致过于乐观的 Apdex 值，但是太小的 T 值又会造成过于严苛的性能要求，最终可能导致过度的性能优化。
所以，总而言之，抛弃 T 值谈 Apdex 得分，都是耍流氓！&lt;/p>
&lt;h3 id="apdex-值一定要做到-1-吗">Apdex 值一定要做到 1 吗？&lt;/h3>
&lt;p>Apdex 公式计算能够得到的最大值就是 1，表示应用“可能”能够令所有用户对应用性能感到满意。但是， Apdex = 1 可以只是一个不断优化的方向，却不一定是要成为优化的目标，具体根据项目实际情况确定，毕竟，优化本身也需要成本投入，不需要为了极致的性能而投入过多的成本。&lt;/p>
&lt;h3 id="参考资料以及推荐链接">参考资料以及推荐链接&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Apdex">Wikipedia: Apdex&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.apdex.org/">Apdex 官网&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/apdex-measuring-user-satisfaction#what-is">Apdex: Measuring user satisfaction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/change-your-apdex-settings">New Relic: Change your Apdex settings&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/view-your-apdex-score">New Relic: View your Apdex score&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>申请以及集成 Stripe 的 Alipay 支付方案</title><link>https://blog.hackerpie.com/posts/archive/shen-qing-yi-ji-ji-cheng-stripe-de-alipay-zhi-fu-fang-an/</link><pubDate>Sat, 28 Mar 2015 12:12:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shen-qing-yi-ji-ji-cheng-stripe-de-alipay-zhi-fu-fang-an/</guid><description>&lt;p>        最近在一个项目需要支持人民币支付，并且客户要求希望能够收完款后的结算是用美元，所以就想到了去年 Stripe 宣布已经跟支付宝达成合作意向，所以经过一番咨询跟集成，终于把 Stripe 集成进来，并且启用了支付宝收款。这篇文章介绍功能申请以及集成的完整过程。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="功能申请">功能申请&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://dashboard.stripe.com/register">注册 Stripe 账号&lt;/a>；&lt;/li>
&lt;li>加入 &lt;a href="https://stripe.com/alipay">beta 用户组&lt;/a>，电子邮箱跟注册的 Stripe 账号保持一致；&lt;/li>
&lt;li>联系 Stripe 员工&lt;br>
发送邮件到 &lt;a href="mailto:support@stripe.com">support@stripe.com&lt;/a>，声明你需要在你的 Stripe 账号中启用 Alipay 的支付功能，并且提供你的 Stripe 账号。然后，等待回复就是，一般当天都能收到回复的。&lt;/li>
&lt;/ol>
&lt;h2 id="集成">集成&lt;/h2>
&lt;h3 id="0-时序图可结合后边代码一起理解">0. 时序图(可结合后边代码一起理解)&lt;/h3>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/medias/stripe_checkout_flow.png" alt="Stripe 支付流程">
&lt;/p>
&lt;h3 id="1-引入-stripejs-以及初始化脚本">1. 引入 stripe.js 以及初始化脚本&lt;/h3>
&lt;p>假设支付页面上有个开始支付按钮，其 html 代码为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">button&lt;/span> id=&lt;span style="font-style:italic">&amp;#39;pay&amp;#39;&lt;/span>&amp;gt;支付&amp;lt;/&lt;span style="font-weight:bold">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请在 html 代码里合适的地方（比如&lt;code>&amp;lt;body&amp;gt;&lt;/code>标签的底部）加载 stripe.js：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">script&lt;/span> src=&lt;span style="font-style:italic">&amp;#34;https://checkout.stripe.com/checkout.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="font-weight:bold">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在脚本中初始化 stripe.js，并且注册支付按钮的事件监听函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>$(&lt;span style="font-weight:bold">function&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">var&lt;/span> stripeHandler = StripeCheckout.configure({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: &lt;span style="font-style:italic">&amp;#39;pk_test_xxxxxxxxxxxxxxxxxxxxxxxx&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 可以查看 https://dashboard.stripe.com/account/apikeys
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> image: &lt;span style="font-style:italic">&amp;#39;https://placehold.it/200x200&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 显示在支付对话框的图片，可自己指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> alipay: &lt;span style="font-weight:bold">true&lt;/span>, &lt;span style="font-style:italic">// 启用支付宝支付
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> token: &lt;span style="font-weight:bold">function&lt;/span>(token){ &lt;span style="font-style:italic">// 用户填写完资料并且 Stripe 校验成功后的回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// 此时应该提交 token.id 到后台，比如 http://example.com/orders/1?stripeToken={token.id}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $(&lt;span style="font-style:italic">&amp;#39;#pay&amp;#39;&lt;/span>).click(&lt;span style="font-weight:bold">function&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stripeHandler.open({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">&amp;#39;Business Name&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 收款方或商家名称，比如 Beansmile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> description: &lt;span style="font-style:italic">&amp;#34;商品描述内容&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 待支付商品的描述
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> amount: 50 * 100, &lt;span style="font-style:italic">// 支付金额，单位是“分”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> opened: &lt;span style="font-weight:bold">function&lt;/span>(){ &lt;span style="font-style:italic">// 支付对话框打开后的回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// Do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-通过-token-请求收款">2. 通过 token 请求收款&lt;/h3>
&lt;p>服务器端是 Ruby on Rails 实现，所以在 Gemfile 中引入 Stripe 官方的 Ruby SDK(具体配置方法请自行查阅其 README)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Gemfile&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Stripe Ruby bindings&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/stripe/stripe-ruby&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#34;stripe&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;~&amp;gt; 1.20.1&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后在 Controller action 中添加处理逻辑:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/controllers/orders_controller.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">OrdersController&lt;/span> &amp;lt; ApplicationController
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># PUT /orders/:id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># params:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># id: 订单的 id&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># stripeToken: 客户端完成支付流程，在脚本的回调函数中会得到 `token.id`，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 将其上传到 `stripeToken` 参数，服务器端用此 token 请求收款&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> pay
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response = Stripe::Charge.create &lt;span style="font-style:italic">amount&lt;/span>: order.amount_in_cents,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">currency&lt;/span>: &lt;span style="font-style:italic">&amp;#39;USD&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">source&lt;/span>: params[&lt;span style="font-style:italic">:stripeToken&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">description&lt;/span>: &lt;span style="font-style:italic">&amp;#34;订单描述&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> order.update_attribute &lt;span style="font-style:italic">:state&lt;/span>, &lt;span style="font-style:italic">:paid&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redirect_to order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Stripe::InvalidRequestError =&amp;gt; error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flash[&lt;span style="font-style:italic">:error&lt;/span>] = &lt;span style="font-style:italic">&amp;#34;由于&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>error.message&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">，支付失败！&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redirect_to order
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-效果预览">3. 效果预览&lt;/h3>
&lt;p>
&lt;img src="https://blog.hackerpie.com/images/medias/stripe.gif" alt="stripe 支付流程演示">
&lt;/p>
&lt;h2 id="其他">其他&lt;/h2>
&lt;ol>
&lt;li>关于 Stripe 的沙盒机制&lt;br>
Stripe 为每个账号都提供了&lt;a href="https://dashboard.stripe.com/account/apikeys">两组 keys&lt;/a>，一组 key 用于用于 live 环境，另一组是 test 环境，后者即是沙盒环境，而针对支付宝的沙盒，可用任意合法的邮箱账号进行测试，但验证码是固定的 123456，而身份证后 6 位是固定的 12345；&lt;/li>
&lt;li>在功能申请过程中，一定要记得完成步骤3——联系 Stripe 开通 Alipay 支付功能。否则，会在支付的时候出现错误，错误信息示例为：&lt;code>There is no token with ID atok_xxxxxxxxxxxxxxxxxxxxxxxx&lt;/code>&lt;/li>
&lt;li>实际开发中，请结合考虑用 stripe 提供的 &lt;a href="https://dashboard.stripe.com/account/webhooks">webhook&lt;/a> 处理支付状态变迁；&lt;/li>
&lt;li>此支付机制中，付款人可用人民币支付，但是 Stripe 会用美元跟商家（收款方）进行结算；&lt;/li>
&lt;li>我总结了工作中集成过的其他几款支付网关，横向对比了各家的异同点，有兴趣的请戳：&lt;a href="http://jianggaowang.com/slides/67">讲稿网：Payment Gateways&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://stripe.com/alipay">Stripe: Alipay 首页&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stripe.com/press/alipay">Stripe: Alipay FAQ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stripe.com/docs/guides/alipay-beta">Stripe: Alipay 集成文档&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stripe.com/docs/checkout">Stripe: Checkout&lt;/a>，这部分的文档虽然没有提交 Alipay, 但是针对 Alipay 的集成，依旧适用。&lt;/li>
&lt;/ol></description></item><item><title>How do I fix Passenger application startup problem</title><link>https://blog.hackerpie.com/posts/archive/how-do-i-fix-passenger-application-startup-problem/</link><pubDate>Sat, 10 Jan 2015 01:54:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/how-do-i-fix-passenger-application-startup-problem/</guid><description>&lt;p>Recent days I was working on deploying one of my Rails project on a complete new VPS. I had operated according to my experience for deploying sites before, but at the last step, after I have deployed the site, it always raised error message &amp;ldquo;An error occurred while starting up the preloader: it did not write a startup response in time.&amp;rdquo; when I try to visit the site. But, thanks to much hard work and retry, I found the source of the problem and finally fix it.&lt;/p>
&lt;p>I will spend short time to show the main steps to resolve the problem. Let&amp;rsquo;s GO!&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="what-does-the-error-message-mean">What Does The Error Message Mean?&lt;/h2>
&lt;p>According the official wiki of &lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems">Passenger&lt;/a> on Github:&lt;/p>
&lt;blockquote>
&lt;p>Phusion Passenger reports this error if the application did not finish initializing within a time limit, or if it exited without sending Phusion Passenger a message that says &amp;ldquo;I&amp;rsquo;ve initialized successfully!&amp;rdquo;&lt;/p>
&lt;/blockquote>
&lt;p>That is, &lt;strong>TWO&lt;/strong> things are expected that our application should:&lt;/p>
&lt;ul>
&lt;li>response a message to notify Passenger that itself is ready&lt;/li>
&lt;li>response within a time limit&lt;/li>
&lt;/ul>
&lt;p>otherwise Passenger will regard the application has been failed to startup and hence report error.&lt;/p>
&lt;h2 id="possible-causes-of-problem">Possible Causes Of Problem&lt;/h2>
&lt;p>According &lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems#possible-causes-of-problems">&amp;ldquo;Possible causes of problems&amp;rdquo;&lt;/a> section in the above wiki, we can conclude that there will be the below four causes:&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems#stdout-redirection">Stdout redirection&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems#early-termination-in-bash">Early termination in bash&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems#application-startup-freeze">Application startup freeze&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/phusion/passenger/wiki/Debugging-application-startup-problems#server-too-busy">Server too busy&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="how-i-refused-impossible-causes">How I Refused Impossible Causes&lt;/h2>
&lt;p>For the first possible cause, I can not find any STDOUT redirection in all my bash init scripts, so I trust there is no redirection in my server.&lt;/p>
&lt;p>For the second one, I had tried to config to disable the loading of bashrc, but it still didn&amp;rsquo;t work, so the second cause is not the cause.&lt;/p>
&lt;p>The third one is impossible because I had built the application on other servers successfully, it seems that the cause was not from the application itself.&lt;/p>
&lt;h2 id="the-true-evil-found">The True Evil Found&lt;/h2>
&lt;p>For the last one possible cause, I tried to run &lt;code>top&lt;/code> command in shell of the server to determine if CPU or disk is busy, and I found a interesting thing: everytime I visit the site, the CPU usage was up to &amp;gt; 80%, even 90% - 100%, and after about one and half minutes, the browser rendered a rails &amp;ldquo;Something went wrong&amp;rdquo; page and meantime the CPU usage was back to &amp;lt;10%.&lt;/p>
&lt;p>I then check the explanation from Passenger again:&lt;/p>
&lt;blockquote>
&lt;p>It could also be that your server is so busy doing something (either CPU-wise or disk-wise) that it fails to start an application process within a reasonable amount of time. The default startup limit is 90 seconds.&lt;/p>
&lt;/blockquote>
&lt;p>Aha, looks like the time limit is the evil. So I decided to try to change the timeout to a longer time, such as 300 seconds.&lt;/p>
&lt;p>In my passenger module config file &lt;code>/etc/apache2/mods-available/passenger.conf&lt;/code>(more details about why this file, see &lt;a href="https://www.phusionpassenger.com/documentation/Users%20guide%20Apache.html#working_with_apache_conf">Passenger Guide: Working with the Apache configuration file&lt;/a>), I explicitly append:&lt;/p>
&lt;pre tabindex="0">&lt;code>PassengerStartTimeout 300
&lt;/code>&lt;/pre>&lt;p>After that, I tried to restart my Apache2 server and deploy again, and Passenger waited for startup within a longer time this time, and hence my application was lastly deployed successfully.&lt;/p></description></item><item><title>在 coding.net 上部署 Jekyll 博客</title><link>https://blog.hackerpie.com/posts/archive/zai-coding-dot-netshang-bu-shu-jekyllbo-ke/</link><pubDate>Sat, 20 Dec 2014 12:59:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zai-coding-dot-netshang-bu-shu-jekyllbo-ke/</guid><description>&lt;p>自从 &lt;a href="https://ruby-china.org/topics/22858">coding 推出 PaaS 演示平台以及开放自定义域名&lt;/a>之后，很多人开始尝试在 coding 上部署自己的博客，其中就有 &lt;a href="http://jekyllrb.com/">jekyll&lt;/a>，coding 上就有官方推荐的 &lt;a href="https://coding.net/u/chenwj233/p/jekyll-demo/git">jekyll-demo&lt;/a>。但是因为这个 Demo 的 README 文档中只是简单介绍配置步骤而已，没有详细介绍原理以及灵活配置的地方，我在参照着迁移 jekyll 博客的过程中也遇到一些问题。现在写下文章，希望能够把原理理清楚。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>**声明：**这篇文章主要是对原来的 Demo 的几个主要思路做一个补充说明，而并非 coding 演示平台使用操作的详细教程，所以在有些细节上不一定覆盖到，建议最终的部署代码需要以官方推荐的 repo 里的代码为主。&lt;/p>
&lt;h2 id="基本原理">基本原理&lt;/h2>
&lt;p>因为 Coding 提供的演示平台是通用的 PaaS 平台，并非类似 Github 或者 Gitcafe 的 Pages 服务，所以 jekyll 部署到演示平台需要解决三个问题：&lt;/p>
&lt;p>&lt;strong>1. 运行问题&lt;/strong>，blog 需要以常规 Web 程序的方式运行；&lt;br>
&lt;strong>2. 启动脚本&lt;/strong>，部署完成后自动启动服务器；&lt;br>
&lt;strong>3. 自动更新&lt;/strong>，blog 内容更新 push 后能够自动生成新的页面。&lt;/p>
&lt;p>第一个问题我们可以通过 &lt;a href="https://github.com/adaoraul/rack-jekyll">rack-jekyll&lt;/a> 解决；第二个问题通过 Coding 约定的 &lt;code>Procfile&lt;/code> 文件解决；第三个问题我们通过 Coding 的 &lt;a href="https://coding.net/help/about_git/what_is_web_hook">Webhook&lt;/a> 结合脚本解决。&lt;/p>
&lt;h3 id="1-将-jekyll-博客变为一个在线运行的-rack-程序">1. 将 Jekyll 博客变为一个在线运行的 Rack 程序&lt;/h3>
&lt;p>Jekyll 原本是一个用于生成静态博客站点的框架，但是为了能够在 coding 演示平台上直接运行 Jekyll 博客，我们需要一个能够在 &lt;a href="http://unicorn.bogomips.org/">Unicorn&lt;/a> 服务器上运行 Jekyll 的方法。通过原来 coding 提供的 Demo，找到了一个叫 &lt;a href="https://github.com/adaoraul/rack-jekyll">rack-jekyll&lt;/a> 的工具。&lt;/p>
&lt;p>rack-jekyll 主要的功能如其介绍：&lt;/p>
&lt;blockquote>
&lt;p>Transform your Jekyll app into Rack application!&lt;/p>
&lt;/blockquote>
&lt;p>就是将 Jekyll 作为 &lt;a href="http://rack.github.io/">Rack&lt;/a> 程序运行。&lt;/p>
&lt;p>首先，为了能够使用 rack-jekyll 以及 unicorn，我们在 &lt;code>Gemfile&lt;/code> 文件(如果没有则直接新建即可)中加入:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#34;rack-jekyll&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#34;unicorn&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这两行，然后执行 &lt;code>bundle install&lt;/code> 这样，我们的项目中就成功引入 &lt;code>rack-jekyll&lt;/code> 以及 &lt;code>unicorn&lt;/code> 了。&lt;/p>
&lt;p>其次，因为 unicorn 默认会从项目根目录下的 &lt;code>config.ru&lt;/code> 文件启动，再结合 &lt;a href="https://github.com/adaoraul/rack-jekyll#how-to-use-it">rack-jekyll 的使用说明&lt;/a> ，我们在 jekyll 项目根目录下要创建一个包含以下内容的文件，并且名字就是 &lt;code>config.ru&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># config.ru&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#34;rack/jekyll&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>run Rack::Jekyll.new
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>到此，可以在命令行中 cd 到当前项目根目录，执行 &lt;code>jekyll build&lt;/code> 生成站点，然后再执行 &lt;code>unicorn&lt;/code> 从默认配置启动服务器，成功启动后，在浏览器中访问“ http://127.0.0.1:8080 ”就可以看到博客了。&lt;/p>
&lt;h3 id="2-添加用于-coding-演示平台的启动脚本">2. 添加用于 Coding 演示平台的启动脚本&lt;/h3>
&lt;p>上面第一步只是解决了 Jekyll 能够以 Rack 方式运行的问题而已，但是为了部署到 coding 后，项目能够正常启动，我们还需要加入启动命令。&lt;/p>
&lt;p>按照 &lt;a href="http://docs.coding.io/ruby.html#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4">coding 在关于 Ruby 部分的演示平台文档&lt;/a> 中的介绍得知，coding 会查找项目根目录下的 &lt;code>Procfile&lt;/code> 文件，并将里边的内容作为启动命令，当此文件不存在时，则将默认使用一下启动命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">web&lt;/span>: bundle exec rackup config.ru -p $PORT
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>按照默认启动命令的格式，我们也可以写出以下 &lt;code>Procfile&lt;/code> 文件，用于部署后从 unicorn 启动项目：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">web&lt;/span>: bundle exec unicorn -p $PORT -c ./unicorn.rb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成前面两步之后，将代码 push 到 coding 上，再从演示平台一键部署的话，就应该可以成功启动 unicorn 服务器，并且能够访问你的 jekyll 博客了。但是，如果有了新文章呢？怎么自动在站点改动后重新生成站点？&lt;/p>
&lt;h3 id="3-使用-webhook-在-push-后自动重新生成站点内容">3. 使用 Webhook 在 push 后自动重新生成站点内容&lt;/h3>
&lt;p>coding 为用户提供了 &lt;a href="https://coding.net/help/about_git/what_is_web_hook">webhook&lt;/a> 功能，方便用户在 push 代码改动后自动 POST 请求你指定的 Web URL，你可以利用这个 URL 在程序后台完成程序的自动部署等操作。更多的介绍跟使用方法请参考 &lt;a href="https://coding.net/help/about_git/about_web_hook_content">&amp;ldquo;WebHook 的内容是什么？&amp;rdquo;&lt;/a> 以及 &lt;a href="https://coding.net/help/about_git/what_is_web_hook">&amp;ldquo;WebHook 是什么？我该如何使用？&amp;rdquo;&lt;/a>。&lt;/p>
&lt;p>为了增加新的入口以接收 coding 的 Webhook 通知，我们可以在 &lt;code>config.ru&lt;/code> 中添加新的路由，并且添加响应的处理脚本，这部分的内容我先直接拷贝官方推荐的 &lt;a href="https://coding.net/u/chenwj233/p/jekyll-demo/git/raw/master/config.ru">jekyll demo 的代码&lt;/a> 后再做必要的解读：&lt;/p>
&lt;pre tabindex="0">&lt;code># config.ru
require &amp;#34;bundler/setup&amp;#34;
Bundler.require(:default)
WEBHOOK_TOKEN = ENV[&amp;#39;WEBHOOK_TOKEN&amp;#39;]
app = Proc.new do |env|
request = Rack::Request.new(env)
response = Rack::Response.new
path_info = request.path_info
if request.content_type =~ /application\/json/
params = JSON.parse(request.body.read)
else
params = request.params
end
if request.post? &amp;amp;&amp;amp; params[&amp;#39;token&amp;#39;] == WEBHOOK_TOKEN
repo_url = params[&amp;#39;repository&amp;#39;][&amp;#39;url&amp;#39;] rescue nil
if repo_url
archive_url = &amp;#34;#{repo_url}/archive/master&amp;#34;
puts &amp;#34;--&amp;gt; updating to #{params[&amp;#39;ref&amp;#39;]}..&amp;#34;
puts `jekyll build`
`rm -rf $HOME/_posts; curl -s -L -o $TMPDIR/archive.zip #{archive_url}; unzip -qo -d $HOME $TMPDIR/archive.zip; cd $HOME; jekyll build`
puts &amp;#34;--&amp;gt; done.&amp;#34;
else
STDERR.puts &amp;#34;--&amp;gt; error: no url field found in params: #{params}&amp;#34;
end
[&amp;#39;200&amp;#39;, { &amp;#39;Conetent-Type&amp;#39; =&amp;gt; &amp;#39;application/json;charset=utf-8&amp;#39; }, [&amp;#39;ok&amp;#39;]]
else
[&amp;#39;403&amp;#39;, { &amp;#39;Conetent-Type&amp;#39; =&amp;gt; &amp;#39;application/json;charset=utf-8&amp;#39; }, [{ error: &amp;#39;webhook token mismatch!&amp;#39; }.to_json]]
end
end
jekyll = Rack::Jekyll.new(auto: true)
run Rack::URLMap.new(&amp;#39;/&amp;#39; =&amp;gt; jekyll, &amp;#39;/_&amp;#39; =&amp;gt; app)
&lt;/code>&lt;/pre>&lt;p>首先，程序在启动时，指定了两个路由入口分别指向不同的后台程序，其中 &lt;code>'/'&lt;/code> 路径指向了我们的 &lt;code>jekyll&lt;/code> 程序，这个跟原来的配置目的一致；而 &lt;code>'/_'&lt;/code> 路径指向了 &lt;code>app&lt;/code> 这个程序。&lt;/p>
&lt;p>所以，当有外部向服务器发送了一个指向 &amp;ldquo;/&lt;em>&amp;rdquo; 路径（比如“ &lt;a href="http://test.codingapp.com/">http://test.codingapp.com/&lt;/a>&lt;/em> ”）的请求时，服务器在内部启动了 &lt;code>app&lt;/code> 的脚本。（注意，如果你希望使用别的路径名来配置 webhook 的入口，只要将下划线改成你需要的路径即可，比如： &amp;ldquo;&lt;a href="http://test.codingapp.com/deploy%22">http://test.codingapp.com/deploy&amp;quot;&lt;/a>）。&lt;/p>
&lt;p>&lt;code>app&lt;/code> 脚本首先通过请求的 &lt;code>Content-Type&lt;/code> 头信息判断请求格式，并据此从请求中提取请求参数赋给 &lt;code>params&lt;/code> 变量；接着脚本验证请求的合法性，要求请求必须是 POST 方式，并且参数中的 &lt;code>token&lt;/code> 参数的值必须与我们在 coding 后台中配置的 token 一致。&lt;/p>
&lt;p>最后，在确认请求的合法性后，脚本先清空了当前部署的项目，然后下载解压指定分支的最新代码，并且进入项目根目录(&lt;code>$HOME&lt;/code>环境变量)重新执行了 &lt;code>jekyll build&lt;/code> 命令以重新生成静态站点，见代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">`rm -rf $HOME/_posts; curl -s -L -o $TMPDIR/archive.zip &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>archive_url&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">; unzip -qo -d $HOME $TMPDIR/archive.zip; cd $HOME; jekyll build`&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>其中值得一提的是，&lt;code>archive_url&lt;/code>是在前面代码中拼接而来的链接：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>archive_url = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>repo_url&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">/archive/master&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意其中硬编码的部分 &lt;code>&amp;quot;archive/master&amp;quot;&lt;/code>，其中的 &lt;code>master&lt;/code> 指定了是 &lt;code>master&lt;/code> 分支上的代码压缩包的路径，所以假如你需要从 master 分支外的分支部署代码，请务必记得将 &lt;code>master&lt;/code> 改为对应的分支名，比如我的部署分支是 &lt;code>coding-pages&lt;/code>，那我这里的代码就应该改为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>archive_url = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>repo_url&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">/archive/coding-pages&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>完成 webhook 处理脚本后，需要重新 push 代码并且重新在演示平台部署一次，以使 &lt;code>config.ru&lt;/code> 文件里的代码生效。至于如何配置 webhook ，直接参照 coding 的官方文档即可。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>以上的三点主要是对在 coding 上部署 jekyll 博客的关键思路的说明，通过这三点，相信你再去看原来的 &lt;a href="https://coding.net/u/chenwj233/p/jekyll-demo/git/raw/125f456d2dfa4d324e320a57a78adf7fda89c93e/README.md">README&lt;/a> 的时候，应该就能很快理解为什么需要配置 &lt;code>WEBHOOK_TOKEN&lt;/code> 环境变量以及为什么要配置 webhook 的 URL 为类似 &amp;ldquo;http://host/_&amp;rdquo; 这么奇怪的链接了吧？除此之外，你也可以根据你的需要将脚本中的代码分支从 &lt;code>master&lt;/code> 改为你所需要的目标分支了。&lt;br>
其实用 unicorn 运行 jekyll 项目的原理还是非常简单的，知道了这些之后，将你的已有 jekyll 项目直接迁移到 coding 甚至是其他 PaaS 平台上就不是件麻烦的事了。&lt;/p>
&lt;h2 id="其他联想">其他联想&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="http://octopress.org/">Octopress&lt;/a> 博客是在 jekyll 的基础上封装而来的更高级也更方便的静态站点框架，所以按照上面的原理，将已有的 octopress 项目部署到 coding 平台上，应该也不是件难事。&lt;/li>
&lt;li>Octopress 本身支持另外一种部署方式，就是本地生成静态站点之后，直接执行 &lt;code>rake deploy&lt;/code> 将生成后的静态站点 push 到指定的远程 repo 或者指定的分支上，从这个角度考虑，其实也可以为 jekyll 实现类似的脚本，结合 coding 演示平台的 &lt;a href="https://coding.net/help/project_demos/do_you_support_static_html_site">静态站点部署&lt;/a> ，就可以直接部署 jekyll 博客了，这种方式就省去了 unicorn 服务器等的配置了，也不需要再使用 webhook 重新生成站点了，而且纯静态站点的方案的最大优点就是，特别节约内存。这种方案只是构想，但是值得一试。如果哪位朋友尝试成功了，请记得在评论里回复一下。&lt;/li>
&lt;/ol></description></item><item><title>RAILS中利用YAML文件完成数据对接</title><link>https://blog.hackerpie.com/posts/archive/railszhong-jie-he-yamlwen-jian-wan-cheng-shu-ju-dui-jie/</link><pubDate>Wed, 12 Nov 2014 20:15:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/railszhong-jie-he-yamlwen-jian-wan-cheng-shu-ju-dui-jie/</guid><description>&lt;p>最近在做的Ruby on Rails项目中，需要将远程数据库中的数据对接到项目数据库中，但是远程的数据不仅数据表名跟字段命名奇葩，数据结构本身跟项目数据结构出入比较大，在数据导入过程中代码经历了几次重构，最后使用了YAML文件解决了基本数据&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>对接的问题。在此写一篇博文，我会尽量重现一路过来的代码变更，算是分享一下我的思考过程，也算是祭奠一下自己的苦逼岁月。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="假设以及数据结构预览">假设以及数据结构预览&lt;/h3>
&lt;p>因为远程数据库服务器为Oracle Server，我在项目中使用到了&lt;a href="http://sequel.jeremyevans.net/">Sequel&lt;/a>这个gem用于连接数据库以及数据查询，因为数据库连接的内容不是本文的重点，故后续代码直接用&lt;code>remote_database&lt;/code>表示数据库连接，而根据&lt;a href="http://sequel.jeremyevans.net/rdoc/files/doc/dataset_basics_rdoc.html">Sequel的用法&lt;/a>，我们可以直接使用&lt;code>remote_database[table_name]&lt;/code>连接到具体的表。&lt;/p>
&lt;p>本次需要从远程数据库中导入的基本数据主要有学生信息表（包含班级名称）、老师信息表以及专业信息表，相应地，项目中（以下称为“本地”）也已经创建好了对应的model。其中学生信息表的表名以及部分数据字段的从本地到远程的映射关系如表所示：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表名或字段名&lt;/th>
&lt;th>本地&lt;/th>
&lt;th>远程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>表名&lt;/td>
&lt;td>students&lt;/td>
&lt;td>XSJBXX&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>姓名&lt;/td>
&lt;td>name&lt;/td>
&lt;td>XM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>学号&lt;/td>
&lt;td>number&lt;/td>
&lt;td>XH&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>年级&lt;/td>
&lt;td>grade&lt;/td>
&lt;td>NJ&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>班级&lt;/td>
&lt;td>belongs_to :klass    &lt;/td>
&lt;td>BJMC(班级名称)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>老师信息表的表名以及部分数据字段的映射关系为：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>表名或字段名&lt;/th>
&lt;th>本地&lt;/th>
&lt;th>远程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>表名&lt;/td>
&lt;td>teachers&lt;/td>
&lt;td>JZGJBXX&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>姓名&lt;/td>
&lt;td>name&lt;/td>
&lt;td>XM&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>职称&lt;/td>
&lt;td>title&lt;/td>
&lt;td>ZC&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>证件号码&lt;/td>
&lt;td>id_number&lt;/td>
&lt;td>ZJHM&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="数据对接第一版属性方法显式赋值">数据对接第一版：属性方法显式赋值&lt;/h3>
&lt;p>第一个导入的数据表是学生的信息表，在最开始的时候，因为只需要考虑一张单独的表，所以代码写得简单粗暴，基本过程就是：根据需要的信息，查询对应的远程数据字段，然后使用属性方法赋值，最后保存接入的数据。对接方法的部分相关代码示例（为了方便阅读以及保护项目敏感信息，本文对项目中原有代码进行了缩减以及修改）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/student.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Student&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> import_data_from_remote
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students = remote_database[&lt;span style="font-style:italic">:xsjbxx&lt;/span>].page(page)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students.each &lt;span style="font-weight:bold">do&lt;/span> |remote_student|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name, number, grade = *remote_student.values_at(&lt;span style="font-style:italic">:xm&lt;/span>, &lt;span style="font-style:italic">:xh&lt;/span>, &lt;span style="font-style:italic">:nj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_name = remote_student[&lt;span style="font-style:italic">:bjmc&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass = Klass.find_or_create_by name: class_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student = Student.find_by_create_by name: name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: number,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">grade&lt;/span>: grade,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">klass&lt;/span>: klass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码，呃，中规中矩，基本体现了各取所需的指导思想，但是总觉得怎么有点不好呢？&lt;/p>
&lt;h3 id="数据对接第二版通过本地到远程数据库字段映射关系自动匹配赋值">数据对接第二版：通过本地到远程数据库字段映射关系自动匹配赋值&lt;/h3>
&lt;p>在第一版的代码中，最大的坏味道在于：代码中需要把所有需要对接的字段列举出来，一旦遇到字段增删修改的情况，就需要同时更新原来的逻辑代码，太不灵活了，而且列举所有字段本身就是一件非常繁琐枯燥的事情。再假设字段很多的情况下，要从代码中一个个检查字段的名称，肯定是件多么可怕的事情啊。&lt;/p>
&lt;p>那么怎么修改呢？用映射表！仔细观察第一段的代码，其实代码所做的工作如此简单：无非是先从远程数据中取值，然后赋值到本地数据对象的对应属性中，这种“本地-远程”的字段映射关系，不就是我们每天面对的“键-值”对的特征吗？那直接用一个&lt;code>Hash&lt;/code>来保存这种对应关系不就好了。&lt;/p>
&lt;p>话不多说，我们开始重构：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/student.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Student&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: &lt;span style="font-style:italic">:xh&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">:xm&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">age&lt;/span>: &lt;span style="font-style:italic">:nj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_ASSOCIATION_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">klass&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">association_field_name&lt;/span>: &lt;span style="font-style:italic">:name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">remote_field_name&lt;/span>: &lt;span style="font-style:italic">:bjmc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> import_data_from_remote
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students = remote_database[&lt;span style="font-style:italic">:xsjbxx&lt;/span>].page(page)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students.each &lt;span style="font-weight:bold">do&lt;/span> |remote_student|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student = Student.find_or_initialize_by &lt;span style="font-style:italic">xxx&lt;/span>: xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP.keys.each &lt;span style="font-weight:bold">do&lt;/span> |attribute|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 逐一调用属性赋值方法，完成Student属性的赋值&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.send(&lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>attribute&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">=&amp;#34;&lt;/span>, remote_student[LOCAL_TO_REMOTE_FIELDS_MAP[attribute]])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_ASSOCIATION_MAP.each &lt;span style="font-weight:bold">do&lt;/span> |association_name, association_fields_map|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 把远程数据赋给对应的本地数据字段&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> association_field_name = association_fields_map[&lt;span style="font-style:italic">:association_field_name&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_value = remote_student[association_fields_map[&lt;span style="font-style:italic">:remote_field_name&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 查找或创建关联对象&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> related_object =
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> reflect_on_association(association_name).klass.find_or_create_by association_field_name =&amp;gt; remote_value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 建立关联关系&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local_object.send(&lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>association_name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">=&amp;#34;&lt;/span>, related_object)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student.save
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在上面的示例中，我们用常量&lt;code>LOCAL_TO_REMOTE_FIELDS_MAP&lt;/code>保存&lt;code>Student&lt;/code>这个model本身的字段跟远程数据字段的映射关系，这样我们就可以通过类似&lt;code>LOCAL_TO_REMOTE_FIELDS_MAP[:number]&lt;/code>知道学生的姓名在远程数据表中对应的字段是&lt;code>:xm&lt;/code>了。另外值得一提的是，我用了&lt;code>LOCAL_TO_REMOTE_ASSOCIATION_MAP&lt;/code>这个常量保存了学生与班级关联关系，同时保存了关联的&lt;code>klass&lt;/code>的数据字段映射关系。&lt;/p>
&lt;p>在声明了必要的字段映射关系之后，我就在代码中遍历了每一个字段，并且通过对应的远程字段名称查找对应的数值，并且使用&lt;code>send&lt;/code>方法调用了对象的属性赋值方法，将数据自动对接到本地数据对象上。&lt;/p>
&lt;p>到目前为止，代码行数虽然反而多了，但是却实现了字段映射关系与逻辑代码的分离，我们可以独立管理映射关系了。以后就算需要加入新的对接字段，只要在&lt;code>LOCAL_TO_REMOTE_FIELDS_MAP&lt;/code>中添加新的键值对就好了，甚至可以在&lt;code>LOCAL_TO_REMOTE_ASSOCIATION_MAP&lt;/code>添加类似&lt;code>klass&lt;/code>的简单关联关系的数据接入，而这些都无需修改逻辑代码。&lt;/p>
&lt;h3 id="数据对接第三版教职工信息也需要导入了代码拷贝之旅开始了">数据对接第三版：教职工信息也需要导入了，代码拷贝之旅开始了&lt;/h3>
&lt;p>毫无疑问，如果只是满足于学生信息的对接，相信上面的代码也都够用了，代码的重构也可以告一段落了。&lt;/p>
&lt;p>但是，前面说了，除了学生的信息，还有教职工的信息需要做接入，而且从最开始的&lt;strong>假设以及数据结构预览&lt;/strong>一节看到，老师的数据结构跟学生的数据结构极其相似，所以，时间紧迫，我就直接拷贝代码然后简单删改了一下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/teacher.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Teacher&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: &lt;span style="font-style:italic">:xh&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">title&lt;/span>: &lt;span style="font-style:italic">:zc&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">id_number&lt;/span>: &lt;span style="font-style:italic">:zjhm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> import_data_from_remote
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_teachers = remote_database[&lt;span style="font-style:italic">:jzgjbxx&lt;/span>].page(page)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_teachers.each &lt;span style="font-weight:bold">do&lt;/span> |remote_teacher|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> teacher = Teacher.find_or_initialize_by &lt;span style="font-style:italic">xxx&lt;/span>: xxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP.keys.each &lt;span style="font-weight:bold">do&lt;/span> |attribute|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> teacher.send(&lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>attribute&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">=&amp;#34;&lt;/span>, remote_teacher[LOCAL_TO_REMOTE_FIELDS_MAP[attribute]])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> teacher.save
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>注意在上面的代码中，&lt;code>Teacher&lt;/code>中比起&lt;code>Student&lt;/code>，少了&lt;code>LOCAL_TO_REMOTE_ASSOCIATION_MAP&lt;/code>常量，并且也删除了相关的代码，虽然代码已经满足需求了，教职工的数据导入也是无比顺利，可是面对着一堆重复的代码，真心别扭！&lt;/p>
&lt;h3 id="数据对接第四版抽象逻辑代码共享">数据对接第四版：抽象逻辑，代码共享&lt;/h3>
&lt;p>其实我多少也是有代码洁癖的，大片Copy的代码岂不是搞得自己逼格好Low？怎么可以忍受，继续重构！&lt;/p>
&lt;p>这一次重构其实就简单多了，把重复的核心逻辑代码抽取出来，然后放到一个专门负责数据对接的Concern里边，最后在需要此concern的model里include一下就行了。话不多说，上Concern代码：&lt;/p>
&lt;pre tabindex="0">&lt;code># app/models/concerns/import_data_concern.rb
module ImportDataConcern
extend ActiveSupport::Concern
module ClassMethods
def import_data_from_remote
remote_objects = remote_database[self::REMOTE_TABLE_NAME].page(page)
remote_objects.each do |remote_object|
object = self.find_or_initialize_by xxx: xxx
self::LOCAL_TO_REMOTE_FIELDS_MAP.keys.each do |attribute|
# 逐一调用属性赋值方法，完成Student属性的赋值
object.send(&amp;#34;#{attribute}=&amp;#34;, remote_object[self::LOCAL_TO_REMOTE_FIELDS_MAP[attribute]])
end
if self::LOCAL_TO_REMOTE_ASSOCIATION_MAP
self::LOCAL_TO_REMOTE_ASSOCIATION_MAP.each do |association_name, association_fields_map|
# 把远程数据赋给对应的本地数据字段
association_field_name = association_fields_map[:association_field_name]
remote_value = remote_object[association_fields_map[:remote_field_name]]
# 查找或创建关联对象
related_object =
reflect_on_association(association_name).klass.find_or_create_by association_field_name =&amp;gt; remote_value
# 建立关联关系
local_object.send(&amp;#34;#{association_name}=&amp;#34;, related_object)
end
end
object.save
end
end
end
end
&lt;/code>&lt;/pre>&lt;p>在上面的代码中，我们把核心对接逻辑抽了出来，并且抽象了远程数据表名的配置，另外通过&lt;code>if self::LOCAL_TO_REMOTE_ASSOCIATION_MAP&lt;/code>兼容关联关系的导入。
为了在&lt;code>Teacher&lt;/code>以及&lt;code>Student&lt;/code>中正常运行上面的代码，我们还需要在这两个model分别include当前的concern，并且声明必要的常量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/student.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Student&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ImportDataConcern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> REMOTE_TABLE_NAME = &lt;span style="font-style:italic">&amp;#39;XSJBXX&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: &lt;span style="font-style:italic">:xh&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">:xm&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">age&lt;/span>: &lt;span style="font-style:italic">:nj&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_ASSOCIATION_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">klass&lt;/span>: {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">association_field_name&lt;/span>: &lt;span style="font-style:italic">:name&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">remote_field_name&lt;/span>: &lt;span style="font-style:italic">:bjmc&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/teacher.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Teacher&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ImportDataConcern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> LOCAL_TO_REMOTE_FIELDS_MAP = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: &lt;span style="font-style:italic">:xh&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">title&lt;/span>: &lt;span style="font-style:italic">:zc&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">id_number&lt;/span>: &lt;span style="font-style:italic">:zjhm&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>经过上面的重构，原本重复的代码已经变成了一个Concern，通过Concern来管理独立的业务逻辑，也使得代码管理起来更方便了。但是，等等，我们的重构之旅还在继续！&lt;/p>
&lt;h3 id="数据对接第五版砍掉恶心的常量使用yaml配置映射关系">数据对接第五版：砍掉恶心的常量，使用YAML配置映射关系&lt;/h3>
&lt;p>当时在写代码的过程中，我就一直感觉一大堆的常量令人无法直视，但是，如果不用常量，我还能怎么做？尽管前面两个表的数据导入任务完成了，我还是纠结于代码中那恶心死了的常量（实际上，我当时写的常量比你们现在看到的更多，文章中的只不过是示例）。而庆幸的是，那天脑洞一开：“这些映射关系本质上不就是一堆配置信息吗？而我在代码中的常量也就是用Hash存储的，那用YAML文件不就刚好了吗?”。是啊，像&lt;code>config/database.yml&lt;/code>这类的文件，一直以来都是用于保存配置信息的啊，一个是符合Rails的使用习惯，另一个也确实符合数据结构的要求。Awesome，这就开始动工。&lt;/p>
&lt;p>首先第一件事，我就把那些常量搬到了yaml文件中，并且放在了项目的&lt;code>config/&lt;/code>目录下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">default&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">remote_unique_field_name&lt;/span>: number
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">models&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">student&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">remote_table_name&lt;/span>: xsjbxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">local_to_remote_fields_map&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">number&lt;/span>: xh
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">name&lt;/span>: xm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">grade&lt;/span>: nj
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">local_to_remote_association_map&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">klass&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">association_field_name&lt;/span>: name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">remote_field_name&lt;/span>: bjmc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">teacher&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">remote_table_name&lt;/span>: jzgjbxx
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">local_to_remote_fields_map&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">name&lt;/span>: xm
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">title&lt;/span>: zc
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">id_number&lt;/span>: zjhm
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>配置好了yaml，那么又要如何方便地读取配置信息呢？我的方法是在&lt;code>config/iniitializers/&lt;/code>目录下新建了一个initializer，主要用于在项目启动时加载配置信息，关键代码段：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">RemoteDatabase&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> &lt;span style="font-weight:bold">self&lt;/span>.fields_map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> @fields_map &lt;span style="font-weight:bold">if&lt;/span> @fields_map
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @fields_map ||=
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> YAML::load_file(Rails.root.join(&lt;span style="font-style:italic">&amp;#39;config&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;local_to_remote_oracle_database_map.yml&amp;#39;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>所以，以后只要使用&lt;code>RemoteDatabase.fields_map&lt;/code>就能读取到所有数据字段映射关系了！&lt;/p>
&lt;p>万事俱备之后，我最后需要做的事情就是把Concern中的常量替换为从YAML中读取到的配置就好了，重构后的代码为：&lt;/p>
&lt;pre tabindex="0">&lt;code>module ImportDataConcern
extend ActiveSupport::Concern
module ClassMethods
def importing_fields_map
return @fields_map if @fields_map
@fields_map =
RemoteDatabase.fields_map[:default].merge(
RemoteDatabase.fields_map[:models][self.name.underscore]
)
end
def import_data_from_remote
remote_objects = remote_database[importing_fields_map[:remote_table_name]].page(page)
remote_objects.each do |remote_object|
# 通过值唯一的属性查找对象
remote_unique_field_name = importing_fields_map[:remote_unique_field_name]
remote_unique_field = remote_object[importing_fields_map[:local_to_remote_fields_map][remote_unique_field_name]]
local_object = find_or_initialize_by(remote_unique_field_name =&amp;gt; remote_unique_field)
local_to_remote_fields_map = importing_fields_map[:local_to_remote_fields_map]
# 逐一设置本地对象需要对接的各个属性
local_to_remote_fields_map.keys.each do |attribute|
local_object.send(&amp;#34;#{attribute}=&amp;#34;, remote_object[importing_fields_map[:local_to_remote_fields_map][attribute]])
end
# ... 关联关系的保存
next unless local_object.changes.any?
local_object.save
end
end
end
end
&lt;/code>&lt;/pre>&lt;p>上面代码中，&lt;code>importing_fields_map&lt;/code>读取与当前Model匹配的字段映射关系，其内部先通过&lt;code>RemoteDatabase.fields_map[:default]&lt;/code>加载了默认的配置，然后通过merge&lt;code>RemoteDatabase.fields_map[:models][self.name.underscore]&lt;/code>得到当前model专属的配置，其中的&lt;code>self.name.underscore&lt;/code>的值类似于&lt;code>'student'&lt;/code>或者&lt;code>'teacher'&lt;/code>。&lt;/p>
&lt;p>在后续的代码中，基本跟前面列举的代码一致，只是将各种常量对应替换为通过&lt;code>local_to_remote_fields_map&lt;/code>存储的配置，并且删除&lt;code>Student&lt;/code>以及&lt;code>Teacher&lt;/code>的多余常量，在此就不列举示例代码了。&lt;/p>
&lt;p>在整个重构的过程中，代码是越来越抽象的，但是代码本身却也因此变得越来越灵活，而至此，我们已经完全将字段映射关系从Ruby代码中剥离，假使以后还需要导入其他数据，我们只需要修改YAML文件，而不再需要碰任何Ruby代码，除非我们需要修改配置项的结构。&lt;/p>
&lt;h3 id="收获重构后的果实专业数据的导入">收获重构后的果实：专业数据的导入&lt;/h3>
&lt;p>在经历过了几次重构后，今天开始导入学生专业的数据，而我所需要做的全部事情，仅仅只是在yaml文件中加入专业相关的配置，并且在专业的model&lt;code>Major&lt;/code>include一下数据导入的Concern就行了。整个过程几分钟就完成了，简直丝般顺滑啊！&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>最后简单总结一下重构完的代码的特点吧：&lt;/p>
&lt;ul>
&lt;li>避免了在model或者concern中生命一堆常量或者方法，到处定义的常量会让映射关系的管理非常分散&lt;/li>
&lt;li>避免不同命名空间下的同名常量，比如&lt;code>Student::LOCAL_TO_REMOTE_FIELDS_MAP&lt;/code>以及&lt;code>Teacher::LOCAL_TO_REMOTE_FIELDS_MAP&lt;/code>&lt;/li>
&lt;li>更集中的字段映射关系配置，避免错漏&lt;/li>
&lt;li>逻辑跟映射关系解耦，更简洁稳健的代码&lt;/li>
&lt;li>自适应新的数据表导入，不需要再修改或者添加Ruby代码，配置即插即用&lt;/li>
&lt;/ul>
&lt;h3 id="问题">问题&lt;/h3>
&lt;ul>
&lt;li>如果涉及复杂关联，如何更好地扩展？
现在的数据对接是有限制的，就是数据本身比较规则，几乎是一张表到一张表的对接，但是如果涉及一张表到多张表之间的对接，是否可以继续再将以上代码扩展？&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>说是基本数据，是因为这篇文章介绍的方案目前仅针对数据关联不是特别复杂的场景，而且介绍的场景，数据的导入也比较简单，基本是从远程数据库中取值，然后再直接赋值到项目数据库的记录中。对于需要在数据导入过程中做复杂的数据分析的案例，我暂时也没有尝试过，不过我预计可以尝试使用Ruby中的代码块的方式解决，但是在此不赘述。&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>sublime text 2基于语法的配置文件</title><link>https://blog.hackerpie.com/posts/archive/sublime-text-2ji-yu-yu-fa-de-pei-zhi-wen-jian/</link><pubDate>Sun, 03 Aug 2014 23:13:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sublime-text-2ji-yu-yu-fa-de-pei-zhi-wen-jian/</guid><description>&lt;p>最近在学习Python编程语言，但是遇到一个小小的问题，就是原来Ruby的编码规范是用2个空格缩进的，所以以前在Sublime的全局用户配置中设置了&lt;code>&amp;quot;tab_size&amp;quot;: 2&lt;/code>，所以在编辑Python文件的时候就每次都要从菜单中设置&lt;code>tab_size&lt;/code>的大小为4。后来经过搜索，发现Sublime Text 2实际上是支持语法特定的配置的，具体的步骤是：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ol>
&lt;li>
&lt;p>先打开一个Python代码文件，或者是设置当前文件的语法为&amp;quot;Python&amp;quot;；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击菜单栏中的“Sublime Text 2 -&amp;gt; Preferences -&amp;gt; Settings - More -&amp;gt; Syntax Specific - User”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以看到打开了一个名字为&amp;quot;Python.sublime-setting&amp;quot;的文件，如果打开的文件的名字不是Python，请回头检查第一步。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在打开的特定语言的配置文件中，直接设置:&lt;/p>
&lt;pre tabindex="0">&lt;code>{ &amp;#34;tab_size&amp;#34;: 4, &amp;#34;translate_tabs_to_spaces&amp;#34;: true }
&lt;/code>&lt;/pre>&lt;p>以上的设置会默认覆盖全局配置。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上步骤参考自&lt;a href="http://lukecafe.com/2013/03/daily-tips-sublime-text2-setting-and-ipa-generation/">今日技巧：Sublime Text 2语法缩进配置和ipa文件生成&lt;/a>。&lt;/p></description></item><item><title>Spree 2.3.0已经发布</title><link>https://blog.hackerpie.com/posts/archive/spree-2-dot-3-0yi-jing-fa-bu/</link><pubDate>Mon, 28 Jul 2014 21:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/spree-2-dot-3-0yi-jing-fa-bu/</guid><description>&lt;p>**声明：**原文来自Spree官方博客&lt;a href="http://spreecommerce.com/blog/spree-2-3-released">Spree 2.3.0 Released&lt;/a>，原文发布日期是2014-06-30，本文仅作翻译。&lt;/p>
&lt;p>&lt;strong>简要介绍：&lt;/strong>&lt;a href="http://spreecommerce.com/">Spree&lt;/a>是一个基于&lt;a href="http://rubyonrails.org/">Ruby on Rails&lt;/a>开发的开源在线商城框架，提供了从商品展示购买、下单支付到库存管理以及订单管理等一系列基本功能，并且支持通过第三方扩展的形式定制或者扩展框架的功能，最新版本的Spree已经支持最新的Rails版本。&lt;/p>
&lt;p>Spree 2.3的最新更改已经加入对Rails 4.1的支持，提供了更好的配置项的存储，更好的针对多店铺的支持，以及更好的游客追踪。Spree 2.3的发布，有赖于总的97位贡献者以及他们总的700多个的commit记录。现在，我们非常兴奋地宣布：Spree 2.3发布了！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="rails-41-的支持">Rails 4.1 的支持&lt;/h3>
&lt;p>现在，Rails 4.1已经得到了Spree 2.3的支持。如果你希望基于Rails 4.1进行开发，那么Spree 2.3就是特为你准备的发布版。&lt;/p>
&lt;h3 id="基于序列化记录的配置项">基于序列化记录的配置项&lt;/h3>
&lt;p>现在，所有的配置项存储在一个记录上，而不是存储在&lt;code>spree_preferences&lt;/code>表中。这意味着，为了获取一个配置项，比如价格的计算器配置，就会触发一个数据库查询，所查询的那一行记录有一个包含了所有配置信息的命名为&lt;code>preferences&lt;/code>的列。&lt;/p>
&lt;p>而在此之前，对于每一个配置记录本身，可能都会有一个单独的数据库调用，而在查询到所请求的配置项之后，还是有可能会有任意数目的数据库调用产生。而现在，我们总的只需要调用一次，这意味着程序本身将会有一些速度上的提升。&lt;/p>
&lt;h3 id="更好的多店铺支持">更好的多店铺支持&lt;/h3>
&lt;p>我们已经添加了一个名为&lt;code>Spree::Store&lt;/code>的model，用于支持基本的多店铺/多域名的站点。其在&lt;code>spree-multi-domain&lt;/code>这个扩展的基础上提供了针对多店铺/多域名的基本框架。一些原有的配置项被转移到了这个model上，以此实现根据具体的店铺提供不同配置值：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Spree::Config[:site_name]&lt;/code> 迁移到了 &lt;code>name&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:site_url]&lt;/code> 迁移到了 &lt;code>url&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_meta_description]&lt;/code> 迁移到了 &lt;code>meta_description&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_meta_keywords]&lt;/code> 迁移到了 &lt;code>meta_keywords&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_seo_title]&lt;/code> 迁移到了 &lt;code>seo_title&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>一个数据库迁移文件将会负责把这些原有的配置项转移到一个新的默认的store实例上。&lt;/p>
&lt;p>一个新的名为&lt;code>ControllerHelpers::Store&lt;/code>的Concern提供了一个&lt;code>current_store&lt;/code>helper，可以在请求的域名的基础上，通过它获取当前店铺。&lt;/p>
&lt;h3 id="更好的游客追踪">更好的游客追踪&lt;/h3>
&lt;p>现在，我们用了一个签名的cookie在浏览器中存储游客的唯一的token。通过它允许关闭了浏览器的顾客可以在再次访问时继续完成他们的购物流程。更重要的是，这也帮助作为商店主人的你方便地识别游客的订单。由于我们在访客来访时都会设置&lt;code>cookies.signed[:guest_token]&lt;/code>，所以除了订单，或许你可以把cookie用于其他用途。&lt;/p>
&lt;p>举个实际例子，如果游客需要收藏一个商品，你可以创建一个用于记录收藏记录的model，然后把&lt;code>cookies.signed[:guest_token]&lt;/code>赋值给这个model中的&lt;code>token&lt;/code>字段。这将有助于你分析当前用户在此之前的订单以及收藏记录，这对于商品推荐将是非常有用的。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>你可以从&lt;a href="https://github.com/spree/spree/releases/tag/v2.3.0">Github&lt;/a>上浏览更详细的变更列表。&lt;/p></description></item><item><title>Run a shell script auto-matically when entering/cd a directory</title><link>https://blog.hackerpie.com/posts/archive/run-a-shell-script-auto-matically-when-entering-a-directory/</link><pubDate>Sun, 04 May 2014 10:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/run-a-shell-script-auto-matically-when-entering-a-directory/</guid><description>&lt;p>I don&amp;rsquo;t know if it is common that you need to run some shell scripts which are used under only some directories, such as, one of your Rails projects.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Today I find that I always need to run &lt;code>rspec&lt;/code> command with a &lt;code>SPEC&lt;/code> option, which specifies spec files to be run. In short, everytime I should type the following command in my terminal:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>rake spec SPEC=spec/lib/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It is convenient to run this command as an &lt;strong>alias&lt;/strong>, but I don&amp;rsquo;t want to write this alias into the &lt;code>~/.bash_profile&lt;/code>, because it should be available under the current directory only. But how?&lt;/p>
&lt;p>Thanks to the powerful bash shell and its function, we can rewrite the built-in &lt;code>cd&lt;/code> command through a function named &lt;strong>cd&lt;/strong>. The following are steps:&lt;/p>
&lt;ol>
&lt;li>Open your &lt;code>~/.bash_profile&lt;/code>, and insert:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">function&lt;/span> cd {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># actually change the directory with all args passed to the function&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> builtin cd &lt;span style="font-style:italic">&amp;#34;&lt;/span>$@&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># if there&amp;#39;s a regular file named &amp;#34;.bash_local&amp;#34;...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> [ -f &lt;span style="font-style:italic">&amp;#34;.bash_local&amp;#34;&lt;/span> ] ; &lt;span style="font-weight:bold">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># source its contents&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> source .bash_local
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>And then source it in your terminal:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ source ~/.bash_profile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>Create new file named &lt;code>.bash_local&lt;/code> under your target directories(on my machine, it is &lt;code>~/development/rails-dev/graduation-project/&lt;/code>), and then insert:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>alias rspec_lib=&lt;span style="font-style:italic">&amp;#39;rake spec SPEC=spec/lib/&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>Now cd the directory, and the alias &lt;code>rspec_lib&lt;/code> will be available auto-matically:&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cd ~/development/rails-dev/graduation-project/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ rspec_lib
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; .....
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Finished in 0.00617 seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>5 examples, 0 failures
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Randomized with seed 23543
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="tips">Tips&lt;/h3>
&lt;p>Please consider if it is necessary to check &lt;code>.bash_local&lt;/code> into your git repo. If not, remember to add it to the &lt;code>.gitignore&lt;/code> file.&lt;/p>
&lt;h3 id="todo">TODO&lt;/h3>
&lt;p>When leave the directory, how to &lt;strong>&amp;ldquo;un-source&amp;rdquo;&lt;/strong> the sourced file, that is, make &lt;code>rspec_lib&lt;/code> unavailable?&lt;/p>
&lt;h3 id="related-links">Related Links&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="http://superuser.com/questions/283352/how-do-you-run-a-shell-command-script-automatically-when-entering-cd-ing-a-direc">How do you run a shell command/script automatically when entering/cd-ing a directory on Snow Leopard?&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://stackoverflow.com/questions/8760505/is-it-possible-to-unsource-in-bash">Is it possible to “unsource” in bash?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Gemfile指定gem来源的四种方式</title><link>https://blog.hackerpie.com/posts/archive/gemfilezhi-ding-gemlai-yuan-de-si-chong-fang-shi/</link><pubDate>Thu, 03 Apr 2014 00:30:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/gemfilezhi-ding-gemlai-yuan-de-si-chong-fang-shi/</guid><description>&lt;p>Gemfile的作用无非就是告诉bundler你的项目具体都需要哪些gem，这些gem都需要哪些版本，以及从哪获取这些gem。其实你的问题应该就是跟第三点有关，总的来说，gem的来源可以有四种：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4 id="1-从镜像源安装">1. 从镜像源安装&lt;/h4>
&lt;p>这个是最直接的，通过这种方式指定的gem，bundler会从文件开头的&lt;code>source&lt;/code>中去查找这个gem：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>source &lt;span style="font-style:italic">&amp;#39;https://rubygems.org&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;rails&amp;#39;&lt;/span> &lt;span style="font-style:italic"># this gem will be installed from https://rubygems.org&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-从git代码库安装">2. 从git代码库安装&lt;/h4>
&lt;p>通过在&lt;code>gem&lt;/code>方法（Gemfile实际上就是一个ruby的代码文件）中指定&lt;code>git&lt;/code>参数，可以使bundler从指定的远程代码库上拉取代码，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># nokogiri will be installed from git://github.com/tenderlove/nokogiri.git&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;nokogiri&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:git&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;git://github.com/tenderlove/nokogiri.git&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-从github安装">3. 从github安装&lt;/h4>
&lt;p>上面第2种方法只是针对所有合法的git代码库（不仅仅是github，也可以是你自己的一个git服务器上一个代码库）而言，而如果你所需要的库来自于github，则可以通过更方便的&lt;code>github&lt;/code>参数实现目标:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;nokogiri&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:github&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;tenderlove/nokogiri&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，只要指定了&lt;code>author/repo_name&lt;/code>的形式，bundler就能自动从github上获取你所需要的gem了。
&lt;strong>注意&lt;/strong>: 第2跟第3种方式还都可以通过&lt;code>branch&lt;/code>参数指定你所需要的代码分支，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;refinerycms&amp;#39;&lt;/span>, &lt;span style="font-style:italic">github&lt;/span>: &lt;span style="font-style:italic">&amp;#39;refinery/refinerycms&amp;#39;&lt;/span>, &lt;span style="font-style:italic">branch&lt;/span>: &lt;span style="font-style:italic">&amp;#39;master&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="4-从文件系统中安装">4. 从文件系统中安装&lt;/h4>
&lt;p>假如你有一个已经放在项目目录中（其实可以是任何地方）的gem，则可以通过&lt;code>path&lt;/code>参数指定所需的gem在文件系统中的位置，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#34;rails&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:path&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#34;vendor/rails&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bundler将会根据path指定的路径去查找并且安装gem。&lt;/p>
&lt;h3 id="最后说一下">最后说一下&lt;/h3>
&lt;p>最后顺便说下我的一点体会，一般像这种gem来自于项目目录下的情况，大多是因为项目中用到了一些提供扩展机制的框架，比如&lt;strong>Spree&lt;/strong>以及&lt;strong>Refinery&lt;/strong>，这两者生成的扩展或者子Engine都是以gem的形式放在vendor或者lib目录下，然后从Gemfile里边进行指定，比如我的一个项目中的一个实例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;refinerycms-factories&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:path&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;vendor/extensions&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>refinerycms-factories是我用Refinery的generator生成的一个子engine，默认放在&lt;code>verdor/extensions&lt;/code>目录下。&lt;/p>
&lt;p>另一种可能比较常见的情况就是你用到了某个可能不再维护的gem，由于对源代码的改动较大，所以你干脆把这个gem的源代码下载到本地项目目录下，然后直接进行修改，最后通过&lt;code>path&lt;/code>去安装。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;p>关于Gemfiile的更多资料，请自行猛戳：
&lt;a href="http://bundler.io/v1.5/gemfile.html">Bundler homepage&lt;/a>
&lt;a href="http://bundler.io/v1.5/man/gemfile.5.html">Gemfile manual page&lt;/a>&lt;/p></description></item><item><title>Ruby中Hash的7个日常使用范例</title><link>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</link><pubDate>Tue, 25 Mar 2014 20:05:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</guid><description>&lt;p>此文翻译自&lt;a href="http://blog.8thcolor.com/en/2014/03/7-daily-use-cases-of-ruby-hash/?utm_source=rubyweekly&amp;amp;utm_medium=email#json-to-hash">7 daily use cases of Ruby Hash&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>每一天，你都需要跟Hash相处。创建一个新的Hash或者是通过它的某一个键去检索其中的元素这样的工作，都是常见也是非常简单的。但是当你需要合并两个嵌套的Hash或者是从某一个Hash里边过滤某些键，你可能需要考虑得多一点。通过完整的&lt;a href="http://ruby-doc.org/">文档&lt;/a>，你可以找到对Hash中的每一个方法的充分解释。但是由于文档不是面向应用场景的，你可能没法很快找到你的解决方案。在下面，我分享了我日常中经常遇到的Hash中的7个常用场景，希望它们对你有用。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="1-如何将一个json转换为一个hash">1. 如何将一个JSON转换为一个Hash？&lt;/h2>
&lt;p>假设你刚刚接收到一个用JSON表示的Twitter账号的资料信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="">data&lt;/span> &lt;span style="">=&lt;/span> &lt;span style="">&amp;#39;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Aaron Patterson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;screen_name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tenderlove&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;location&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Seattle, WA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你希望能够将它转化为一个Hash,这样会更方便你进行对数据的操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>profile = JSON.parse(data)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 在IRB中的输出结果：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Aaron Patterson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;screen_name&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;tenderlove&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;location&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Seattle, WA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-parse">JSON#parse&lt;/a>&lt;/p>
&lt;h2 id="2-如何将一个hash转换为一个json">2. 如何将一个Hash转换为一个JSON？&lt;/h2>
&lt;p>在你的web应用程序中，你需要追踪当前星期每一天新注册用户的数量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>signups_of_the_week = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">monday&lt;/span>: 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">tuesday&lt;/span>: 3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">wednesday&lt;/span>: 4,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">thursday&lt;/span>: 20,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">friday&lt;/span>: 5,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">saturday&lt;/span>: 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">sunday&lt;/span>: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过API的方式把它们以JSON格式提供给客户端：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signups_of_the_week.to_json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 在IRB中的输出结果：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="font-style:italic">&amp;#34;{&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">monday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:2,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">tuesday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:3,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">wednesday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:4,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">thursday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:20,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">friday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:5,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">saturday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:2,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">sunday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:5}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-generate">JSON#generate&lt;/a>
边注：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-pretty_generate">JSON#pretty_generate&lt;/a>对于更好的打印以及调试非常有用。&lt;/p>
&lt;h2 id="3-如何为一个嵌套的hash设置默认值">3. 如何为一个嵌套的Hash设置默认值？&lt;/h2>
&lt;p>你有一个以name为索引的联系人的集合，也就是一个嵌套的Hash：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>contacts = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;John&amp;#39;&lt;/span> =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">&amp;#39;John&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">email&lt;/span>: &lt;span style="font-style:italic">&amp;#39;john@doe.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#39;Freddy&amp;#39;&lt;/span> =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name &lt;span style="font-style:italic">&amp;#39;Freddy&amp;#39;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">email&lt;/span>: &lt;span style="font-style:italic">&amp;#39;freddy@mercury.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你在处理单个联系人的时候，你不需要每一次都检查它是否存在。你只需要写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>contacts[&lt;span style="font-style:italic">&amp;#39;Jane&amp;#39;&lt;/span>][&lt;span style="font-style:italic">:email&lt;/span>] = &lt;span style="font-style:italic">&amp;#39;jane@doe.com&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>puts contacts[&lt;span style="font-style:italic">&amp;#39;Jane&amp;#39;&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** IRB输出 **:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {&lt;span style="font-style:italic">:name&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Jane&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:email&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;jane@doe.com&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以在创建Hash的时候通过设置代码块来实现默认值：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>contacts = Hash.new &lt;span style="font-weight:bold">do&lt;/span> |hsh, key|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hsh[key] = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: key,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">email&lt;/span>: &lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者是使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>contacts.default_proc = Proc.new &lt;span style="font-weight:bold">do&lt;/span> |hsh, key|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>hsh[key] = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>name: key,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">email&lt;/span>: &lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-c-new">Hash#new&lt;/a>, &lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-default_proc-3D">Hash#default_proc&lt;/a>&lt;/p>
&lt;h2 id="4-如何合并两个嵌套的hash">4. 如何合并两个嵌套的Hash？&lt;/h2>
&lt;p>在一个在线商店里，你想要将一个心愿单与当前的购物篮进行合并，这两者都是以商品的id号作为索引：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>wish_list = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>8 =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">title&lt;/span>: &lt;span style="font-style:italic">&amp;#34;The Color of Magic&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>42 =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">title&lt;/span>: &lt;span style="font-style:italic">&amp;#34;The Hitch-Hiker&amp;#39;s Guide to the Galaxy&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">price&lt;/span>: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style=""> &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>basket = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>8 =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">price&lt;/span>: 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>1729 =&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>&lt;span style="font-style:italic">title&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Ramanujan:  Twelve Lectures on Subjects Suggested by His Life and Work&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">price&lt;/span>: 28
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>借助于ActiveSupport,你可以简单地实现你的目标：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;active_support/core_ext/hash&amp;#39;&lt;/span> &lt;span style="font-style:italic"># not necessary if in Rails&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style=""> &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>basket.deep_merge(wish_list)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>又或者，在没有ActiveSupport的情况下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> deep_merge(h1, h2)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>h1.merge(h2) { |key, h1_elem, h2_elem| deep_merge(h1_elem, h2_elem) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style=""> &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deep_merge(basket, wish_list)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** IRB输出: **&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 8=&amp;gt;{&lt;span style="font-style:italic">:price&lt;/span>=&amp;gt;10, &lt;span style="font-style:italic">:title&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;The Color of Magic&amp;#34;&lt;/span>},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1729=&amp;gt;{&lt;span style="font-style:italic">:title&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Ramanujan: Twelve Lectures on Subjects Suggested by His Life and Work&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:price&lt;/span>=&amp;gt;28},
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 42=&amp;gt;{&lt;span style="font-style:italic">:title&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;The Hitch-Hiker&amp;#39;s Guide to the Galaxy&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:price&lt;/span>=&amp;gt;5}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-merge">Hash#merge&lt;/a>, &lt;a href="http://api.rubyonrails.org/classes/Hash.html#method-i-deep_merge">Hash#deep_merge&lt;/a>&lt;/p>
&lt;h2 id="5-如何过滤掉一个hash中的某些key">5. 如何过滤掉一个Hash中的某些key？&lt;/h2>
&lt;p>你已经创建了一个表示日销售额的矩形图，并且你将它以Hash的方式存储，每一天就是一个key：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>histogram = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">monday&lt;/span>: 5,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">tuesday&lt;/span>: 7,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">wednesday&lt;/span>: 10,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">thursday&lt;/span>: 18,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">friday&lt;/span>: 7,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">saturday&lt;/span>: 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">sunday&lt;/span>: 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你想从中过滤掉Saturday以及Sunday。通过ActiveSupport，你可以像下面这样做：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;active_support/core_ext/hash&amp;#39;&lt;/span> &lt;span style="font-style:italic"># not necessary if Rails&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style=""> &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>histogram.except(&lt;span style="font-style:italic">:saturday&lt;/span>, &lt;span style="font-style:italic">:sunday&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>或者在没有ActiveSupport的情况下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> filter(hsh, *keys)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>hsh.dup.tap &lt;span style="font-weight:bold">do&lt;/span> |h|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">    &lt;/span>keys.each { |k| h.delete(k) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style=""> &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>filter(histogram, &lt;span style="font-style:italic">:saturday&lt;/span>, &lt;span style="font-style:italic">:sunday&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>另一个简洁点实现则是基于&lt;code>reject&lt;/code>方法的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> filter2(hsh, *keys)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>hsh.reject { |k, _| keys.include? k }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意，如果你正在处理一个比较大的集合，你最好是先衡量下你的实现，一次选择最好的其中一个实现。
** IRB输出：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {&lt;span style="font-style:italic">:monday&lt;/span>=&amp;gt;5, &lt;span style="font-style:italic">:tuesday&lt;/span>=&amp;gt;7, &lt;span style="font-style:italic">:wednesday&lt;/span>=&amp;gt;10, &lt;span style="font-style:italic">:thursday&lt;/span>=&amp;gt;18, &lt;span style="font-style:italic">:friday&lt;/span>=&amp;gt;7}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://api.rubyonrails.org/classes/Hash.html#method-i-except">Hash#except&lt;/a>, &lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-delete">Hash#delete&lt;/a>, &lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-reject">Hash#reject&lt;/a>, &lt;a href="http://www.ruby-doc.org/core-2.1.0/Object.html#method-i-dup">Object#dup&lt;/a>, &lt;a href="http://www.ruby-doc.org/core-2.1.0/Object.html#method-i-tap">Object#tap&lt;/a>&lt;/p>
&lt;h2 id="6-如何通过value对一个hash进行排序">6. 如何通过value对一个Hash进行“排序”？&lt;/h2>
&lt;p>在一个骰子类游戏中，你在Hash中储存了每一个选手的得分：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>scores = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">&amp;#39;The Lady&amp;#39;&lt;/span> =&amp;gt; 3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">&amp;#39;Fate&amp;#39;&lt;/span> =&amp;gt; 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>&lt;span style="font-style:italic">&amp;#39;Death&amp;#39;&lt;/span> =&amp;gt; 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你想要通过他们的得分对他们进行排序。你可以这样做：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>leaderboard = scores.sort_by { |_, score| -score }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** IRB输出：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; [[&lt;span style="font-style:italic">&amp;#34;Death&amp;#34;&lt;/span>, 10], [&lt;span style="font-style:italic">&amp;#34;The Lady&amp;#34;&lt;/span>, 3], [&lt;span style="font-style:italic">&amp;#34;Fate&amp;#34;&lt;/span>, 2]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://ruby-doc.org/core-2.1.0/Enumerable.html#method-i-sort_by">Enumerable#sort_by&lt;/a>
边注：Hash通过元素插入时的顺序去枚举它们的值。&lt;/p>
&lt;h2 id="7-如何找出两个hash中的不同">7. 如何找出两个Hash中的不同？&lt;/h2>
&lt;p>假设你定期地从RSS订阅源中读取数据，并且将他们放在了一个Hash里边：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>entries = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1372284000 =&amp;gt; &lt;span style="font-style:italic">&amp;#34;CVE-2013-4073&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 1368482400 =&amp;gt; &lt;span style="font-style:italic">&amp;#34;CVE-2013-2065&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你更新了之后，你可能得到另一个Hash：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>updated_entries = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>1385074800 =&amp;gt; &lt;span style="font-style:italic">&amp;#34;CVE-2013-4164&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>1372284000 =&amp;gt; &lt;span style="font-style:italic">&amp;#34;CVE-2013-4073&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="">  &lt;/span>1368482400 =&amp;gt; &lt;span style="font-style:italic">&amp;#34;CVE-2013-2065&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你想要查找出哪一条记录才是新加的，这样你就可以通过email的方式将它们发送出去。最好的解决方案是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>new_entries = updated_entries.reject { |k, _| entries.include? k }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** IRB输出：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {1385074800=&amp;gt;&lt;span style="font-style:italic">&amp;#34;CVE-2013-4164&amp;#34;&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/core-2.1.0/Hash.html#method-i-include-3F">Hash#include?&lt;/a>&lt;/p></description></item><item><title>注意Rake Task中invoke方法跟execute方法的不同</title><link>https://blog.hackerpie.com/posts/archive/zhu-yi-rake-taskzhong-invokegen-executefang-fa-de-bu-tong/</link><pubDate>Fri, 21 Mar 2014 01:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhu-yi-rake-taskzhong-invokegen-executefang-fa-de-bu-tong/</guid><description>&lt;p>平时如果跟Rake Task有过接触的同学都会知道，当我们需要在一个Task里边调用另一个Task的时候，我们可以使用&lt;code>Rake::Task['task_name'].invoke&lt;/code>的方式。但是在今天的实践中，才知道&lt;code>Rake::Task#invoke&lt;/code>在默认情况下在整个运行过程中将只会被调用一次而已。话不多说，动手演示：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>准备一个&lt;strong>say hello&lt;/strong>的task，代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># lib/tasks/demo.rake&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello&amp;#39; string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Hello, World!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来在命令行中执行rake task:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设我们一个循环，需要调用上边的task共5次，那么我们可能会这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello, World!&amp;#39; five times&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_five_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rake::Task[&lt;span style="font-style:italic">&amp;#39;demo:say_hello&amp;#39;&lt;/span>].invoke
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok, 让我们尝试着运行这个&lt;code>say_five_hello&lt;/code>的task，是不是真的会打印5次&amp;rsquo;Hello, World!&amp;lsquo;呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_five_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果就是，&amp;lsquo;Hello, World!&amp;lsquo;只打印了一次，也就是说，我们的&lt;code>Rake::Task['demo:say_hello']&lt;/code>只被运行了一次。&lt;/p>
&lt;p>经过搜索，从StackOverflow找到了这个问题的相关描述，详见：&lt;a href="http://stackoverflow.com/a/12948485">How do I execute Rake tasks with arguments multiple times?&lt;/a>&lt;/p>
&lt;p>按照答案中的描述，我们有两种修改方案。第一种就是将上述代码进行修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello, World!&amp;#39; five times&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_five_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rake::Task[&lt;span style="font-style:italic">&amp;#39;demo:say_hello&amp;#39;&lt;/span>].execute
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次运行，这次总算得到期待结果了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_five_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>而第二种方法则会稍微麻烦一点：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello, World!&amp;#39; five times&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_five_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rake::Task[&lt;span style="font-style:italic">&amp;#39;demo:say_hello&amp;#39;&lt;/span>].reenable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rake::Task[&lt;span style="font-style:italic">&amp;#39;demo:say_hello&amp;#39;&lt;/span>].invoke
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>再次执行rake task, 同样能够得到预期结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_five_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="未完待续">未完待续&lt;/h3>
&lt;p>针对重复调用的行为上的不同只是&lt;code>invoke&lt;/code>以及&lt;code>execute&lt;/code>方法之间的一个基本差异而已，那第一种方案跟第二种方案的差异又有什么不同？在带参数的情况下，又该如何考虑两个方法之间的差异？&lt;/p>
&lt;p>&lt;a href="http://rake.rubyforge.org/classes/Rake/Task.html">Rake::Task source code&lt;/a>&lt;/p></description></item><item><title>属性方法</title><link>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</link><pubDate>Wed, 12 Mar 2014 20:58:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails - Attribute Methods&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>在我们&lt;a href="https://blog.hackerpie.com/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨&lt;/a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似&lt;code>attribute_method_suffix&lt;/code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似&lt;code>name&lt;/code>这样的模型属性以及对应生成的类似&lt;code>name_changed?&lt;/code>这样的方法的。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="声明declarations">声明（Declarations）&lt;/h3>
&lt;p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，&lt;code>attribute_method_suffix&lt;/code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在&lt;a href="https://blog.hackerpie.com/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论&lt;/a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个&lt;code>_changed?&lt;/code>方法(&lt;strong>提示&lt;/strong>： 命令行中键入&lt;code>qw activemodel&lt;/code>查看代码)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Dirty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ActiveModel::AttributeMethods
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_suffix &lt;span style="font-style:italic">&amp;#39;_changed?&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_change&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_will_change!&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_was&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们打开ActiveModel库中的&lt;code>attribute_methods.rb&lt;/code>文件，并且看一下到底发生了什么事情。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_method_suffix(*suffixes)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.attribute_method_matchers += suffixes.map! &lt;span style="font-weight:bold">do&lt;/span> |suffix|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AttributeMethodMatcher.new &lt;span style="font-style:italic">suffix&lt;/span>: suffix
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你调用&lt;code>attribute_method_suffix&lt;/code>方法的时候，每一个后缀都通过&lt;code>map!&lt;/code>方法转换为一个&lt;code>AttributeMethodMatcher&lt;/code>对象。这些对象会被存储在&lt;code>attribute_method_matchers&lt;/code>中。如果你重新看一下这个module的顶部，你会发现&lt;code>attribute_method_matchers&lt;/code>是在每一个包含此module的类中使用&lt;code>class_attribute&lt;/code>定义的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">AttributeMethods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_attribute &lt;span style="font-style:italic">:attribute_aliases&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:attribute_method_matchers&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">instance_writer&lt;/span>: &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>class_attribute&lt;/code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Person&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_attribute &lt;span style="font-style:italic">:database&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Employee&lt;/span> &amp;lt; Person
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Person.database = Sql.new(&lt;span style="font-style:italic">:host&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#39;localhost&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Employee.database &lt;span style="font-style:italic">#=&amp;gt; &amp;lt;Sql:host=&amp;#39;localhost&amp;#39;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ruby中并没有&lt;code>class_attribute&lt;/code>的内置实现，它是在ActiveSupport(&lt;strong>提示&lt;/strong>:命令行中键入&lt;code>qw activesupport&lt;/code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下&lt;code>attribute.rb&lt;/code>&lt;/p>
&lt;p>现在我们来看一下&lt;code>AttributeMethodMatcher&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">AttributeMethodMatcher&lt;/span> &lt;span style="font-style:italic">#:nodoc:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">attr_reader&lt;/span> &lt;span style="font-style:italic">:prefix&lt;/span>, &lt;span style="font-style:italic">:suffix&lt;/span>, &lt;span style="font-style:italic">:method_missing_target&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> initialize(options = {})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @prefix, @suffix = options.fetch(&lt;span style="font-style:italic">:prefix&lt;/span>, &lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>), options.fetch(&lt;span style="font-style:italic">:suffix&lt;/span>, &lt;span style="font-style:italic">&amp;#39;&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @regex = &lt;span style="font-style:italic">/^(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>Regexp.escape(@prefix)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)(.*)(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>Regexp.escape(@suffix)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)$/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @method_missing_target = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>@prefix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">attribute&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>@suffix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @method_name = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>prefix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">%s&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>suffix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>代码中的&lt;code>prefix&lt;/code>以及&lt;code>suffix&lt;/code>是通过&lt;code>Hash#fetch&lt;/code>方法提取出来的。这会返回一个对应键的值，或者是一个默认值。如果调用方法的时候没有提供默认值，&lt;code>Hash#fetch&lt;/code>方法将会抛出一个异常，提示指定的键不存在。对于options的处理来说是一种不错的模式，特别是对于boolean型数据来说：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>options = {&lt;span style="font-style:italic">:name&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#34;Mortimer&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:imaginary&lt;/span> =&amp;gt; &lt;span style="">false&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Don&amp;#39;t do this:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>options[&lt;span style="font-style:italic">:imaginary&lt;/span>] || &lt;span style="">true&lt;/span> &lt;span style="font-style:italic">#=&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Do this:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>options.fetch(&lt;span style="font-style:italic">:imaginary&lt;/span>, &lt;span style="">true&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; false&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>对于我们的&lt;code>attribute_method_suffix&lt;/code>其中的&lt;code>'_changed'&lt;/code>示例来说，&lt;code>AttributeMethodMatcher&lt;/code>将会有如下的实例变量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>@prefix &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@suffix &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;_changed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@regex &lt;span style="font-style:italic">#=&amp;gt; /^(?:)(.*)(?:_changed\?)$/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@method_missing_target &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;attribute_changed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@method_name &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;%s_changed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你一定想知道&lt;code>%s_changed&lt;/code>中的&lt;code>%s&lt;/code>是用来干什么的吧？这是一个格式化字符串（format string）。你可以使用&lt;code>sprintf&lt;/code>方法对它插入值，或者使用缩写（shortcut）&lt;code>%&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>sprintf(&lt;span style="font-style:italic">&amp;#34;%s_changed?&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;named_changed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&amp;#34;%s_changed?&amp;#34;&lt;/span> % &lt;span style="font-style:italic">&amp;#34;age&amp;#34;&lt;/span> &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;age_changed?&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>第二个比较有趣的地方就是正则表达式创建的方式。请留意创建&lt;code>@regex&lt;/code>变量时&lt;code>Regexp.escape&lt;/code>的用法。如果后缀没有被escape，则正则表达式中带有特殊含义的符号将会被错误解释(misinterpreted)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Don&amp;#39;t do this!&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>regex = &lt;span style="font-style:italic">/^(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>@prefix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)(.*)(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>@suffix&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)$/&lt;/span> &lt;span style="font-style:italic">#=&amp;gt; /^(?:)(.*)(?:_changed?)$/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>regex.match(&lt;span style="font-style:italic">&amp;#34;name_changed?&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>regex.match(&lt;span style="font-style:italic">&amp;#34;name_change&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; #&amp;lt;MatchData &amp;#34;name_change&amp;#34; 1:&amp;#34;name&amp;#34;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Do this:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>@regex = &lt;span style="font-style:italic">/^(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>Regexp.escape(@prefix)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)(.*)(?:&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>Regexp.escape(@suffix)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)$/&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>regex.match(&lt;span style="font-style:italic">&amp;#34;name_changed?&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; #&amp;lt;MatchData &amp;#34;name_changed?&amp;#34; 1:&amp;#34;name&amp;#34;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>regex.match(&lt;span style="font-style:italic">&amp;#34;name_change&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; nil&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请仔细记住&lt;code>regex&lt;/code>以及&lt;code>method_name&lt;/code>，它们可以用来匹配和生成属性方法，我们在后面还会继续用到它们。&lt;/p>
&lt;p>我们现在已经搞明白了属性方法是如何声明的，但是实际中，Rails又是如何使用它们的呢？&lt;/p>
&lt;h3 id="通过method-missing调用invocation-with-method-missing">通过Method Missing调用（Invocation With Method Missing）&lt;/h3>
&lt;p>当我们调用了一个未定义的方法时，Rails将会在抛出异常之前调用对象的&lt;code>method_missing&lt;/code>方法。让我们看看Rails是如何利用这个技巧调用属性方法的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> method_missing(method, *args, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> respond_to_without_attributes?(method, &lt;span style="">true&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">super&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> match = match_attribute_method?(method.to_s)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> match ? attribute_missing(match, *args, &amp;amp;block) : &lt;span style="font-weight:bold">super&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>传给&lt;code>method_missing&lt;/code>方法的第一个参数是一个用symbol类型表示的方法名，比如，我们的&lt;code>:name_changed?&lt;/code>。&lt;code>*args&lt;/code>是（未定义的）方法被调用时传入的所有参数，&lt;code>&amp;amp;block&lt;/code>是一个可选的代码块。Rails首先通过调用&lt;code>respond_to_without_attributes&lt;/code>方法检查是否有别的方法可以对应这次调用。如果别的方法可以处理这次调用，则通过&lt;code>super&lt;/code>方法转移控制权。如果找不到别的方法可以处理当前的调用，ActiveModel则会通过&lt;code>match_attribute_method?&lt;/code>方法检查当前调用的方法是否是一个属性方法。如果是，它则会接着调用&lt;code>attribute_missing&lt;/code>方法。&lt;/p>
&lt;p>&lt;code>match_attribute_method&lt;/code>方法利用了之前声明过的&lt;code>AttributeMethodMatcher&lt;/code>对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> match_attribute_method?(method_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> match = self.class.send(&lt;span style="font-style:italic">:attribute_method_matcher&lt;/span>, method_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> match &lt;span style="font-weight:bold">if&lt;/span> match &amp;amp;&amp;amp; attribute_method?(match.attr_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个方法里边发生了两件事。第一，Rails查找到了一个匹配器(matcher)，并且检查这是否真的是一个属性。说实话，我自己也是比较迷惑，为什么&lt;code>match_attribute_method?&lt;/code>方法调用的是&lt;code>self.class.send(:attribute_method_matcher, method_name)&lt;/code>，而不是&lt;code>self.attribute_method_matcher(method_name)&lt;/code>，但是我们还是可以假设它们的效果是一样的。&lt;/p>
&lt;p>如果我们再接着看&lt;code>attribute_method_matcher&lt;/code>，就会发现它的最核心的代码仅仅只是扫描匹配了&lt;code>AttributeMethodMatcher&lt;/code>实例，它所做的事就是对比对象本身的正则表达式与当前的方法名：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_method_matcher(method_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_matchers.detect { |method| method.match(method_name) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如果Rails找到了匹配当前调用的方法的属性，那么接下来所有参数都会被传递给&lt;code>attribute_missing&lt;/code>方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_missing(match, *args, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> __send__(match.target, match.attr_name, *args, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个方法将匹配到的属性名以及传入的任意参数或者代码块代理给了&lt;code>match.target&lt;/code>。回头看下我们的实例变量，&lt;code>match.target&lt;/code>将会是&lt;code>attribute_changed?&lt;/code>，而且&lt;code>match.attr_name&lt;/code>则是&amp;quot;name&amp;quot;。&lt;code>__send__&lt;/code>方法将会调用&lt;code>attribute_changed?&lt;/code>方法，或者是你定义的任意一个特殊的属性方法。&lt;/p>
&lt;h3 id="元编程metaprogramming">元编程（Metaprogramming）&lt;/h3>
&lt;p>有很多的方式可以对一个方法的调用进行分发（dispatch），如果这个方法经常被调用，那么实现一个&lt;code>name_changed?&lt;/code>方法将会更为有效。Rails通过&lt;code>define_attribute_methods&lt;/code>方法做到了对这类属性方法的自动定义：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> define_attribute_methods(*attr_names)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attr_names.flatten.each { |attr_name| define_attribute_method(attr_name) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> define_attribute_method(attr_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_matchers.each &lt;span style="font-weight:bold">do&lt;/span> |matcher|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method_name = matcher.method_name(attr_name)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> define_proxy_call &lt;span style="">true&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> generated_attribute_methods,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> method_name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> matcher.method_missing_target,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attr_name.to_s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>matcher.method_name&lt;/code>使用了我们前面见到过的格式化字符串，并且插入了&lt;code>attr_name&lt;/code>。在我们的例子中，&lt;code>&amp;quot;%s_changed?&amp;quot;&lt;/code>变成了&lt;code>&amp;quot;name_changed?&amp;quot;&lt;/code>。现在我们我们准备好了了解在&lt;code>define_proxy_call&lt;/code>中的元编程。下面是这个方法被删掉了一些特殊场景下的代码的版本，你可以在阅读完这篇文章后自己去了解更多的代码。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> define_proxy_call(include_private, mod, name, send, *extra)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> defn = &lt;span style="font-style:italic">&amp;#34;def &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">(*args)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> extra = (extra.map!(&amp;amp;&lt;span style="font-style:italic">:inspect&lt;/span>) &amp;lt;&amp;lt; &lt;span style="font-style:italic">&amp;#34;*args&amp;#34;&lt;/span>).join(&lt;span style="font-style:italic">&amp;#34;, &amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>send&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">(&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>extra&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">)&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> mod.module_eval &lt;span style="font-style:italic">&amp;lt;&amp;lt;-RUBY, __FILE__, __LINE__ + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">#{defn}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#{target}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> RUBY
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里为我们定义了一个新的方法。&lt;code>name&lt;/code>就是正要被定义的方法名，而&lt;code>send&lt;/code>则是处理器(handler)，另外的&lt;code>extra&lt;/code>是属性名。&lt;code>mod&lt;/code>参数是一个Rails用&lt;code>generated_attribute_methods&lt;/code>方法生成的特殊的模块（module），它被嵌入（mixin）到我们的类中。现在让我们多看一下&lt;code>module_eval&lt;/code>方法。这里有三件有趣的事情发生了。&lt;/p>
&lt;p>第一件事就是&lt;a href="http://blog.jayfields.com/2006/12/ruby-multiline-strings-here-doc-or.html">HEREDOC&lt;/a>被用作一个参数传给了一个方法。这是有点难懂的，但是对某些场景却是非常有用的。举个例子，想象我们在一个服务器响应(response)中有一个方法要用来嵌入Javascript代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>include_js(&lt;span style="font-style:italic">&amp;lt;&amp;lt;-JS, :minify =&amp;gt; true)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="">$&lt;/span>(&lt;span style="font-style:italic">&amp;#39;#logo&amp;#39;&lt;/span>).show();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> App.refresh();
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JS
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这将会把字符串&lt;code>&amp;quot;$('#logo').show(); App.refresh();&amp;quot;&lt;/code>作为调用&lt;code>include_js&lt;/code>时传入的第一个参数，而&lt;code>:minify =&amp;gt; true&lt;/code>作为第二个参数。在Ruby中需要生成代码时，这是一个非常有用的技巧。值得高兴的是，诸如&lt;a href="https://github.com/textmate/textmate">TextMate&lt;/a>这类编辑器都能够识别这个模式，并且正确地高亮显示字符串。即使你并不需要生成代码，HEREDOC对于多行的字符串也是比较有用的。&lt;/p>
&lt;p>现在我们就知道了&lt;code>&amp;lt;&amp;lt;-RUBY&lt;/code>做了些什么事，但是&lt;code>__FILE__&lt;/code>以及&lt;code>__LINE__ + 1&lt;/code>呢？&lt;code>__FILE__&lt;/code>返回了当前文件的（相对）路径，而&lt;code>__LINE__&lt;/code>返回了当前代码的行号。&lt;code>module_eval&lt;/code>接收这些参数，并通过这些参数决定新的代码定义在文件中“看起来”的位置。在对于栈跟踪（stack traces）来说是特别有用的。&lt;/p>
&lt;p>最后，让我们看一些&lt;code>module_eval&lt;/code>中实际执行的代码。我们可以把值替换成我们的&lt;code>name_changed?&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>mod.module_eval &lt;span style="font-style:italic">&amp;lt;&amp;lt;-RUBY, __FILE__, __LINE__ + 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">def&lt;/span> name_changed?(*args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_changed?(&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>, *args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>RUBY
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在&lt;code>name_changed?&lt;/code>就是一个真实的方法了，比起依赖于&lt;code>method_missing&lt;/code>方法的实现，这种方法的开销要小得多。&lt;/p>
&lt;h3 id="总结recap">总结（Recap）&lt;/h3>
&lt;p>我们发现了调用&lt;code>attribute_method_suffix&lt;/code>方法会保存一个配置好的对象，这个对象用于Rails中两种元编程方法中的一种。不考虑是否使用了&lt;code>method_missing&lt;/code>，或者通过&lt;code>module_eval&lt;/code>定义了新的方法，方法的调用最后总会被传递到诸如&lt;code>attribute_changed?(attr)&lt;/code>这样的方法上。&lt;/p>
&lt;p>走过这次比较宽泛的旅途，我们也收获了一些有用的技巧：&lt;/p>
&lt;ul>
&lt;li>你必须使用&lt;code>Hash#fetch&lt;/code>从options中读取参数，特别是对于boolean类型参数来说。&lt;/li>
&lt;li>诸如&lt;code>&amp;quot;%s_changed&amp;quot;&lt;/code>这样的格式化字符串，可以被用于简单的模板。&lt;/li>
&lt;li>可以使用&lt;code>Regexp.escape&lt;/code>escape正则表达式。&lt;/li>
&lt;li>当你试图调用一个未定义的方法时，Ruby会调用&lt;code>method_missing&lt;/code>方法。&lt;/li>
&lt;li>HEREDOCs可以用在方法参数中，也可以用来定义多行的字符串。&lt;/li>
&lt;li>&lt;code>__FILE__&lt;/code>以及&lt;code>__LINE__&lt;/code>指向当前的文件以及行号。&lt;/li>
&lt;li>你可以使用&lt;code>module_eval&lt;/code>动态生成代码。&lt;/li>
&lt;/ul>
&lt;p>坚持浏览Rails的源代码吧，你总会发现你原本不知道的宝藏！&lt;/p>
&lt;h3 id="喜欢这篇文章">喜欢这篇文章？&lt;/h3>
&lt;p>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多&lt;/a>《解读Rails》中的文章。&lt;/p></description></item><item><title>跟踪model中属性（值）的变更</title><link>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</link><pubDate>Fri, 07 Mar 2014 13:02:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_change_tracking/">Reading Rails - Change Tracking&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>我们今天来看看Rails是如何追踪model里边属性的变更的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>person = Person.find(8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name = &lt;span style="font-style:italic">&amp;#34;Mortimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name_changed? &lt;span style="font-style:italic">#=&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name_was &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;Horton&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.changes &lt;span style="font-style:italic">#=&amp;gt; {&amp;#34;name&amp;#34;=&amp;gt;[&amp;#34;Horton&amp;#34;,&amp;#34;Mortimer&amp;#34;]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.save!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.changes &lt;span style="font-style:italic">#=&amp;gt; {}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>name_changed?&lt;/code>方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="activemodel">ActiveModel&lt;/h3>
&lt;p>当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（&lt;strong>提示&lt;/strong>： 命令行中键入&lt;code>qw activemodel&lt;/code>查看代码）定义了没有与数据库捆绑的逻辑。我们将从&lt;code>dirty.rb&lt;/code>文件开始。在这个模块最开始的地方，代码调用了&lt;code>attribute_method_suffix&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Dirty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ActiveModel::AttributeMethods
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_suffix &lt;span style="font-style:italic">&amp;#39;_changed?&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_change&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_will_change!&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_was&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>attribute_method_suffix&lt;/code>定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似&lt;code>_changed?&lt;/code>后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到&lt;code>def attribute_changed?&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_changed?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> changed_attributes.include?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似&lt;code>name_changed?&lt;/code>的方法时，Rails将会把&lt;code>&amp;quot;name&amp;quot;&lt;/code>作为参数&lt;code>attr&lt;/code>传给上述方法。往回看一点点，你会发现&lt;code>changed_attributes&lt;/code>只是一个包含了从属性名到旧的属性值的映射的&lt;code>Hash&lt;/code>而已：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Returns a hash of the attributes with unsaved changes indicating their original&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># values like &amp;lt;tt&amp;gt;attr =&amp;gt; original value&amp;lt;/tt&amp;gt;.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.name # =&amp;gt; &amp;#34;bob&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.name = &amp;#39;robert&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.changed_attributes # =&amp;gt; {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;bob&amp;#34;}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> changed_attributes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @changed_attributes ||= {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Ruby中，如果你之前都没有见过&lt;code>||=&lt;/code>操作，那么你可能需要了解这其实是一个用于初始化变量值的技巧。当它第一次被访问的时候，变量的值是&lt;code>nil&lt;/code>，所以它返回了一个空的&lt;code>Hash&lt;/code>并且用其初始化&lt;code>@changed_attributes&lt;/code>。当它再一次被访问的时候，&lt;code>@changed_attributes&lt;/code>已经被赋值过了。那么现在我们可以回答我们的第一个问题了，&lt;code>name_changed?&lt;/code>方法被转发到&lt;code>attribute_changed?&lt;/code>方法，而后者会在&lt;code>changed_attributes&lt;/code>中查找特定的值。&lt;/p>
&lt;p>在我们的例子中，我们看到&lt;code>changes&lt;/code>返回一个类似&lt;code>{&amp;quot;name&amp;quot;=&amp;gt;[&amp;quot;Horton&amp;quot;,&amp;quot;Mortimer&amp;quot;]}&lt;/code>这样既包含旧的属性值，又包含新的属性值的&lt;code>Hash&lt;/code>。让我们这又是如何做到的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> changes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActiveSupport::HashWithIndifferentAccess[changed.map { |&lt;span style="">attr&lt;/span>| [&lt;span style="">attr&lt;/span>, attribute_change(&lt;span style="">attr&lt;/span>)] }]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这段代码看起来有点难以理解，但是我们可以一步一步分析。首先我们从&lt;code>ActiveSupport::HashWithIndifferentAccess&lt;/code>开始，这是在ActiveSupport中所定义的&lt;code>Hash&lt;/code>的子类，通过字符串类型或者符号类型的键去访问它将得到一样的结果：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>hash = ActiveSupport::HashWithIndifferentAccess.new
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hash[&lt;span style="font-style:italic">:name&lt;/span>] = &lt;span style="font-style:italic">&amp;#34;Mortimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>hash[&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>] &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;Mortimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来就有点奇怪了，Rails调用了&lt;code>Hash[]&lt;/code>方法。这是一个鲜为人知的从包含键/值对的数组中初始化一个哈希表的方法。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>Hash[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="font-style:italic">:name&lt;/span>, &lt;span style="font-style:italic">&amp;#34;Mortimer&amp;#34;&lt;/span>],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [&lt;span style="font-style:italic">:species&lt;/span>, &lt;span style="font-style:italic">&amp;#34;Crow&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>] &lt;span style="font-style:italic">#=&amp;gt; {[:name, &amp;#34;Mortimer&amp;#34;]=&amp;gt;[:species, &amp;#34;Crow&amp;#34;]}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以查看&lt;code>Hash Tricks&lt;/code>找到更多类似的方法。&lt;code>changes&lt;/code>中剩余部分的代码就比较清晰了。属性名被映射到类似&lt;code>[attr, attribute_change(attr)]&lt;/code>的数组。其中第一个元素，也就是&lt;code>attr&lt;/code>编程了一个键，而对应的值则是&lt;code>attribute_change(attr)&lt;/code>返回的结果。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_change(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [changed_attributes[&lt;span style="">attr&lt;/span>], __send__(&lt;span style="">attr&lt;/span>)] &lt;span style="font-weight:bold">if&lt;/span> attribute_changed?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是另一个被分发的属性方法，但是在这个例子里，它返回了一个包含了两个元素的数组，第一个元素是从&lt;code>changed_attributes&lt;/code>哈希表中读到的&lt;code>attr&lt;/code>所对应的旧的值，第二个则是所对应的新的值。Rails通过使用&lt;code>__send__&lt;/code>方法调用了名为&lt;code>attr&lt;/code>的方法，进而得到新的属性值。然后这对值会被返回，并且用作&lt;code>changes&lt;/code>哈希表中&lt;code>attr&lt;/code>所对应的值。&lt;/p>
&lt;h3 id="activerecord">ActiveRecord&lt;/h3>
&lt;p>现在让我们来找出Rails是如何记录更改的。ActiveRecord实现了读写ActiveModel所跟踪的属性的代码。跟ActiveModel一样，ActiveRecord也有一个&lt;code>dirty.rb&lt;/code>文件，我们将要对这个文件进行挖掘。通过在定义了&lt;code>changed_attributes&lt;/code>的文件中（&lt;strong>提示&lt;/strong>：命令行中键入&lt;code>qw activerecord&lt;/code>）找到的相关代码，我们可以看到这个文件包装了ActiveRecord的&lt;code>write_attribute&lt;/code>与逻辑以实现对变更的跟踪。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Wrap write_attribute to remember original attribute value.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> write_attribute(&lt;span style="">attr&lt;/span>, value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">attr&lt;/span> = &lt;span style="">attr&lt;/span>.to_s
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># The attribute already has an unsaved change.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> attribute_changed?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> old = @changed_attributes[&lt;span style="">attr&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @changed_attributes.delete(&lt;span style="">attr&lt;/span>) &lt;span style="font-weight:bold">unless&lt;/span> _field_changed?(&lt;span style="">attr&lt;/span>, old, value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> old = clone_attribute_value(&lt;span style="font-style:italic">:read_attribute&lt;/span>, &lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @changed_attributes[&lt;span style="">attr&lt;/span>] = old &lt;span style="font-weight:bold">if&lt;/span> _field_changed?(&lt;span style="">attr&lt;/span>, old, value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Carry on.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">super&lt;/span>(&lt;span style="">attr&lt;/span>, value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们暂时偏离一下主题，并且看一下方法的包装。这是在Rails的代码里边非常常见的模式。当你调用&lt;code>super&lt;/code>的时候，Ruby查找当前对象的所有祖先，包括相关的模块。由于一个类可以引进多个模块，所以你可以多层地包装方法。这里是一个简单的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Shouting&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> say(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message.upcase
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Speaker&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> Shouting
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> say(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-weight:bold">super&lt;/span>(message)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Speaker.new.say(&lt;span style="font-style:italic">&amp;#34;Hi!&amp;#34;&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;HI!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请注意&lt;code>Shouting&lt;/code>是&lt;code>Speaker&lt;/code>所包含的模块，而不是后者所扩展的类。Rails使用这种技巧去包装方法，以此确保在不同的文件里有独立的关注点（Concern）。这也意味着为了了解整个系统，你可能需要从多个文件里边找到相关的代码。假如你看到了一个对&lt;code>super&lt;/code>的调用，这是一个可以告诉你在别的地方还有更多代码需要了解的好线索。假如你想学习更多的这方面的知识，James Coglan有一个非常详细的文章讲解了Ruby的&lt;a href="https://blog.jcoglan.com/2013/05/08/how-ruby-method-dispatch-works/">方法分发&lt;/a>。&lt;/p>
&lt;p>回到&lt;code>write_attribute&lt;/code>方法。根据属性（值）是否已经改变，会有两个可能的场景。第一个分支检查你是否正在将一个属性（值）还原到原来的值，如果是这样，它将会从记录了已改变属性的哈希表中删除属性。第二个分支仅仅在新的值与旧的值不同的时候记录下更改。一旦更改被记录下来，实际的用于更新属性的逻辑通过调用&lt;code>super&lt;/code>方法完成。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>Rails为你的model提供了变更的跟踪。这个功能是在ActiveModel中实现的，但是真正的监测更改的逻辑则是在ActiveRecord中实现的。&lt;/p>
&lt;p>通过了解这个功能，我们也发掘到了一些有趣的小贴士：&lt;/p>
&lt;ul>
&lt;li>ActiveModel定义了&lt;code>attribute_method_suffix&lt;/code>方法用于分发类似&lt;code>name_changed?&lt;/code>的方法。&lt;/li>
&lt;li>&lt;code>||=&lt;/code>操作符是一个可以用来初始化变量的方便的方法。&lt;/li>
&lt;li>在&lt;code>HashWithIndifferentAccess&lt;/code>中，字符串类型以及符号类型的键是一样的。&lt;/li>
&lt;li>&lt;code>Hash&lt;/code>可以通过&lt;code>Hash[key_value_pairs]&lt;/code>方法初始化。&lt;/li>
&lt;li>你可以使用模块拦截方法并为方法加上另一层的功能。&lt;/li>
&lt;/ul>
&lt;p>假如你有关于你想阅读的关于Rails中其他部分的建议，请让我知道。&lt;/p>
&lt;h3 id="喜欢这篇文章">喜欢这篇文章？&lt;/h3>
&lt;p>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多&lt;/a>“解读Rails”中的文章。“解读Rails”中的文章。&lt;/p></description></item><item><title>解读Rails - 处理异常</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</link><pubDate>Wed, 05 Mar 2014 13:53:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_handling_exceptions/">Reading Rails - Handling Exceptions&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Rails通过让你使用&lt;code>rescue_from&lt;/code>方法，让你在你的&lt;code>controller&lt;/code>里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">ApplicationController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Redirect users if they try to use disabled features.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_from FeatureDisabledError, InsufficientAccessError &lt;span style="font-weight:bold">do&lt;/span> |ex|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flash[&lt;span style="font-style:italic">:alert&lt;/span>] = &lt;span style="font-style:italic">&amp;#34;Your account does not support &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>ex.feature_name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redirect_to &lt;span style="font-style:italic">&amp;#34;/pricing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。&lt;/p>
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="定义处理器handlers">定义处理器(Handlers)&lt;/h3>
&lt;p>ActiveSupport包含了一个用于定义异常如何被处理的模块&lt;code>Rescuable&lt;/code>。第一个需要了解的方法就是&lt;code>rescue_from&lt;/code>。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（&lt;strong>提示&lt;/strong>：查看代码，请在命令行中输入&lt;code>qw activesupport&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_from(*klasses, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options = klasses.extract_options!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">unless&lt;/span> options.has_key?(&lt;span style="font-style:italic">:with&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> block_given?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options[&lt;span style="font-style:italic">:with&lt;/span>] = block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，&lt;code>*klasses&lt;/code>接收数量不定的异常类，所以你可以进行类似&lt;code>rescue_from(FeatureDisabledError, InsufficientAccessError)&lt;/code>这样的调用。它们将会被存放在一个数组里。&lt;/p>
&lt;p>接下来，请留意&lt;code>extract_options!&lt;/code>的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用&lt;code>:with&lt;/code>项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。&lt;/p>
&lt;p>接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_from(*klasses, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="font-weight:bold">if&lt;/span> klass.is_a?(Class) &amp;amp;&amp;amp; klass &amp;lt;= Exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">elsif&lt;/span> klass.is_a?(String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里你应该注意的是，Rails是如何判定&lt;code>klass&lt;/code>是不是继承自&lt;code>Exception&lt;/code>的。通常情况下，你可能会通过使用&lt;code>obj.is_a?(Exception)&lt;/code>来判断一个对象是不是某一个具体类型的实例，即使如此，&lt;code>klass&lt;/code>并不是&lt;code>Exception&lt;/code>，而只是&lt;code>Class&lt;/code>。那么我们又怎么找出它使哪一类呢？Ruby在&lt;code>Module&lt;/code>上定义了类似&lt;code>&amp;lt;=&lt;/code>这样的&lt;a href="http://ruby-doc.org/core-1.9.3/Module.html#method-i-3C">用于比较的操作符&lt;/a>。当操作符左边的对象是操作符右边对象的子类的时候，它会返回true。举个例子，&lt;code>ActiveRecord::RecordNotFound &amp;lt; Exception&lt;/code>返回true，而&lt;code>ActiveRecord::RecordNotFound &amp;gt; Exception&lt;/code>返回false。&lt;/p>
&lt;p>在这个方法的末尾，我们看到表示异常类的&lt;code>String&lt;/code>对象稍后被储存在二元数组中：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_from(*klasses, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.rescue_handlers += [[key, options[&lt;span style="font-style:italic">:with&lt;/span>]]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>现在我们已经知道了处理器是如何储存的，但是当Rails需要处理异常的时候，它又是如何查找这些处理器的呢？&lt;/p>
&lt;h3 id="查找处理器finding-handlers">查找处理器（Finding Handlers）&lt;/h3>
&lt;p>经过对&lt;code>rescue_handlers&lt;/code>的快速搜索发现，这一切使用到了&lt;code>handler_for_rescue&lt;/code>。我们可以看到每一个可能的处理器都被一一检查，直到我们找到能够与&lt;code>exception&lt;/code>匹配的处理器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> handler_for_rescue(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 我们遵循从右到左的顺序，是因为每当发现一个rescue_from声明的时候，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 相应的klass_name, handler对就会被压入resuce_handlers里。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> _, rescuer = self.class.rescue_handlers.reverse.detect &lt;span style="font-weight:bold">do&lt;/span> |klass_name, handler|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass = self.class.const_get(klass_name) &lt;span style="font-weight:bold">rescue&lt;/span> &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass ||= klass_name.constantize &lt;span style="font-weight:bold">rescue&lt;/span> &lt;span style="">nil&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> exception.is_a?(klass) &lt;span style="font-weight:bold">if&lt;/span> klass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>如同注释所言，&lt;code>rescue_handlers&lt;/code>被反序读取。假如有两个处理器能够处理同一个异常，那么最后定义的处理器会被优先选中。假如你先定义了一个针对&lt;code>ActiveRecord::NotFoundError&lt;/code>异常的处理器，接着又定义了针对&lt;code>Exception&lt;/code>异常的处理器，那么前者将永远都不会被调用，因为针对&lt;code>Exception&lt;/code>的处理器总是会优先匹配。&lt;/p>
&lt;p>现在，在代码块里边，又发生了什么呢？&lt;/p>
&lt;p>首先，字符串对象&lt;code>klass_name&lt;/code>被当做当前类内部的常量进行查找，在找不到的情况下会继续判断它是不是定义在程序内部其他地方的常量，以此将&lt;code>klass_name&lt;/code>转换为实际的类。每一步都通过返回&lt;code>nil&lt;/code>进行rescue。这么做的一个原因就是当前处理器可能是针对某个尚未加载的异常的类型。举例来说，一个插件里可能为&lt;code>ActiveRecord::NotFoundError&lt;/code>定义了错误处理，但是你可能并没有使用&lt;code>ActiveRecord&lt;/code>。在这样的情况下，引用这个异常将会导致异常。每一行最后的&lt;code>rescue nil&lt;/code>能够在无法找到类时无声无息地组织异常的抛出。&lt;/p>
&lt;p>最后我们检查这个异常（等待匹配的异常）是否是这个处理器所对应异常类的实例。如果是，数组&lt;code>[klass_name, handler]&lt;/code>将会被返回。返回到上边看看&lt;code>_, rescuer = ...&lt;/code>这一行代码，这一一个数组拆分的例子。因为我们实际上只想要返回数组的第二个元素，也就是处理器，所以&lt;code>_&lt;/code>在这里只是一个占位符。&lt;/p>
&lt;h3 id="处理异常rescuing-exceptions">处理异常（Rescuing Exceptions)&lt;/h3>
&lt;p>现在我们知道了程序是如何查找异常处理器的，但是它又是如何被调用的呢？为了回答这最后一个问题，我们可以返回到源代码文件的顶部然后探索一下&lt;code>rescue_with_handler&lt;/code>方法。当给它传递一个异常的时候，它将会尝试通过调用合适的处理器来处理这个异常。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_with_handler(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> handler = handler_for_rescue(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> handler.arity != 0 ? handler.call(exception) : handler.call
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>为了了解这个方法是如何在你的controller里边生效的，我们需要查看ActionPack包里边的代码。（&lt;strong>提示&lt;/strong>：可以在命令行中键入&lt;code>qw actionpack&lt;/code>打开ActionPace的代码）Rails定义了一个叫做&lt;code>ActionController::Rescue&lt;/code>的中间件，它被混入到了&lt;code>Rescuable&lt;/code>模块里边，并且通过&lt;code>precess_action&lt;/code>调用。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> process_action(*args)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">super&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_with_handler(exception) || &lt;span style="font-weight:bold">raise&lt;/span>(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Rails在收到每一个请求时都会调用&lt;code>process_action&lt;/code>，假如请求导致一个异常即将被抛出，&lt;code>rescue_with_handler&lt;/code>都会试图去处理这个异常。&lt;/p>
&lt;h3 id="在rails之外使用rescuableusing-rescuable-outside-of-rails">在Rails之外使用Rescuable（Using Rescuable Outside of Rails）&lt;/h3>
&lt;p>&lt;code>Rescuable&lt;/code>能够被混入到其它代码之中。假如你想集中化你的异常处理部分的逻辑，那么你可以考虑一下使用&lt;code>Rescuable&lt;/code>。举个例子，假如你有很多发向远程服务的请求，并且你不想在每一个方法里边重复异常处理的逻辑：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">RemoteService&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> Rescuable
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_from Net::HTTPNotFound, Net::HTTPNotAcceptable &lt;span style="font-weight:bold">do&lt;/span> |ex|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> disable_service!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> log_http_failure(@endpoint, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_from Net::HTTPNetworkAuthenticationRequired &lt;span style="font-weight:bold">do&lt;/span> |ex|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> authorize!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> get_status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_with_handler(exception) || &lt;span style="font-weight:bold">raise&lt;/span>(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> update_status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_with_handler(exception) || &lt;span style="font-weight:bold">raise&lt;/span>(exception)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>使用一点元编程的技巧，你甚至可以通过类似的模式对已有的方法进行封装以避免rescue代码块。&lt;/p>
&lt;h3 id="总结recap">总结（Recap）&lt;/h3>
&lt;p>ActiveSupport的&lt;code>Rescuable&lt;/code>模块允许我们定义异常处理方法。ActionController的&lt;code>Rescue&lt;/code>中间件捕捉异常，并试图处理这些异常。
我们也同时了解到：&lt;/p>
&lt;ul>
&lt;li>一个签名类似&lt;code>rescue_from(*klasses)&lt;/code>的方法可以接收数量不定的参数。&lt;/li>
&lt;li>&lt;code>Array#extract_options!&lt;/code>方法是一个用于从arguments数组得到options的技巧。&lt;/li>
&lt;li>你可以通过类似&lt;code>klass &amp;lt;= Exception&lt;/code>这样的代码判读一个类是否某个类的子类。&lt;/li>
&lt;li>&lt;code>rescue nil&lt;/code>将会静默地消除异常。&lt;/li>
&lt;/ul>
&lt;p>就算是再小的代码片段都包含了非常多有用的信息，请让我知道你下一步想要了解什么东西，我们还会看到能够从Rails里边挖掘到的新奇玩意。&lt;/p>
&lt;h3 id="喜欢这篇文章">喜欢这篇文章？&lt;/h3>
&lt;p>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多&lt;/a>“解读Rails”中的文章。“解读Rails”中的文章。&lt;/p></description></item><item><title>解读Rails - 适配器模式</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</link><pubDate>Mon, 03 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</guid><description>&lt;p>本文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;amp;utm_medium=email">Reading Rails - The Adapter Pattern&lt;/a>，限于本人水平有限，翻译不当之处，敬请指教！&lt;/p>
&lt;p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是&lt;a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）&lt;/a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>为了跟随本文的步骤，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开相关的代码库，或者直接在&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github&lt;/a>上查看这些代码。&lt;/p>
&lt;h3 id="适配器模式">适配器模式&lt;/h3>
&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式&lt;/a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。&lt;/p>
&lt;p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_restaurant(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.nearest(&lt;span style="font-style:italic">:restaurant&lt;/span>, self.lat, self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们假设有一个针对&lt;code>locator&lt;/code>的接口，但是如果我们想要&lt;code>find_nearest_restaurant&lt;/code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_restaurant(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> locator.is_a? GeoFish
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.nearest(&lt;span style="font-style:italic">:restaurant&lt;/span>, self.lat, self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">elsif&lt;/span> locator.is_a? ActsAsFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.find_food(&lt;span style="font-style:italic">:lat&lt;/span> =&amp;gt; self.lat, &lt;span style="font-style:italic">:lon&lt;/span> =&amp;gt; self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> NotImplementedError, &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>locator.class.name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> is not supported.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许&lt;code>find_nearest_restaurant&lt;/code>就是我们使用&lt;code>locator&lt;/code>的唯一场景。&lt;/p>
&lt;p>那假如你真的需要去支持一个新的&lt;code>locator&lt;/code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现&lt;code>find_nearest_hospital&lt;/code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。&lt;/p>
&lt;p>在这个例子中，我们可以为&lt;code>GeoFish&lt;/code>以及&lt;code>ActsAsFound&lt;/code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_hospital(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.find &lt;span style="font-style:italic">:type&lt;/span> =&amp;gt; &lt;span style="font-style:italic">:hospital&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:lat&lt;/span> =&amp;gt; self.lat,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:lon&lt;/span> =&amp;gt; self.lon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>locator = GeoFishAdapter.new(geo_fish_locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find_nearest_hospital(locator)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>特意假设的例子就到此为止，接下来让我们看看真实的代码。&lt;/p>
&lt;h3 id="multijson">MultiJSON&lt;/h3>
&lt;p>&lt;code>ActiveSupport&lt;/code>在做JSON格式的解码时，用到的是&lt;code>MultiJSON&lt;/code>，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对&lt;a href="https://github.com/ohler55/oj">oj&lt;/a>和&lt;a href="https://github.com/brianmario/yajl-ruby">yajl&lt;/a>的适配器。
(&lt;strong>提示&lt;/strong>: 可在命令行中输入&lt;code>qw multi_json&lt;/code>查看源码。)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">MultiJson&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Adapters&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Oj&lt;/span> &amp;lt; Adapter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> load(string, options={})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options[&lt;span style="font-style:italic">:symbol_keys&lt;/span>] = options.delete(&lt;span style="font-style:italic">:symbolize_keys&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ::Oj.load(string, options)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Oj的适配器修改了&lt;code>options&lt;/code>哈希表，使用&lt;code>Hash#delete&lt;/code>将&lt;code>:symbolize_keys&lt;/code>项转换为Oj的&lt;code>:symbol_keys&lt;/code>项：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>options = {&lt;span style="font-style:italic">:symbolize_keys&lt;/span> =&amp;gt; &lt;span style="">true&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>options[&lt;span style="font-style:italic">:symbol_keys&lt;/span>] = options.delete(&lt;span style="font-style:italic">:symbolize_keys&lt;/span>) &lt;span style="font-style:italic"># =&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>options &lt;span style="font-style:italic"># =&amp;gt; {:symbol_keys=&amp;gt;true}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来MultiJSON调用了&lt;code>::Oj.load(string, options)&lt;/code>。MultiJSON适配后的API跟Oj原有的API非常相似，在此不必赘述。不过你是否注意到，Oj是如何引用的呢？&lt;code>::Oj&lt;/code>引用了顶层的&lt;code>Oj&lt;/code>类，而不是&lt;code>MultiJson::Adapters::Oj&lt;/code>。&lt;/p>
&lt;p>现在让我们看看MultiJSON又是如何适配Yajl库的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">MultiJson&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Adapters&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Yajl&lt;/span> &amp;lt; Adapter
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> load(string, options={})
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ::Yajl::Parser.new(&lt;span style="font-style:italic">:symbolize_keys&lt;/span> =&amp;gt; options[&lt;span style="font-style:italic">:symbolize_keys&lt;/span>]).parse(string)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个适配器从不同的方式实现了&lt;code>load&lt;/code>方法。Yajl的方式是先创建一个解析器的实力，然后将传入的字符串&lt;code>string&lt;/code>作为参数调用&lt;code>Yajl::Parser#parse&lt;/code>方法。在&lt;code>options&lt;/code>哈希表上的处理也略有不同。只有&lt;code>:symbolize_keys&lt;/code>项被传递给了Yajl。&lt;/p>
&lt;p>这些JSON的适配器看似微不足道，但是他们却可以让你随心所欲地在不同的库之间进行切换，而不需要在每一个解析JSON的地方更新代码。&lt;/p>
&lt;h3 id="activerecord">ActiveRecord&lt;/h3>
&lt;p>很多JSON库往往都遵从相似的模式，这让适配工作变得相当轻松。但是如果你是在处理一些更加复杂的情况时，结果会是怎样？ActiveRecord包含了针对不同数据库的适配器。尽管PostgreSQL和MySQL都是SQL数据库，但是他们之间还是有很多不同之处，而ActiveRecord通过使用适配器模式屏蔽了这些不同。(&lt;strong>提示&lt;/strong>: 命令行中输入&lt;code>qw activerecord&lt;/code>查看ActiveRecord的代码)&lt;/p>
&lt;p>打开ActiveRecord代码库中的&lt;code>lib/connection_adapters&lt;/code>目录，里边会有针对PostgreSQL,MySQL以及SQLite的适配器。除此之外，还有一个名为&lt;code>AbstractAdapter&lt;/code>的适配器，它作为每一个具体的适配器的基类。&lt;code>AbstractAdapter&lt;/code>实现了在大部分数据库中常见的功能，这些功能在其子类比如&lt;code>PostgreSQLAdapter&lt;/code>以及&lt;code>AbstractMysqlAdapter&lt;/code>中被重新定制，而其中&lt;code>AbstractMysqlAdapter&lt;/code>则是另外两个不同的MySQL适配器——MysqlAdapter以及Mysql2Adapter——的父类。让我们通过一些真实世界中的例子来看看他们是如何一起工作的。&lt;/p>
&lt;p>PostgreSQL和MySQL在SQL方言的实现稍有不同。查询语句&lt;code>SELECT * FROM users&lt;/code>在这两个数据库都可以正常执行，但是它们在一些类型的处理上会稍显不同。在MySQL和PostgreSQL中，时间格式就不尽相同。其中，PostgreSQL支持微秒级别的时间，而MySQL只是到了最近的一个稳定发布的版本中才支持。那这两个适配器又是如何处理这种差异的呢？&lt;/p>
&lt;p>ActiveRecord通过被混入到&lt;code>AbstractAdapter&lt;/code>的&lt;code>ActiveRecord::ConnectionAdapters::Quoting&lt;/code>中的&lt;code>quoted_date&lt;/code>引用日期。而&lt;code>AbstractAdapter&lt;/code>中的实现仅仅只是格式化了日期：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> quoted_date(value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value.to_s(&lt;span style="font-style:italic">:db&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Rails中的ActiveSupport扩展了&lt;code>Time#to_s&lt;/code>，使其能够接收一个代表格式名的符号类型参数。&lt;code>:db&lt;/code>所代表的格式就是&lt;code>%Y-%m-%d %H:%M:%S&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Examples of common formats:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time.now.to_s(&lt;span style="font-style:italic">:db&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;2014-02-19 06:08:13&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time.now.to_s(&lt;span style="font-style:italic">:short&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;19 Feb 06:08&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Time.now.to_s(&lt;span style="font-style:italic">:rfc822&lt;/span>) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;Wed, 19 Feb 2014 06:08:13 +0000&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>MySQL的适配器都没有重写&lt;code>quoted_date&lt;/code>方法，它们自然会继承这种行为。另一边，&lt;code>PostgreSQLAdapter&lt;/code>则对日期的处理做了两个修改：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> quoted_date(value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="font-weight:bold">super&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> value.acts_like?(&lt;span style="font-style:italic">:time&lt;/span>) &amp;amp;&amp;amp; value.respond_to?(&lt;span style="font-style:italic">:usec&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>result&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">.&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>sprintf(&lt;span style="font-style:italic">&amp;#34;%06d&amp;#34;&lt;/span>, value.usec)&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> value.year &amp;lt; 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = result.sub(&lt;span style="font-style:italic">/^-/&lt;/span>, &lt;span style="font-style:italic">&amp;#34;&amp;#34;&lt;/span>) + &lt;span style="font-style:italic">&amp;#34; BC&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>它在一开始便调用&lt;code>super&lt;/code>方法，所以它也会得到一个类似MySQL中格式化后的日期。接下来，它检测&lt;code>value&lt;/code>是否像是一个具体时间。这是一个ActiveSupport中扩展的方法，当一个对象类似&lt;code>Time&lt;/code>类型的实例时，它会返回&lt;code>true&lt;/code>。这让它更容易表明各种对象已被假设为类似&lt;code>Time&lt;/code>的对象。（&lt;strong>提示&lt;/strong>: 对&lt;code>acts_like?&lt;/code>方法感兴趣？请在命令行中执行&lt;code>qw activesupport&lt;/code>，然后阅读&lt;code>core_ext/object/acts_like.rb&lt;/code>）&lt;/p>
&lt;p>第二部分的条件检查&lt;code>value&lt;/code>是否有用于返回毫秒的&lt;code>usec&lt;/code>方法。如果可以求得毫秒数，那么它将通过&lt;code>sprintf&lt;/code>方法被追加到&lt;code>result&lt;/code>字符串的末尾。跟很多时间格式一样，&lt;code>sprintf&lt;/code>也有很多不同的方式用于格式化数字：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>sprintf(&lt;span style="font-style:italic">&amp;#34;%06d&amp;#34;&lt;/span>, 32) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;000032&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sprintf(&lt;span style="font-style:italic">&amp;#34;%6d&amp;#34;&lt;/span>, 32) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34; 32&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sprintf(&lt;span style="font-style:italic">&amp;#34;%d&amp;#34;&lt;/span>, 32) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;32&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sprintf(&lt;span style="font-style:italic">&amp;#34;%.2f&amp;#34;&lt;/span>, 32) &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;32.00&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最后，假如日期是一个负数，&lt;code>PostgreSQLAdapter&lt;/code>就会通过加上&amp;quot;BC&amp;quot;去重新格式化日期，这是PostgreSQL数据库的实际要求：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>SELECT &lt;span style="font-style:italic">&amp;#39;2000-01-20&amp;#39;&lt;/span>::timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-- 2000-01-20 00:00:00
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SELECT &lt;span style="font-style:italic">&amp;#39;2000-01-20 BC&amp;#39;&lt;/span>::timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-- 2000-01-20 00:00:00 BC
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>SELECT &lt;span style="font-style:italic">&amp;#39;-2000-01-20&amp;#39;&lt;/span>::timestamp;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>-- &lt;span style="font-style:italic">ERROR&lt;/span>: time zone displacement out of &lt;span style="font-style:italic">range&lt;/span>: &lt;span style="font-style:italic">&amp;#34;-2000-01-20&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这只是ActiveRecord适配多个API时的一个极小的方式，但它却能帮助你免除由于不同数据库的细节所带来的差异和烦恼。&lt;/p>
&lt;p>另一个体现SQL数据库的不同点是数据库表被创建的方式。MySQL以及PostgreSQL中对主键的处理各不相同：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># AbstractMysqlAdapter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NATIVE_DATABASE_TYPES = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:primary_key&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#34;int(11) DEFAULT NULL auto_increment PRIMARY KEY&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># PostgreSQLAdapter&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>NATIVE_DATABASE_TYPES = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">primary_key&lt;/span>: &lt;span style="font-style:italic">&amp;#34;serial primary key&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这两种适配器都能够明白ActiveRecord中的主键的表示方式，但是它们会在创建新表的时候将此翻译为不同的SQL语句。当你下次在编写一个migration或者执行一个查询的时候，思考一下ActiveRecord的适配器以及它们为你做的所有微小的事情。&lt;/p>
&lt;h3 id="datetime和time">DateTime和Time&lt;/h3>
&lt;p>当MultiJson以及ActiveRecord实现了传统的适配器的时候，Ruby的灵活性使得另一种解决方案成为可能。&lt;code>DateTime&lt;/code>以及&lt;code>Time&lt;/code>都用于表示时间，但是它们在内部的处理上是不同的。虽然有着这些细微的差异，但是它们所暴露出来的API却是极其类似的（&lt;strong>提示&lt;/strong>：命令行中执行&lt;code>qw activesupport&lt;/code>查看此处相关代码）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>t = Time.now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t.day &lt;span style="font-style:italic">#=&amp;gt; 19 (Day of month)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t.wday &lt;span style="font-style:italic">#=&amp;gt; 3 (Day of week)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t.usec &lt;span style="font-style:italic">#=&amp;gt; 371552 (Microseconds)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>t.to_i &lt;span style="font-style:italic">#=&amp;gt; 1392871392 (Epoch secconds)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d = DateTime.now
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d.day &lt;span style="font-style:italic">#=&amp;gt; 19 (Day of month)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d.wday &lt;span style="font-style:italic">#=&amp;gt; 3 (Day of week)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d.usec &lt;span style="font-style:italic">#=&amp;gt; NoMethodError: undefined method `usec&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>d.to_i &lt;span style="font-style:italic">#=&amp;gt; NoMethodError: undefined method `to_i&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ActiveSupport通过添加缺失的方法来直接修改&lt;code>DateTime&lt;/code>和&lt;code>Time&lt;/code>，进而抹平了两者之间的差异。从实例上看，这里就有一个例子演示了ActiveSupport如何定义&lt;code>DateTime#to_i&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">DateTime&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> to_i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> seconds_since_unix_epoch.to_i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> seconds_since_unix_epoch
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (jd - 2440588) * 86400 - offset_in_seconds + seconds_since_midnight
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> offset_in_seconds
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> (offset * 86400).to_i
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> seconds_since_midnight
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sec + (min * 60) + (hour * 3600)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>每一个用于支持的方法，&lt;code>seconds_since_unix_epoch&lt;/code>，&lt;code>offset_in_seconds&lt;/code>，以及&lt;code>seconds_since_midnight&lt;/code>都使用或者扩展了&lt;code>DateTime&lt;/code>中已经存在的API去定义与&lt;code>Time&lt;/code>中匹配的方法。&lt;/p>
&lt;p>假如说我们前面所看到的适配器是相对于被适配对象的外部适配器，那么我们现在所看到的这个就可以被称之为内部适配器。与外部适配器不同的是，这种方法受限于已有的API，并且可能导致一些麻烦的矛盾问题。举例来说，&lt;code>DateTime&lt;/code>和&lt;code>Time&lt;/code>在一些特殊的场景下就有可能出现不一样的行为：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>datetime == time &lt;span style="font-style:italic">#=&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>datetime + 1 &lt;span style="font-style:italic">#=&amp;gt; 2014-02-26 07:32:39&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>time + 1 &lt;span style="font-style:italic">#=&amp;gt; 2014-02-25 07:32:40&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当加上1的时候，&lt;code>DateTime&lt;/code>加上了一天，而&lt;code>Time&lt;/code>则是加上了一秒。当你需要使用它们的时候，你要记住ActiveSupport基于这些不同，提供了诸如&lt;code>change&lt;/code>和&lt;code>Duration&lt;/code>等保证一致行为的方法或类。&lt;/p>
&lt;p>这是一个好的模式吗？它理所当然是方便的，但是如你刚才所见，你仍旧需要注意其中的一些不同之处。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>设计模式不是只有Java才需要的。Rails通过使用设计模式以提供用于JSON解析以及数据库维护的统一接口。由于Ruby的灵活性，类似&lt;code>DateTime&lt;/code>以及&lt;code>Time&lt;/code>这样的类可以被直接地修改而提供相似的接口。Rails的源码就是一个可以让你挖掘真实世界中不同设计模式实例的天堂。&lt;/p>
&lt;p>在这次的实践中，我们同时也发掘了一些有趣的代码：&lt;/p>
&lt;ul>
&lt;li>&lt;code>hash[:foo] = hash.delete(:bar)&lt;/code>是一个用于重命名哈希表中某一项的巧妙方法。&lt;/li>
&lt;li>调用&lt;code>::ClassName&lt;/code>会调用顶层的类。&lt;/li>
&lt;li>ActiveSupport为&lt;code>Time&lt;/code>、&lt;code>Date&lt;/code>以及其他的类添加了一个可选的代表格式的参数&lt;code>format&lt;/code>。&lt;/li>
&lt;li>&lt;code>sprintf&lt;/code>可以用于格式化数字。&lt;/li>
&lt;/ul>
&lt;p>想要探索更多的知识？回去看看MultiJson是如何处理以及解析格式的。仔细阅读你在你的数据库中所使用到的ActiveRecord的适配器的代码。浏览ActiveSupport中用于xml适配器的&lt;code>XmlMini&lt;/code>，它跟MultiJson中的JSON适配器是类似的。在这些里面还会有很多可以学习的。&lt;/p>
&lt;p>喜欢这篇文章？&lt;!-- raw HTML omitted -->
&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/">阅读更多&lt;/a>“解读Rails”中的文章。&lt;/p></description></item><item><title>解读Rails(系列翻译)</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-xi-lie-fan-yi/</link><pubDate>Sun, 02 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-xi-lie-fan-yi/</guid><description>&lt;p>解读Rails系列文章原文来自&lt;a href="http://monkeyandcrow.com/series/reading_rails/">Reading Rails&lt;/a>，我将尽我所能完成此系列所有文章的翻译。以下部分为原文系列对应翻译：&lt;/p>
&lt;p>在我们的工作中，我们的大部分时间都是在使用各种各样的工具，但是你知不知道它们是如何工作的呢？&lt;/p>
&lt;p>在这个系列里，我们通过阅读&lt;a href="http://rubyonrails.org/">Ruby on Rails&lt;/a>的源码去探索其内部的工作机制。我们将不仅仅只是学到与Rails有关的知识，我们也将见识到Ruby里边一些有趣的功能，以及一些有用的新技巧。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/">解读Rails - 适配器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 错误和验证器&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 验证机制是如何配置的&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - Concern&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 更多的Migrations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2017/10/14/jie-du-rails-migrations/">解读Rails - Migrations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/12/shu-xing-fang-fa/">解读Rails - 属性方法(Attribute Methods)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/07/zhui-zong-bian-geng/">解读Rails - 跟踪model中属性（值）的变更&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/">解读Rails - 处理异常&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>在Ruby中使用WebSocket</title><link>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</link><pubDate>Sat, 01 Mar 2014 21:31:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</guid><description>&lt;p>&lt;strong>声明&lt;/strong>: 此文翻译自&lt;a href="http://www.troikatech.com/blog/2014/02/26/websocket-webmachine/?utm_source=rubyweekly&amp;amp;utm_medium=email">WebSockets in Ruby&lt;/a>， 限于本人才疏学浅，其中有翻译不当之处，敬请指出，感激不尽！&lt;/p>
&lt;p>在我的主要工作中，需要构建一个一直占用相当大CPU时间片的数据系统。这个任务主要用于在地理编码以及local reference system(本地地理系统？)之间进行编码以及解码。举个例子，这个工作将帮助我们在系统中标记一条对应于街道上某个地点的记录，并且可以知道本地地理位置所对应的坐标。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>在第一次的尝试中，我开发了一个用于地理编码的Ruby库以及一个简单的基于Sinatra的web服务。当时我的解决方案表现得还不错，直到后来客户要求对每一个鼠标滑过的事件进行交互。这个需求上的更改让我不得不再一次通过Javascript语言去构建一个同样用于地理编码的基础构件，在之后的一段时间里，一切也都表现得非常好。&lt;/p>
&lt;p>而意料之中的是，我们再一次决定在系统中允许每个用户与多个街道关联。现在，每次下载800KB的数据（存储在索引数据库中，用于记录最新的会话信息）尚且可以承受；但是潜在上来说，几个MB的数据将是致命的，甚至软件也有可能在会话的响应之前被使用-而这只是用户所期待的功能之一。&lt;/p>
&lt;p>我知道我们必须寻找一个完美的解决方案，并且使一切都是可以管理控制的。在以前，我涉足过WebSocket领域（比如node.js以及Socket.IO）并且知道相关的底层知识。从之前的搜索中，我意识到Ruby在这方面的欠缺，我很快又考虑通过在节点上的Javascript端口来实现需求。这样的想法使我非常激动。&lt;/p>
&lt;h2 id="可选方案">可选方案&lt;/h2>
&lt;p>第一步是找出可用的方案。以下列举我找到的：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/simulacre/sinatra-websocket">sinatra-websocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/faye/faye-websocket-ruby">faye-websocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/websocket-rails/websocket-rails">websocket-rails&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ngauthier/tubesock">tubesock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/seancribbs/webmachine-ruby">webmachine-ruby&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>在上述五种方案中，前三种方案都是基于事件机制的，而&lt;code>tubesock&lt;/code>使用了rake hijacking技术，&lt;code>webmachine-ruby&lt;/code>通过基于&lt;code>Celluloid::IO&lt;/code>的HTTP服务器Reel提供WebSockets。&lt;/p>
&lt;p>首先，考虑到我已经使用了Sinatra，于是我试用了&lt;code>sinatra-websocket&lt;/code>。但是因为部分原因，我无法将连接方式迁移到WebSocket，所以我决定快速跳过。而且坦白说的话，我还直接跳过了&lt;code>faye-websocket&lt;/code>。&lt;/p>
&lt;p>接下来的两个备选方案遇到了同样的问题：在一个配置较低的Heroku的站点上启动Rails并且加载了整个系统之后，剩下的内存只够几十个客户端同时使用的了。除此之外，Rails的启动时间加上其他用于构建的时间偶尔会让Heroku认为系统中出现异常，结果导致进程在服务正常启动之前就已经被强行退出了。&lt;/p>
&lt;p>假如你有所留意，那么你也就知道了，剩下的唯一一个方案，就是&lt;code>webmachine-ruby&lt;/code>。&lt;/p>
&lt;h2 id="webmachine-ruby">webmachine-ruby&lt;/h2>
&lt;p>配置&lt;code>webmachine-ruby&lt;/code>的环境还是相对容易的。为了逐步进行，我首先把原来基于HTTP的服务迁移到它的资源结构。比起Rails以及Sinatra，它更加具有面向对象的味道。它的分发器是易于理解的，我非常喜欢通过&lt;a href="https://github.com/seancribbs/webmachine-ruby#visual-debugger">visual debugger&lt;/a>来摆玩这一切。&lt;/p>
&lt;p>迁移到WebSocket上后，一切都变了。我能建议的（包括文档中说明的）就是，你完全可以跳过常规的基础配置，转而提供一个可调用的配置项，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>App = Webmachine::Application &lt;span style="font-weight:bold">do&lt;/span> |app|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app.configure &lt;span style="font-weight:bold">do&lt;/span> |config|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.adapter = &lt;span style="font-style:italic">:Reel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.adapter_options[&lt;span style="font-style:italic">:websocket_handler&lt;/span>] = proc &lt;span style="font-weight:bold">do&lt;/span> |websocket|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> websocket &amp;lt;&amp;lt; &lt;span style="font-style:italic">&amp;#34;hello, world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是相当多的文档所提到的方法。因为它只期望handler支持&lt;code>#call&lt;/code>方法，所以你可以写一个你自己的ad-hoc分发器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">WebsocketHandler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> call(websocket)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = websocket.read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># do something with the message, call methods on other objects, log stuff, have your fun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很多文档并不提及一些套接字编程的基础。假如你发现你的handler被挂起并且不再处理响应，这意味着你需要重新修改程序，但是不需要为此感到烦恼：你只需要实现一个不断从套接字中读取信息并且让&lt;code>Celluloid::IO&lt;/code>实现它的非阻塞魔术方法的循环就行了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">WebsocketHandler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> call(websocket)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">loop&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = websocket.read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># do something with the message, call methods on other objects, log stuff, have your fun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>因为非阻塞的特点，你不再需要担心你的CPU占用会一直停留在100%。然而，你会受到节点在CPU使用率以及事件处理方面同样的限制（比如，假如你的程序是CPU密集型的，它便会影响自身的吞吐量）。&lt;/p>
&lt;p>幸运的是，我们可以在Ruby中使用线程。我决定通过为每一个客户端指定一个&lt;code>Celluloid Actor&lt;/code>来好好利用线程。这个做法允许我去提供一些CPU密集型的操作而不需要妥协于系统中的其他用户。到目前为止，这个方案表现得不错。&lt;/p>
&lt;h2 id="疏漏的地方">疏漏的地方&lt;/h2>
&lt;p>我的解决方案本来应该考虑非WebSocket的客户端，但事实上我却没有做到。&lt;code>webmachine-ruby&lt;/code>通过允许你实现流式API而将此变得简单且没有后顾之忧。我想这将只需要一些JS代码去做相互之间的反馈并且提供一个指向接收者的连接。&lt;/p>
&lt;p>这篇文档并未涵盖所有可能在套接字连接时出现的事件（onerror, on close, onopen, onmessage）。你可以在连接套接字的时候看到它们，并且每一个都带着一个块。&lt;/p>
&lt;p>这个工具也并不提供一个成熟的结合频道以及信息代理的发布/订阅系统。如果你更多的是需要这方面的工具，其实可以考虑使用&lt;code>faye&lt;/code>以及&lt;code>websocket-rails&lt;/code>。&lt;/p></description></item><item><title>DIY an interesting timer through terminal-notifier and crontab under Mac OS X</title><link>https://blog.hackerpie.com/posts/archive/diy-an-interesting-timer-through-terminal-notifier-and-crontab-under-mac-os-x/</link><pubDate>Sun, 12 Jan 2014 15:51:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/diy-an-interesting-timer-through-terminal-notifier-and-crontab-under-mac-os-x/</guid><description>&lt;p>Today I will show you how to DIY an intersting notifier automatically running per hour under the Mac OS X 10.8 and higher, all we need are a terminal-notifier and the system built-in command line program named &lt;code>crontab&lt;/code>.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="1-install-the-terminal-notifier">1. Install the terminal-notifier&lt;/h2>
&lt;p>&lt;code>terminal-notifier&lt;/code> is a program written in the awesome &lt;a href="https://www.ruby-lang.org/en/">Ruby&lt;/a> program language, we can visit &lt;a href="https://github.com/alloy/terminal-notifier/releases">the releases page&lt;/a> and download the newest version of terminal-notifier. Steps to install it:&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>Please click the green button such as &amp;ldquo;&lt;strong>terminal-notifier-1.5.0.zip&lt;/strong>&amp;rdquo; and select a path wherever you love to save the zip file;&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>After downloading completed, open the folder you selected in the above step, look for the zip file, and then double-click to extract the program;&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>Copy the extracted program &lt;strong>terminal-notifier&lt;/strong>;&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>Click the &amp;ldquo;Applications&amp;rdquo; tab in the sidebar of your finder, and then paste the copied file.&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>Lastly, open a terminal and then run the following command to test if the notifier has been installed successfully.&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>/Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier -title &lt;span style="font-style:italic">&amp;#34;Test Installation&amp;#34;&lt;/span> -message &lt;span style="font-style:italic">&amp;#39;your notifier has been installed successfully!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>You will see a notification message appears. If not, re-check your installation and make sure you have finished the above steps strictly.&lt;/p>
&lt;h2 id="2-create-the-timer-to-notice-you-to-have-a-break">2. Create the timer to notice you to have a break&lt;/h2>
&lt;p>In order to run the notifier periodically, we use &lt;code>crontab&lt;/code>, which maintains crontab files for individual users.&lt;/p>
&lt;p>Now, please open your terminal again, and then type the following command, run it:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>crontab -e
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Append the following line to the openning file:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>0 * * * * /Applications/terminal-notifier.app/Contents/MacOS/terminal-notifier -title &lt;span style="font-style:italic">&amp;#34;Guy, take a break please!&amp;#34;&lt;/span> -message &lt;span style="font-style:italic">&amp;#39;You have worked for a hour again, I suggest that you should take a break.&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Save the file and exit, your cron tasks will be updated automatically.&lt;/p>
&lt;p>After every thing is finished, you will reveive the attentive message per hour. Cheers!&lt;/p>
&lt;p>This post only acts like a demo, you can do more powerful works as you imagine.&lt;/p>
&lt;p>&lt;strong>Related Resources:&lt;/strong>&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/alloy/terminal-notifier">terminal-notifier&lt;/a>&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;a href="http://www.pantz.org/software/cron/croninfo.html">crontab&lt;/a>&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;a href="http://unixhelp.ed.ac.uk/CGI/man-cgi?crontab">crontab man page&lt;/a>&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;a href="http://www.thegeekstuff.com/2009/06/15-practical-crontab-examples">Linux Crontab: 15 Awesome Cron Job Examples&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Split logs automatically every day</title><link>https://blog.hackerpie.com/posts/archive/split-logs-automatically-every-day/</link><pubDate>Sat, 07 Sep 2013 01:11:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/split-logs-automatically-every-day/</guid><description>&lt;p>&lt;strong>Related resource(s):&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;linuxcommand: logrotate&amp;rdquo;:http://linuxcommand.org/man_pages/logrotate8.html&lt;!-- raw HTML omitted -->
&lt;strong>logrotate&lt;/strong> is designed to ease administration of systems that generate large numbers of log files. Normally, logrotate is run as a daily cron job.&lt;/p>
&lt;p>&lt;strong>Some important knowledges:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Any number of config files may be given. Later config files may override the options given in earlier files, so the order in which the logrotate config files are listed in is important. Normally, &lt;strong>a single config file which includes any other config files which are needed should be used&lt;/strong>. If a directory is given, every file in that directory is used as a config file.&lt;/li>
&lt;li>&lt;strong>Default config file:&lt;/strong> /etc/logrotate.conf. You can include other config files within it using &lt;strong>include&lt;/strong> directive.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="assumption">Assumption&lt;/h2>
&lt;ol>
&lt;li>Your site is &lt;code>example.com&lt;/code>&lt;/li>
&lt;li>The site is located in &lt;code>/var/www/example/&lt;/code>&lt;/li>
&lt;li>Your site is deployed by Capistrano, so you can find your logs in &lt;code>/var/www/example/shared/log/&lt;/code>&lt;/li>
&lt;li>Your static contents server is &lt;strong>Nginx&lt;/strong>, and its logs are located in &lt;code>/var/www/example/shared/log/&lt;/code> and their names start with &lt;code>nginx_&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="how-to-do">How to do&lt;/h2>
&lt;h3 id="1-login-your-server">1. Login your server&lt;/h3>
&lt;h3 id="2-make-sure-that-include-etclogrotated-is-existed-in-default-config-file-and-not-commented">2. Make sure that &amp;ldquo;include /etc/logrotate.d&amp;rdquo; is existed in default config file and not commented:&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>You should be able to find the directive shown below, if not, append it manully.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;h3 id="3create-new-logrotate-config-files-for-your-sites-logs">3.Create new logrotate config files for your site&amp;rsquo;s logs&lt;/h3>
&lt;p>&lt;strong>A. Create new rotate config file for application log:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Type following contents, and save.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>B. Create new rotate config file for server log:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Type following contents, and save.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>Attention:&lt;/strong>&lt;!-- raw HTML omitted -->
&lt;strong>/var/run/nginx.pid&lt;/strong> is your nginx pid file path, but someone may use default nginx pid path(&lt;strong>/opt/nginx/logs/nginx.pid&lt;/strong>). You have two solutions to solve this conflict:&lt;/p>
&lt;blockquote>
&lt;p>A. Change &lt;code>/var/run/nginx.pid&lt;/code> to &lt;code>/opt/nginx/logs/nginx.pid&lt;/code> or other path you have defined in your nginx config file.
B. Set your &lt;strong>&amp;ldquo;pid&amp;rdquo;&lt;/strong> directive to expected path:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;/blockquote>
&lt;p>pid /var/run/nginx.pid;
&lt;!-- raw HTML omitted -->&lt;/p>
&lt;blockquote>
&lt;p>in your nginx config file(such as, /opt/nginx/conf/nginx.conf), and then restart your server.&lt;/p>
&lt;/blockquote>
&lt;p>If the above work are all finished, everything done! You should remember to check if everything runs normally at other days.&lt;/p></description></item><item><title>Backup database and other attachments in ROR</title><link>https://blog.hackerpie.com/posts/archive/backup-database-and-other-attachments-in-ror/</link><pubDate>Sat, 07 Sep 2013 00:26:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/backup-database-and-other-attachments-in-ror/</guid><description>&lt;h2 id="related-resources">Related Resources&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>rsync&lt;/strong>:http://rsync.samba.org/&lt;/li>
&lt;li>&lt;strong>Crontab&lt;/strong>:http://unixhelp.ed.ac.uk/CGI/man-cgi?crontab+5&lt;/li>
&lt;li>&lt;strong>&amp;ldquo;Linux Crontab 定时任务 命令详解&amp;rdquo;&lt;/strong>:http://blog.csdn.net/tianlesoftware/article/details/5315039&lt;/li>
&lt;li>&lt;strong>[rubygem]&amp;ldquo;backup&amp;rdquo;&lt;/strong>:https://github.com/meskyanichi/backup&lt;/li>
&lt;li>&lt;strong>[rubygem]&amp;ldquo;whenever&amp;rdquo;&lt;/strong>:https://github.com/javan/whenever&lt;/li>
&lt;/ol>
&lt;h2 id="automatically-backup-on-the-remote-server">Automatically backup on the remote server:&lt;/h2>
&lt;p>Let&amp;rsquo;s firstly assumpt:&lt;/p>
&lt;ol>
&lt;li>You have a site named &amp;ldquo;&lt;strong>example.com&lt;/strong>&amp;rdquo;;&lt;/li>
&lt;li>You can login to it through a username &amp;ldquo;&lt;strong>deploy&lt;/strong>&amp;rdquo;, and its password is &amp;ldquo;&lt;strong>password&lt;/strong>&amp;rdquo;;&lt;/li>
&lt;li>You located the contents of your site in &lt;code>/var/www/example/&lt;/code>;&lt;/li>
&lt;li>Your database server is &lt;strong>Mysql&lt;/strong>, and the database for your site is &lt;strong>example_production&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>1. SSH login:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>2. Install the backup:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>3. Prepare directories for backup files:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>4. Generate and edit backup script:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Input the below content:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># encoding: utf-8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Backup::Model.new(&lt;span style="font-style:italic">:example_db&lt;/span>, &lt;span style="font-style:italic">&amp;#39;Dumping example Production Database&amp;#39;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> split_into_chunks_of 250
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> database MySQL &lt;span style="font-weight:bold">do&lt;/span> |db|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.name = &lt;span style="font-style:italic">&amp;#34;example_production&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.username = &lt;span style="font-style:italic">&amp;#34;&amp;#34;&lt;/span> &lt;span style="font-style:italic"># Replace the blank string with your real username&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.password = &lt;span style="font-style:italic">&amp;#34;&amp;#34;&lt;/span> &lt;span style="font-style:italic"># Replace the blank string with your real password&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.host = &lt;span style="font-style:italic">&amp;#34;localhost&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.port = 3306
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.socket = &lt;span style="font-style:italic">&amp;#34;/var/run/mysqld/mysqld.sock&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> db.additional_options = [&lt;span style="font-style:italic">&amp;#34;--quick&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;--single-transaction&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> store_with Local &lt;span style="font-weight:bold">do&lt;/span> |local|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local.path = &lt;span style="font-style:italic">&amp;#34;/var/www/example/backup/db&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> local.keep = 10
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> compress_with Gzip
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Run backup command to confirm that your config works:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>Attention&lt;/strong>: Remember to update the config file if you have changed the username and/or password of the database.&lt;/p>
&lt;p>&lt;strong>5. Install whenever:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>6. Generate a schedule.rb file with whenever:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>The last command will create a new file named &lt;strong>&amp;ldquo;schedule.rb&amp;rdquo;&lt;/strong> under &lt;code>config/&lt;/code> directory.&lt;/p>
&lt;p>&lt;strong>7. Add a daily task:&lt;/strong>&lt;/p>
&lt;p>Open the file to edit:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Contents:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>set &lt;span style="font-style:italic">:output&lt;/span>, &lt;span style="font-style:italic">&amp;#34;~/Backup/example_whenever.log&amp;#34;&lt;/span> &lt;span style="font-style:italic"># This is important, it can help you to find the reason when failed to backup the database&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>every &lt;span style="font-style:italic">:day&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> command &lt;span style="font-style:italic">&amp;#34;cd ~/Backup &amp;amp;&amp;amp; backup perform -t example_db&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;strong>8. Update whenever task into crontab:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>9. Check whether the task is updated successfully or not:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>If successed, you should see your new task shown at the bottom of the file.&lt;/p>
&lt;h2 id="synchronize-remote-backups-every-day-automatically-by-rsync-and-crontab">Synchronize remote backups every day automatically by rsync and crontab:&lt;/h2>
&lt;p>&lt;strong>Attention&lt;/strong>: Below operations are played on a different server, which is used to sync files. We assumpt its domain is &lt;code>another.com&lt;/code> and the username is &lt;code>deploy&lt;/code>.&lt;/p>
&lt;p>&lt;strong>1. SSH login:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>2. Write a synchronize shell script:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Input the below contents into the new file named &amp;lsquo;sync.sh&amp;rsquo;:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>and then, assign the scripe execution authority:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Run the script to ensure everything works well:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>Attention:&lt;/strong> Because it is required to be authorized to access the targer server, you should remember to copy your ssh public key to the target server(such as, &lt;strong>example.com&lt;/strong>) before you can sync files.&lt;/p>
&lt;p>&lt;strong>3. Open user&amp;rsquo;s crontab config file:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Append the below task at the end:&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>Ok, that&amp;rsquo;s all. The rest work is that remember to check if there is any backups generated.&lt;/p></description></item><item><title>Write css codes distinct from different pages</title><link>https://blog.hackerpie.com/posts/archive/write-css-codes-distinct-from-different-pages/</link><pubDate>Thu, 29 Aug 2013 15:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/write-css-codes-distinct-from-different-pages/</guid><description>&lt;p>In rails, there is normally a view corresponding to an action. So if you want to do some special styles based on different pages, you can render controller name and action name in your layout file like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">body&lt;/span> class=&lt;span style="font-style:italic">&amp;#34;#{controller_name} #{action_name}&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;lt;!-- Render something --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="font-weight:bold">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s assumpt that your current page controller is &lt;code>ProductsController&lt;/code>, and your action is &lt;code>index&lt;/code>, then you can write your style codes like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scss" data-lang="scss">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">.products.index&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">/* some styles */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Failed to stop or restart Nginx server through serevice command</title><link>https://blog.hackerpie.com/posts/archive/failed-to-stop-or-restart-nginx-server-through-serevice-command/</link><pubDate>Fri, 09 Aug 2013 11:39:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/failed-to-stop-or-restart-nginx-server-through-serevice-command/</guid><description>&lt;p>Many people are accustomed to start a Nginx web server through init scripts and then they can control the state of the server through &lt;code>service&lt;/code> command, such as &lt;code>sudo service nginx restart&lt;/code>. But sometimes unobvious config error makes the scripts failed to work. Here I will show an error related to &lt;code>pid&lt;/code> directive in the config file of nginx, which defaultly located at &lt;code>/opt/nginx/conf/nginx.conf&lt;/code>. &lt;!-- raw HTML omitted -->
As ignored by many people, some init scripts assump there is a pid file of nginx located at &lt;code>/var/run/nginx.pid&lt;/code>, but in the fact, the default pid file for nginx is &lt;code>/opt/nginx/logs/nginx.pid&lt;/code>. Because the scripts can&amp;rsquo;t get the correct pid or even get nothing, they failed to stop the nginx process, some tasks dependent on it will be failed too, for example, you are not able to restart the server.&lt;!-- raw HTML omitted -->&lt;/p>
&lt;p>To resolve this problem, you need to:&lt;/p>
&lt;ol>
&lt;li>&lt;strong>Force terminating your server through:&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ sudo service nginx destroy
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>&lt;strong>Open your nginx config file to edit:&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ sudo vim /opt/nginx/conf/nginx.conf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>&lt;strong>Specify the path of your pid file:&lt;/strong>&lt;/li>
&lt;/ol>
&lt;pre tabindex="0">&lt;code># /opt/nginx/conf/nginx.conf
pid /var/run/nginx.pid
&lt;/code>&lt;/pre>&lt;ol start="4">
&lt;li>&lt;strong>After saving your change, start your server now:&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ sudo service nginx start
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="5">
&lt;li>&lt;strong>To confirm that your pid config has taken effect, you can cat your pid file and/or try to restart your server through &lt;code>service&lt;/code> command:&lt;/strong>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ cat /var/run/nginx.pid
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ sudo service nginx restart
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>As expected, you will see the screen out &lt;strong>&amp;ldquo;OK&amp;rdquo;&lt;/strong> for your operations.&lt;/p></description></item><item><title>export/import datas to/from a csv file</title><link>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</link><pubDate>Thu, 25 Jul 2013 22:19:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</guid><description>&lt;p>今天需要给客户的网站做支持产品数据导出并且更新的功能，所以就涉及到了数据的导入导出了。在经过一番对比之下，果断使用&lt;code>csv&lt;/code>格式文件作为数据导入导出的载体。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="导出csv文件">导出csv文件&lt;/h4>
&lt;p>与csv文件主要相关的类是&lt;code>CSV&lt;/code>,此类在ruby的标准库中被定义，所以只要在代码开头引入相关文件即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;csv&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着需要创建csv文件，并在其中写入数据:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>CSV.open &lt;span style="font-style:italic">&amp;#34;path/to/csv/file&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;wb&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:col_sep&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;|&amp;#39;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span> |csv|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> csv &amp;lt;&amp;lt; [&lt;span style="font-style:italic">&amp;#34;one&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;row&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;of&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;contents&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 这里有几个细节值得一提：**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>&lt;code>open&lt;/code>方法是用于对CSV文件进行写操作的主要接口,对CSV文件进行写操作都应该使用此方法;&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>&amp;lt;&amp;lt;&lt;/code> 操作符支持将&lt;strong>字符串数组&lt;/strong>写入到csv文件,一个数组为一行，数组中的一个字符串为一个单元(field);&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>open&lt;/code>方法的第三个参数是一个哈希，用于为打开的文件指定初始化赋值，具体可用的option以及其值可参考&lt;code>new&lt;/code>方法的说明:http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html#method-c-new &lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>:col_sep&lt;/code>用于指定文件中每一行中的每个单元之间的分隔符，当通过字符串数组想文件中添加新行的时候，CSV将会在数组元素也就是每一行的单元之间插入指定的分隔符，分隔符需要尽量避开已经在待导出数据中存在的字符，以免后续导入的时候发生歧义。&lt;/li>
&lt;/ol>
&lt;h4 id="导入csv文件">导入csv文件&lt;/h4>
&lt;p>导入csv除了需要用到相关的类&lt;code>CSV&lt;/code>，还可能用到的类是&lt;code>CSV::Row&lt;/code>，前者提供打开文件以及将文件按行分隔的方法&lt;code>foreach&lt;/code>，foreach将分隔后的行逐行分配到CSV::Row的实例中，通过调用CSV::Row的实例方法&lt;code>field&lt;/code>可对每个单元进行读取。&lt;!-- raw HTML omitted -->
假设我有这样一个csv文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>id | value
1234 | hello
2345 | world
&lt;/code>&lt;/pre>&lt;p>则相关的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>CSV.foreach(&lt;span style="font-style:italic">&amp;#39;path/to/file&amp;#39;&lt;/span>), &lt;span style="font-style:italic">:col_sep&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;|&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:headers&lt;/span> =&amp;gt; &lt;span style="font-style:italic">:first_row&lt;/span> &lt;span style="font-weight:bold">do&lt;/span> |row|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># use datas of each row&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> id = row.field &lt;span style="font-style:italic">&amp;#39;id&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value = row.field &lt;span style="font-style:italic">&amp;#39;value&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 同样这里也有几个细节需要注意:**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>&lt;code>foreach&lt;/code>是CSV类中用于读取文件的标准方法；&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>通过指定&lt;code>:col_sep =&amp;gt; '|'&lt;/code>可使CSV按照指定的分隔符分隔好文件内容，方便后面&lt;code>field&lt;/code>方法的调用；&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>指定&lt;code>:headers =&amp;gt; :first_row&lt;/code>可使CSV将第一行视为文件的headers，并且结合&lt;code>:col_sep&lt;/code>的设定可以将headers进行分割，这两个是&lt;code>field&lt;/code>方法的基础。&lt;/li>
&lt;/ol>
&lt;h5 id="related-links">Related links:&lt;/h5>
&lt;p>&lt;a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html&lt;/a> &lt;!-- raw HTML omitted -->
&lt;a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV/Row.html">http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV/Row.html&lt;/a>&lt;/p></description></item><item><title>Rails HTTP Status Code to Symbol Mapping</title><link>https://blog.hackerpie.com/posts/archive/rails-http-status-code-to-symbol-mapping/</link><pubDate>Wed, 24 Jul 2013 15:00:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/rails-http-status-code-to-symbol-mapping/</guid><description>&lt;p>Sometimes you might need to set the HTTP response head with different status to specify the different handled results. You can do this in Rails by add a &lt;code>:status&lt;/code> to a rails method such as &lt;code>#respond_with&lt;/code>. Here list all the maps:&lt;/p>
&lt;p>{% gist 2405434 %}&lt;/p>
&lt;p>Addtionally, you can view all these on your local machine by installing the gem &lt;code>cheat&lt;/code>, and see all status codes using command &lt;code>cheat status_codes&lt;/code>.&lt;/p>
&lt;p>All these informations come from internet, the codes file comes from &lt;a href="https://gist.github.com/ktkaushik">ktkaushik&amp;rsquo;s&lt;/a> gist and other information comes from &lt;a href="http://www.codyfauser.com/2008/7/4/rails-http-status-code-to-symbol-mapping">Cody Fauser&amp;rsquo;s post&lt;/a>&lt;/p></description></item><item><title>Delete multiple git remote branches by prefixing all refs with a colon</title><link>https://blog.hackerpie.com/posts/archive/delete-multiple-git-remote-branches-by-prefixing-all-refs-with-a-colon/</link><pubDate>Sun, 21 Jul 2013 15:46:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/delete-multiple-git-remote-branches-by-prefixing-all-refs-with-a-colon/</guid><description>&lt;p>This article shows how to delete multiple remote branches in Git.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin :branch-1 :branch-2 [:other-branches]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Remember the colon &lt;code>:&lt;/code>&lt;/p></description></item><item><title>Track Original Repo When Fork</title><link>https://blog.hackerpie.com/posts/archive/track-original-repo-when-fork/</link><pubDate>Sun, 21 Jul 2013 10:24:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/track-original-repo-when-fork/</guid><description>&lt;p>{% gist 5908916 %}&lt;/p></description></item></channel></rss>