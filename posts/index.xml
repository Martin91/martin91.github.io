<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on Hackerpie</title><link>https://blog.hackerpie.com/posts/</link><description>Recent content in Posts on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 01 Dec 2024 23:20:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>谈谈我这几个月来的远程工作</title><link>https://blog.hackerpie.com/posts/remote/share-about-my-remote-work-experience-for-months/</link><pubDate>Sun, 01 Dec 2024 23:20:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/remote/share-about-my-remote-work-experience-for-months/</guid><description>&lt;p>从今年 8 月开始，我入职了一家新公司，正式开始了我的远程工作。记得面试的时候，面试官问我如何看待远程工作，我说作为对比，我比较反感办公室里有些同事轻易打断我的工作，所以我第一个期待的是远程工作可以给我不被打扰的机会。事实上，几个月下来，远程工作总体而言带给我的还是很多幸福感的。这些幸福感分为两个主要的点：&lt;strong>灵活的工作地点，以及不被打扰的空间&lt;/strong>。&lt;/p>
&lt;h2 id="远程工作给我的幸福感">远程工作给我的幸福感&lt;/h2>
&lt;h3 id="灵活的工作地点">灵活的工作地点&lt;/h3>
&lt;p>工作地点灵活是远程工作最大的好处。在我的个人办公室（后面会讲我的个人办公室）之外的工作地点分类，按照频率，大概是：&lt;/p>
&lt;ul>
&lt;li>车上：每周&lt;/li>
&lt;li>咖啡馆：每月 2-3 次&lt;/li>
&lt;li>朋友办公室：每月大概 1 次&lt;/li>
&lt;li>其他：偶尔因为家里需要兼顾，会在家里办公；或者可能因为回老家，会在动车上办公&lt;/li>
&lt;/ul>
&lt;p>之所以在车上最多，是因为我近期会习惯每周五中午把车开到我老婆公司楼下路边，为了等她下班后一起吃(ceng)个晚饭然后接她回家。写代码的时候车窗开一条缝，既可以通风，也方便听着车门外的声音，享受自然的白噪音。如果遇上会议，关上车窗后，车子也能提供很好的隔音，并不会给会议造成干扰。当然了，这一切，也同时得益于 MacBook Pro M 系列笔记本的续航能力，通常我一个下午都不需要找地方充电。&lt;/p>
&lt;p>总体而言，我不是特别喜欢去咖啡馆工作，因为咖啡馆的桌椅并非为了办公设计，持续办公时间长了之后我脖子会很难受，我想去咖啡馆里主要的原因：自己一个人呆腻了，会有些许烦闷，这个时候想换个环境让自己内心重新平静，我一般在咖啡馆不会逗留超过一个半小时。&lt;/p>
&lt;p>后面也会想要探索其他办公空间，比如码头、海边、校园之类。但是不论在哪里办公，我都得额外注意办公信息安全，比如只使用个人手机热点网络，尽量在人少的角落，屏幕不对着其他人等等，远程办公给了我自由的空间，但是我仍旧需要保证空间里的安全。&lt;/p>
&lt;h3 id="不被打扰的空间">不被打扰的空间&lt;/h3>
&lt;p>过去在办公室里上班，我经常需要找一些安静的角落工作，比如茶水间或者其他部门所在楼层，原因在于总是有一些同事会有意无意地打断我的专注状态，这种其实是一种同步的沟通方式，因为人已经在面前，我不得不立马回应。而远程工作的好处是，我的同事和我，都会自然而然预期沟通是异步的：你发出的消息，不一定会被立马回复；你收到消息，不一定需要立马阅读，也不一定需要立马回复，真的很急的话，仍然可以语音呼叫，当然，这会给人带来心理门槛，所以这种情况几乎没有出现过。&lt;/p>
&lt;p>如果是居家工作，那干扰源可能从同事变成家里其他人，尤其是有宝宝的家庭。为了隔绝这种打扰，我通过自如在家附近合租了一个房间，简单布置成我的个人办公室。这样的话，我就有了专门的用于工作的空间，通勤时间控制在 10 分钟左右，又实现了独立的空间。&lt;/p>
&lt;h2 id="远程工作更要注意工作效率和健康">远程工作更要注意工作效率和健康&lt;/h2>
&lt;p>远程工作既有美好的一面，但也有我所比较警惕的方面，主要是工作效率和健康的问题。&lt;/p>
&lt;p>远程工作因为身处独立空间，身边没有其他同事坐着，会少了很多 peer presure，这时候如果人想偷懒，简直是天时地利。从公司或者领导，也就是管理的角度来说，我相信他们是基于信任以及以结果为导向为主来看待这个问题。而作为我自己来说，我则会尝试通过自律或者借助工具来确保自己的工作效率。&lt;/p>
&lt;p>如同我在之前的文章《保持高效与专注的 5 个习惯》里所分享的，我目前仍旧延续了里边所有的习惯，比如不会在办公电脑上登陆个人微信等即时聊天软件，也会每天维护自己的 Todo list，确保自己不会在每天各种突然的信息和事务里迷失方向，尽量还是以高优先级的工作为主。&lt;/p>
&lt;p>除了这些习惯的延续，我最近则是更进一步体会到&lt;strong>确认与拒绝&lt;/strong>所带给我的力量。过往我可能不好意思回绝同事的请求，是工作中的老好人，来什么接什么，以至于自己每天都很忙，甚至久了演变成焦虑，因为我是重视承诺的人，如果接了活又没按照承诺的完成，就会陷入自我否定。现在我则是尝试了解清楚每件事情的轻重缓急程度，有些需求是伪需求，有些需求不一定需要我来完成，有些需求可以放到 backlog 慢慢来，确认与拒绝不仅仅只是为了少做事，更多的是有限资源的合理化运用，最重要的是让我减少了一些内耗。&lt;/p>
&lt;p>不过，前面说的这些习惯，似乎都挺好了，但是其实我也不是 100% 做到。我有时候会难以避免深陷一个事情的情况。可能某天，心里就是无比想要继续把一个 bug 的根因找出来，或者是想要弄明白一个技术背后的原理，而这些在团队看来可能并不紧急，而同时还有其他高优先级的事情在等着我。这种难以抗拒很像眼前的一块诱人的蛋糕，你明知道自己已经吃撑，但是始终觉得只要下一口，肯定无比美味。有的时候会因此非常懊悔，觉得自己耽误事，但慢慢又获得平和：我又不是机器，就当自己是馋嘴的小孩，偷吃了一口蛋糕就好。争取未来再多一些理性，让感性多一些败局，让自己似乎因此显得无比专业。&lt;/p>
&lt;p>健康方面，我有自己的升降办公桌，通常会以 45-55 分钟为一个周期，周期之间会有 5 分钟左右的活动时间，可能是上个厕所，也可能是走动一下，也或者是简单的运动，同时不同周期会在坐姿和站姿之间进行切换。我知道的是，久坐或者久站都不健康，当然，我从不躺着工作。&lt;/p>
&lt;p>我所租用的房间，是在一个老小区，运气比较好的是，这套房子在一个 3 楼的大平台，邻居养了很多花花草草，还有鸽子，旁边是一个小学，休息间隙，我有时会在平台上走走，同时手里拿着零食补充一下能量，眼睛看看花草或者鸽子，又或者是看看对面小学里小朋友们在课间嬉闹。&lt;/p>
&lt;p>运动方面，感谢 Mike 建议，我买了一对哑铃，照着短视频上的动作，每天做 1 - 2 组无氧，间或做下广播体操，这里不得不提一下，以前读书时候嗤之以鼻的广播体操，现在成了职场牛马之后，却反而深感简单而确实有效。&lt;/p>
&lt;p>除了散步和运动，我秉持着动起来的原则，偶尔也会下楼骑上电动车，到村里角落一个阿姨的水果摊上挑上几个水果，来回一趟加一起，10分钟足矣。阿姨的水果种类不多，价格也都不贵，但是每次都没有踩雷，比超市的物美价廉。对了，水果也是健康必备，可以补充大量维生素。&lt;/p>
&lt;h2 id="灵活与弹性">灵活与弹性&lt;/h2>
&lt;p>我从这份远程工作中获得了一些幸福感，自然也会更愿意接受这份工作中其他一些看似负担的东西。比如我们团队成员分散多个地区，有时候避免不了我的中午时间开会，要么是吃饭时间，要么是午休时间。这个时候，其实灵活与弹性起到很大作用，比如如果这个会议确实重要，我可能先吃饭再来开会；而如果会议本身我不需要很高的参与度，那我则是戴上耳机，边吃饭边参会。休息则是通过调整时间来实现，比如中午正好开会了，那我可能会在会后躺个15分钟，一开始不太适应，觉得是不是有点罪恶，毕竟在公司办公室里的话，这种弹性是不可能有的。但是想想，我休息是为了保持清醒头脑，更高效的工作，从结果来看，这是更正确的选择。&lt;/p>
&lt;p>这些中午的会议安排，要是放在原来公司里，我可能会比较烦躁，因为这样的话，我中午的休息时间就泡汤了，而我下午还得头脑昏昏沉沉地继续工作。&lt;/p>
&lt;p>其他的弹性则表现在有时候可能因为个人事务，会离开工作岗位一段时间，自己则是可以选择在其他时间段回来补上这期间的工作。比如我所知道的，有些同事会在下午的时候短暂离开，去接一下孩子放学之类，这是可以被允许的，只要你不影响自己的工作即可。&lt;/p>
&lt;h2 id="远程工作">远程工作&lt;/h2>
&lt;p>总的来说，我喜欢远程工作，也努力让自己能够做好远程工作。这所谓的做好，其实可能也比在办公室工作更难，因为同事之间鲜少见面，有时候彼此沟通会有误解，向上管理时又该如何呈现自己的工作产出？远程工作需要更多的自律，也需要更多的自我关注，关注自己的心理状态，自己的健康水平。所以，如果你也在思考远程工作是不是适合自己，可以先想想看，自己是不是享受一个人独处，喜欢做计划，以及愿不愿意保持有节律的工作和运动？&lt;/p></description></item><item><title>腾讯 tRPC-Go 框架核心实现源码解读</title><link>https://blog.hackerpie.com/posts/architecture/tencent-trpc-go-framework-source/</link><pubDate>Tue, 19 Dec 2023 20:01:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/architecture/tencent-trpc-go-framework-source/</guid><description>&lt;h2 id="概述">概述&lt;/h2>
&lt;p>tRPC 是一套由腾讯开源的高性能、跨多种编程语言、插件化的 RPC 框架。tRPC-Go 是框架在 Golang 编程语言下的官方实现。&lt;/p>
&lt;p>本文剖析 tRPC-Go 框架的核心实现原理，并非 tRPC-Go 框架快速入门教程，所以不会有框架使用方法方面的介绍。&lt;/p>
&lt;p>本文假设的读者是已经有一定的 tRPC-Go 框架使用经验或对 tRPC-Go 框架设计有基本了解的同学，我希望这篇文章能对想要更深入了解框架原理的同学提供有效的帮助。&lt;/p>
&lt;p>通过阅读本文，你将可以：&lt;/p>
&lt;ul>
&lt;li>熟悉 tRPC-Go 框架核心模块设计原理&lt;/li>
&lt;li>以框架的核心流程为脉络自行延伸了解其他重要模块实现原理&lt;/li>
&lt;/ul>
&lt;p>注意：本文写作时，对应的 tRPC-go 框架版本是 &lt;code>v0.12.0&lt;/code>。&lt;/p>
&lt;h2 id="trpc-go-架构速览">tRPC-Go 架构速览&lt;/h2>
&lt;p>在一头扎进 tRPC-Go 核心组件的设计原理之前，我们先看看 tRPC-Go 框架的整体架构设计，这个架构图大家可以从 tRPC-Go 框架的&lt;a href="https://github.com/trpc-group/trpc-go/">官方文档&lt;/a>中查到。&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/tRPC-Go/overall_architecture.webp" alt="">
 &lt;figcaption>总体框架设计&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>tRPC-Go 框架的最大设计亮点是清晰的组件划分以及高度的灵活性、可扩展性。&lt;/p>
&lt;p>&lt;strong>组件划分方面&lt;/strong>，框架在设计中考虑到了微服务治理中的常见问题，包括服务注册发现、分布式链路追踪以及服务可观测性等，对应到框架，其定义了 Metrics、Tracing、Selector、Conf 以及 Log 等组件；而 Codec 和 Transport 等组件则是 RPC 调用通信过程的标准化。&lt;/p>
&lt;p>在&lt;strong>灵活性和可扩展性&lt;/strong>的考量上，框架利用插件化设计思想，框架的核心组件均可以通过实现框架定义的各个接口来实现业务定制与扩展，我们在日常开发中，最容易接触到的就是各种各样的拦截器，这些都为 tRPC-Go 兼容腾讯内部已有各种协议与框架奠定了基础。&lt;/p>
&lt;p>在这篇文章中，大家将会看到框架在 Codec 、Log 以及 Tracing 等方面的设计实现。&lt;/p>
&lt;h2 id="trpc-go-框架核心模块及应用详解">tRPC-Go 框架核心模块及应用详解&lt;/h2>
&lt;p>学习一个框架，最有效的方法就是先掌握它最基本的业务过程，其次再从各个流程分叉点延伸到各个角落，这样才不会在框架大量的代码中迷失了方向。对于一个网络应用框架而言，进程间的通信过程就是它最基本的业务过程。来一个非常熟悉的例子：一个 HTTP 请求从浏览器端发送到服务器端完成响应，再返回到浏览器端，发生了什么？当然不要怕，这个问题无需回答，放松。我只是为了提出我们今天的第一个问题：&lt;/p>
&lt;blockquote>
&lt;p>一次 RPC 调用的核心过程是怎样的？需要经过哪些环节的处理？&lt;/p>
&lt;/blockquote>
&lt;h3 id="一次-rpc-调用的核心过程">一次 RPC 调用的核心过程&lt;/h3>
&lt;p>HTTP 客户端和服务器端双方想要通信，客户端需要先完成 HTTP 请求头和请求正文的组装，以及域名的解析，获得 IP 地址后，根据请求的 IP 和端口，交由传输层完成请求的传输；而服务器端在收到请求后，需要完成请求信息的结构化解析，然后执行相应的动作，最后同样通过传输层返回响应的头和正文给到浏览器端。&lt;/p></description></item><item><title>Golang interface 类型的 nil 居然不等于字面量 nil?</title><link>https://blog.hackerpie.com/posts/golang/nil-interface-is-not-equal-to-leteral-nil/</link><pubDate>Wed, 20 Sep 2023 12:20:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/golang/nil-interface-is-not-equal-to-leteral-nil/</guid><description>&lt;h2 id="问题描述">问题描述&lt;/h2>
&lt;p>昨天开发的一段代码在运行时遇到了奇怪的 panic 问题，报错：&lt;/p>
&lt;pre tabindex="0">&lt;code>runtime error: invalid memory address or nil pointer dereference
&lt;/code>&lt;/pre>&lt;p>但是奇怪的是，代码中 panic 出处，我是有判断 nil 的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// 这是相关的结构体定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">type&lt;/span> Options &lt;span style="font-weight:bold">struct&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> sourceFrame fmt.Stringer &lt;span style="font-style:italic">// 错误根源栈页
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// 省略一堆无关代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> options.sourceFrame != &lt;span style="font-weight:bold">nil&lt;/span> { &lt;span style="font-style:italic">// 这里判断了 options.sourceFrame 是否为 nil
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> metaData[metaKeySourceFrame] = options.sourceFrame.String() &lt;span style="font-style:italic">// 这一行代码触发 panic
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>好奇怪，我不是都判断了是否为 nil 了吗？为什么还会报错呢？&lt;/p>
&lt;h2 id="问题分析">问题分析&lt;/h2>
&lt;p>经过一番搜索和学习，最终发现 golang 的一个坑：&lt;strong>interface 类型的 nil 不等于字面量 nil&lt;/strong>。&lt;/p>
&lt;blockquote>
&lt;p>Under the hood, an interface in Golang consists of two elements: type and value.&lt;/p></description></item><item><title>Golang 1.18 及 1.18.1 中 iota 不从 0 开始</title><link>https://blog.hackerpie.com/posts/golang/iota-not-begins-with-0-in-1.18/</link><pubDate>Tue, 07 Mar 2023 14:32:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/golang/iota-not-begins-with-0-in-1.18/</guid><description>&lt;h1 id="一句话读完版">一句话读完版&lt;/h1>
&lt;p>golang 源码中使用了 &lt;code>iota&lt;/code> 定义枚举量，并且没有显式声明起始值的话，请确保没有使用 golang 1.18 或者 golang 1.18.1。&lt;/p>
&lt;h1 id="详细说明版">详细说明版&lt;/h1>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>昨天在线上系统中发现了一个奇怪的现象，代码中有一行 &lt;code>response.Code == konst.SuccessCode&lt;/code> 代码的判断结果总是 &lt;code>false&lt;/code>，经过日志核查，确认 &lt;code>response.Code&lt;/code> 一定是 &lt;code>0&lt;/code>，但是神奇的是 &lt;code>konst.SuccessCode&lt;/code> 却是 1，其定义是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">package&lt;/span> konst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">const&lt;/span> SuccessCode = &lt;span style="font-weight:bold">iota&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最奇怪的是，goland IDE 提示这个常量解析后的值也是 0。&lt;/p>
&lt;p>为什么会是 1 呢？&lt;/p>
&lt;h2 id="问题定位">问题定位&lt;/h2>
&lt;p>经过使用不同的 golang 版本编译后，在本地复现了这个缺陷，问题出在 golang 1.18 上。具体可看：&lt;/p>
&lt;p>&lt;a href="https://go-review.googlesource.com/c/go/+/401134/4">https://go-review.googlesource.com/c/go/+/401134/4&lt;/a>&lt;/p>
&lt;p>此缺陷是由于在 golang 1.18 和 1.18.1 中进行 iota 枚举时，枚举值并不总是从 0 开始递增。在这个问题的修复版本 1.18.2 中，已经修复了这个问题。因此，升级到 1.18.2 版本是解决此问题的最简单方法。另一个解决方法是在定义枚举时指定值 &lt;code>= 0&lt;/code>，这将避免出现 iota 值错误的问题。&lt;/p>
&lt;p>官方修复的记录见：https://github.com/golang/go/issues/52441&lt;/p>
&lt;h2 id="解决方案">解决方案&lt;/h2>
&lt;p>解决方案比较简单，可以升级到 golang 1.18.2 版本，这个版本已经修复了这个问题。如果不想升级，也可以在 konst.SuccessCode 的后面加上 &lt;code>= 0&lt;/code>，这样就能避免出现 iota 值错误的问题了。&lt;/p></description></item><item><title>贪心算法：LeetCode 409 最长回文串双 100 题解</title><link>https://blog.hackerpie.com/posts/algorithms/greedy/longest-palindrome/</link><pubDate>Sat, 14 Jan 2023 09:13:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/greedy/longest-palindrome/</guid><description>&lt;p>这篇文章分享如何借助位的思想将 LeetCode 409——最长回文串的题解优化到双 100。&lt;/p>
&lt;h2 id="题目">题目&lt;/h2>
&lt;p>题目本身是 easy 级别的，原题目是：&lt;/p>
&lt;pre tabindex="0">&lt;code>给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。

在构造过程中，请注意 区分大小写 。比如 &amp;#34;Aa&amp;#34; 不能当做一个回文字符串。
&lt;/code>&lt;/pre>&lt;h2 id="思路分析">思路分析&lt;/h2>
&lt;p>基本的思路是遍历字符串中的所有字符，并且统计每个字符出现的次数，最后求和 &lt;code>length&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>如果字符出现次数为偶数，则将结果 &lt;code>length&lt;/code> 直接加 2；&lt;/li>
&lt;li>如果字符出现次数为奇数，则进一步判断：
&lt;ul>
&lt;li>如果 &lt;code>length&lt;/code> 未曾加过奇数，则将结果 &lt;code>length&lt;/code> 直接加上这个奇数；&lt;/li>
&lt;li>如果 &lt;code>length&lt;/code> 已经加过奇数，则将结果 &lt;code>length&lt;/code> 直接加上这个奇数-1。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>这个思路的基本原则是所有出现次数为偶数的字符可以刚好位于回文中心的两侧，而最多只能有一个长度为奇数的回文中心，超过的子串就只能舍弃掉一个字符使其变成偶数长度。&lt;/p>
&lt;h3 id="对应代码">对应代码&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> longestPalindrome(s &lt;span style="">string&lt;/span>) &lt;span style="">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stats := &lt;span style="font-weight:bold">map&lt;/span>[&lt;span style="">rune&lt;/span>]&lt;span style="">int&lt;/span>{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> _, b := &lt;span style="font-weight:bold">range&lt;/span> s {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> _, found := stats[b]; !found {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stats[b] = 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stats[b]++
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> length := 0
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hasOdd := &lt;span style="font-weight:bold">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">for&lt;/span> _, count := &lt;span style="font-weight:bold">range&lt;/span> stats {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> count % 2 == 0 {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> length += count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> !hasOdd {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> length += count
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hasOdd = &lt;span style="font-weight:bold">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> length += (count - 1)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">return&lt;/span> length
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个题解得到的结果是 100% 时间优势，39% 空间优势，空间占用看来有比较大的优化空间。&lt;/p></description></item><item><title>贪心算法：数组拆分 LeetCode 561</title><link>https://blog.hackerpie.com/posts/algorithms/greedy/split_arrays/</link><pubDate>Thu, 12 Jan 2023 10:50:28 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/greedy/split_arrays/</guid><description>&lt;p>LeetCode #561 是一道贪心算法的 easy 题，记录这道题主要是想梳理一下数学证明的过程。贪心算法比较有趣的是，代码一般写起来都不复杂，但是证明本身才是个比较难的事情。比如在面试过程中，你可能意识到了一个题目需要用贪心算法，或者是你不好判断是否可以使用贪心算法，但是就是无法向面试官证明自己的分析。&lt;/p>
&lt;p>先看题目吧：&lt;/p>
&lt;pre tabindex="0">&lt;code>给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，
使得从 1 到 n 的 min(ai, bi) 总和最大。
返回该最大总和
&lt;/code>&lt;/pre>&lt;p>直觉是使用贪心算法，策略是：&lt;/p>
&lt;pre tabindex="0">&lt;code>对数组 nums 进行升序排序，依次两两分组，取各组中第一个数的和
&lt;/code>&lt;/pre>&lt;h2 id="证明过程">证明过程&lt;/h2>
&lt;p>一般而言，可以使用反证法来验证贪心策略的正确性。&lt;/p>
&lt;p>&lt;strong>假设：&lt;/strong> 有升序排序好的数组 &lt;code>a&lt;/code>，按照上面所说的策略，我们得到分组：&lt;/p>
&lt;pre tabindex="0">&lt;code>(a[0], a[1]), (a[2], a[3]), (a[i-1], a[i]), (a[i+1], a[i+2]), ..., (a[2n-2], a[2n-1])
&lt;/code>&lt;/pre>&lt;p>由于数组是升序，故有 &lt;code>a[i-1] ≤ a[i] ≤ a[i+1] ≤ a[i+2]&lt;/code>，这四个元素对应的分组中较小数求和结果为 &lt;code>a[i-1] + a[i+1]&lt;/code>&lt;/p>
&lt;p>重新排列从&lt;code>a[i-1]&lt;/code>到&lt;code>a[i+2]&lt;/code>的两个分组，共有4种可能的组合：&lt;/p>
&lt;ol>
&lt;li>&lt;code>(a[i-1], a[i+1]), (a[i], a[i+2])&lt;/code>，其对应各组较小数总和为 &lt;code>a[i-1] + a[i] ≤ a[i-1] + a[i+1]&lt;/code>；&lt;/li>
&lt;li>&lt;code>(a[i-1], a[i+2]), (a[i], a[i+1])&lt;/code>，其对应各组较小数总和为 &lt;code>a[i-1] + a[i] ≤ a[i-1] + a[i+1]&lt;/code>；&lt;/li>
&lt;li>&lt;code>(a[i], a[i+1]), (a[i-1], a[i+2])&lt;/code>，其对应各组较小数总和为 &lt;code>a[i] + a[i-1] ≤ a[i-1] + a[i+1]&lt;/code>；&lt;/li>
&lt;li>&lt;code>(a[i], a[i+2]), (a[i-1], a[i+1])&lt;/code>，其对应各组较小数总和为 &lt;code>a[i] + a[i-1] ≤ a[i-1] + a[i+1]&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>即，如果不按照升序结果进行两两分组，则各组较小数的总和小于或等于按照升序结果进行两两分组的各组较小数的总和。&lt;/p></description></item><item><title>Introducing the Schema of Allure Report Tool</title><link>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide/</link><pubDate>Sun, 18 Dec 2022 21:03:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide/</guid><description>&lt;h1 id="background">Background&lt;/h1>
&lt;p>In October, I claimed an issue on the company&amp;rsquo;s internal open source collaboration project. The task was to implement a test report visualization tool for the internal test framework. Because the display effect of Allure is really good, but there is no official detailed description of the underlying schema, so there are some gropings in the implementation process, and it is recorded here, hope it can help someone who may encounter similar problems.&lt;/p></description></item><item><title>Allure 测试报告可视化工具入门</title><link>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide-chinese/</link><pubDate>Sun, 18 Dec 2022 19:03:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/allure-report-beginners-guide-chinese/</guid><description>&lt;h1 id="背景">背景&lt;/h1>
&lt;p>10月份在公司内部的开源协同项目上认领了一个 issue，任务是为内部测试框架实现一个测试报告可视化工具，当时对接人提供了 Allure 作为选型参考，最后经过一番摸索也终于实现了既定效果。因为 Allure 展现效果确实还不错，但是官方没有底层 schema 的详细说明，所以实现过程也有一些摸索，这里记录下，或许会有人遇到类似的问题。&lt;/p>
&lt;h1 id="什么是-allure-框架">什么是 Allure 框架？&lt;/h1>
&lt;p>&lt;a href="https://qameta.io/allure-report/">Allure&lt;/a>，全称 Allure Report，是一个跨编程语言的测试报告工具，通过定义统一的底层 Schema，官方提供了多个编程语言版本的适配实现，目前主要有 Java、JavaScript、Python、Ruby、PHP、Kotlin、.Net 以及 Go。&lt;/p>
&lt;p>Allure 可以生成比较简洁的测试报告，报告划分“Overview”、“Categories”、“Suites”、“Graphs”、“Timeline”、“Behaviors”以及“Packages”几大板块，可以访问&lt;a href="https://allure-framework.github.io/allure-demo">Allure demo&lt;/a> 查看示例效果。如果需要了解更多不同的测试集展示的效果，可以访问 &lt;a href="http://betty.us.es/restest-showcase-demo/">RESTest showcase&lt;/a> 浏览。&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure_Report.png" alt="">
 &lt;figcaption>allure demo&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>除此之外，Allure 也支持多语言切换，目前官方示例包含英语、中文、德语等在内的 12 种语言。&lt;/p>
&lt;p>Allure 框架在各个编程语言之上构建实现了整个测试报告的生态：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-architecture.jpg" alt="">
 &lt;figcaption>allure architecture&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;h1 id="allure-schema">Allure Schema&lt;/h1>
&lt;p>Allure 的跨编程语言特性得益于一套基于 JSON 格式的 Schema，官方在其各个编程语言版本的源码都有相关的定义，比如 Python 版的可以查看 &lt;a href="https://github.com/allure-framework/allure-python/blob/master/allure-python-commons/src/model2.py">allure-python-commons/src/model2.py&lt;/a>。&lt;/p>
&lt;p>但是官方对具体的 Schema 没有文字性的文档，所以 Schema 定义和最终生成报告中的效果的关联，没有确切的说明。我经过摸索和尝试，整理了 Schema 中各个模型的关系：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-models.jpg" alt="">
 &lt;figcaption>allure models&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;h2 id="示例">示例&lt;/h2>
&lt;p>为了直观对比 Schema 和最后生成的报告效果，可以查看这段 allure 的测试用例报告代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;test_shell_testcase_failed32&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例名
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;failed&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例结果，在上图中对应 `Status` 枚举值定义
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;steps&amp;#34;&lt;/span>: [ &lt;span style="font-style:italic">// 测试步骤，在测试报告中展示在面板右下角的 Test body 里
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:17:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:28:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;#@ 测试步骤:39:&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;status&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;passed&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ],
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;start&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;1665562034999&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例开始时间
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;stop&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;1665562053613&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 测试用例结束时间，和开始时间一起确定本用例的耗时，这里是 18s 614ms
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;uuid&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;test_python_testcase-result-37&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// uuid，这个可以由库代码自动生成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;testCaseId&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;20220411-152848-724647399&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 同样可以由库代码自动生成
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;labels&amp;#34;&lt;/span>: [
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;suite&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 这是一个特殊的 label，当为 suite 时，value 表明当前用例对应的测试集名称
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tst_suite_common2&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// tag 是普通的标签，显示在报告中的用例详情中
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;feature&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;medium priority&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;level:3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> },
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tag&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;value&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;type:feature&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上 schema 对应的测试报告如图：


 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/allure/Allure-report-example.png" alt="">
 &lt;figcaption>allure 对照示例&lt;/figcaption>
 &lt;/figure>
&lt;/p></description></item><item><title>How to enable automated captions in zoom.us</title><link>https://blog.hackerpie.com/posts/skills/zoomus-how-to-enable-automated-captions/</link><pubDate>Tue, 16 Aug 2022 10:12:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/zoomus-how-to-enable-automated-captions/</guid><description>&lt;p>There are some times you may need to generate automated captions in zoom.us online meetings, and zoom.us also officially support this amazing feature. However, it is default to disabled so you need to manually enable it firstly. The below are steps to enable it quickly:&lt;/p>
&lt;p>Step 1: Login to &lt;a href="https://zoom.us">https://zoom.us&lt;/a> and then navigate your profile settings page, or you can click &lt;a href="https://zoom.us/profile/setting">this link&lt;/a> directly.&lt;/p>
&lt;p>Step 2: Scroll down your page until the In Meeting (Advanced) section, you can see there are two settings, one is Manual captions and the other is Automated captions, enable both of them like my screenshot.


 &lt;img src="https://blog.hackerpie.com/images/posts/zoom-automated-captions/enable-automated-captions.png" alt="Enable automated captions">
&lt;/p></description></item><item><title>stimulus.js 初体验</title><link>https://blog.hackerpie.com/posts/frontend/stimulus-js-early-experience/</link><pubDate>Sun, 31 Jul 2022 09:46:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/frontend/stimulus-js-early-experience/</guid><description>&lt;p>&lt;code>stimulus.js&lt;/code> 框架是一个轻量的 JavaScript 框架，由大名鼎鼎的 Basecamp 公司开发，也就是 Ruby on Rails 框架核心开发团队所在的公司。老早就听说了 stimulus.js 框架，但是没有实际使用过。最近刚好在自己的一个小项目中有了实践的机会，有了一些心得体会，总结分享一下。&lt;/p>
&lt;p>提醒：如果想快速体验 stimulus.js 做出来的 demo，可以看看这个 &lt;a href="https://github.com/chloerei/todomvc-stimulus">todomvc-stimulus&lt;/a>。&lt;/p>
&lt;h1 id="一个克制的前端-javascript-框架">一个克制的前端 JavaScript 框架&lt;/h1>
&lt;p>谈起对 &lt;code>stimulus.js&lt;/code> 框架总的印象，我觉得这是一个非常克制的前端 JavaScript 框架。它聚焦于&lt;strong>在 HTML 元素与 JavaScript 对象的绑定&lt;/strong>这件事情上，并且这种绑定是单向的，不是前端开发中早已非常普遍的双向绑定。除此之外，它没有提供其他额外的功能。&lt;/p>
&lt;p>由于它的克制，&lt;strong>轻量&lt;/strong>是它必然而然的第一个优点。其次，配合其所设计的 &lt;code>controller&lt;/code> 的概念，可以实现交互逻辑里状态的隔离与解耦。最后，它在 &lt;code>controller&lt;/code> 代码的组织上，也让熟悉 Rails 开发的人感到亲切：&lt;strong>约定大于配置&lt;/strong>。每个 &lt;code>controller&lt;/code> 的定义，都需要按照约定，一个 &lt;code>controller&lt;/code> 对应一个文件，放在 &lt;code>controllers&lt;/code> 目录下，且文件名与 &lt;code>controller&lt;/code> 的名字一致。&lt;/p>
&lt;h2 id="stimulusjs-的轻量">&lt;code>Stimulus.js&lt;/code> 的轻量&lt;/h2>
&lt;p>&lt;code>Stimulus.js&lt;/code> 的核心概念非常少，想要上手 &lt;code>stimulus.js&lt;/code> 框架的使用，只有 4 个核心概念是需要了解的。&lt;/p>
&lt;h3 id="controllers">&lt;code>Controllers&lt;/code>&lt;/h3>
&lt;p>&lt;code>Controllers&lt;/code> 是声明了诸如 &lt;code>data-controller=&amp;quot;todos&amp;quot;&lt;/code> 这样的 data 属性的 HTML 元素所绑定的 JavaScript 对象：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">div&lt;/span> data-controller=&lt;span style="font-style:italic">&amp;#34;todos&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="font-weight:bold">div&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>stimulus.js&lt;/code> 会自动为所有此类元素实例化对应的 controller，每个此类元素各自绑定一个实例。以上述例子来说，&lt;code>stimulus.js&lt;/code> 会自动查找位于 &lt;code>app/javascript/controllers/todos_controller.js&lt;/code> 的文件，并且导入其中导出的默认类，这是一个经典的&lt;strong>约定大于配置&lt;/strong>的做法：&lt;/p></description></item><item><title>Golang 错误处理和日志打印的 5 点建议</title><link>https://blog.hackerpie.com/posts/programming-paradigm/golang-error-logs/</link><pubDate>Sun, 12 Jun 2022 14:49:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/programming-paradigm/golang-error-logs/</guid><description>&lt;p>Golang 语言语法中，错误处理机制是一个非常有特色的设计，它是基于&lt;a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B">防御性编程&lt;/a>思想的设计。不过今天这篇文章不讨论 Golang 错误处理的语法设计问题，相反，今天想思考的是，Golang 里的错误日志应该怎样处理以及打印比较好。&lt;/p>
&lt;h1 id="golang-中错误处理和日志打印的-5-点建议">Golang 中错误处理和日志打印的 5 点建议&lt;/h1>
&lt;ol>
&lt;li>使用错误栈的方式；&lt;/li>
&lt;li>使用逻辑栈信息，而非代码调用栈；&lt;/li>
&lt;li>使用 &lt;code>fmt.Errorf&lt;/code>，不用 &lt;code>pkg/errors&lt;/code> 第三方模块；&lt;/li>
&lt;li>避免使用依赖标准库 &lt;code>fmt&lt;/code> 格式化字符串的日志方法；&lt;/li>
&lt;li>转换外部错误，基于内部错误类型判断。&lt;/li>
&lt;/ol>
&lt;h1 id="使用错误栈的方式">使用错误栈的方式&lt;/h1>
&lt;p>我从转 Golang 开发以来，从看过的 Golang 代码以及自己的实践来说，大概会有以下几种个人认为不是太合理的错误日志打印方式：&lt;/p>
&lt;ol>
&lt;li>每一个函数调用处在发现错误时都打印错误信息；&lt;/li>
&lt;li>约定只在最里层或者最外层函数调用处发现错误时打印错误信息，进一步细分的话，还区分是否会在错误里携带调用栈信息；&lt;/li>
&lt;li>没有明确规范，在整个调用链的任何一处或者多处调用发现错误时都有可能打印错误信息。&lt;/li>
&lt;/ol>
&lt;p>第一种方式，好处是不会遗漏调用链路上的所有调用节点信息，但是在实际应用场景里，服务的线程是并发执行的，不同线程打印的日志行之间相互交错，这种方式打印的同一个链路上的日志非常散乱，导致尽管日志里有全部错误相关的日志，但是却难以简单快速过滤出相关而非干扰的日志行，所谓的好处名存实亡，还占据大量磁盘空间。&lt;/p>
&lt;p>第二种方式，最大的问题是可能缺失对于错误排查所需的一些上下文信息。大多数函数调用都发生在跨层代码逻辑的调用上，如果只在最里层调用处打印错误，则一般缺少最外层请求的大多数参数信息，想象一个存储层代码调用的例子。而另外一种思路是通过记录代码调用栈，可以帮助开发人员还原程序执行路径，进而通过阅读源码以及推理还原请求的上下文信息，这种方式确实能够提高问题排查处理的效率。但是只是纯粹代码调用栈信息的话，一方面会有大量业务无关的代码栈信息可能被记录到日志造成存储空间浪费，另一方面是仍旧可能缺失一些关键的上下文信息，这些信息可能也是问题定位的必要元素。&lt;/p>
&lt;p>第三种方式，本质上是开发者对错误处理本身缺乏思考以及团队缺乏相关的编码规范，看起来这种问题挺低级，但是并不少见。这种自然是最应该避免的。我在此之前，自己也没有好好思考过这个问题。&lt;/p>
&lt;p>第一第二种方式，想要有效定位错误根源，本质上都是需要记录错误发生时的调用栈信息，以便我们知道错误是怎么一路出现的，所以我们得到第一个共识：&lt;strong>错误需要携带调用栈信息&lt;/strong>。&lt;/p>
&lt;h1 id="使用逻辑栈信息而非代码调用栈">使用逻辑栈信息，而非代码调用栈&lt;/h1>
&lt;p>顺着第一点，我们明白了调用栈信息的重要性。关于调用栈，一种最直观的方式就是程序的函数调用栈，这种方式一定程度上并不是面向人的，尽管它详细记录了每个调用栈所在的源代码文件以及行数。比如 Golang 程序在遇到 panic 中打印的调用栈信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>panic: a problem
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>goroutine 1 [running]:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>main.main()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	/tmp/sandbox4213436970/prog.&lt;span style="font-weight:bold">go&lt;/span>:15 +0x27
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Program exited.
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种方式看起来，往往只是一堆文件名和函数名的栈信息，避免不了需要回到源码中进行阅读，如果不是熟悉业务的开发人员，则可能难以快速理解问题产生的原因。&lt;/p>
&lt;p>在我看来，另外一种思路是，如果我可以人为地在代码中主动记录错误发现时所在的位置以及参数等，不也是一种调用栈的思想吗？而且，这种方式下，我还可以额外增加必要的上下文信息。比如我期待拥有类似这样的日志来回溯错误发生的过程，它最大的优点是面向开发人员友好以及偏业务描述的：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>handle upload failed, caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> parse file failed, format: JSON,caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> open file failed, caused by:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> file not found, path: /path/to/file
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这种日志下，信息是偏向于开发者易于理解的，阅读下来，很容易理解程序的目的以及所遇到的异常情况。日志里的“handle upload failed” 等是一种逻辑上的调用链路，而“format: JSON”以及“path: /path/to/file” 则是必要的上下文信息。&lt;/p></description></item><item><title>保持高效与专注的 5 个习惯</title><link>https://blog.hackerpie.com/posts/work-efficiency/5-ways-to-keep-high-efficiency-and-focus/</link><pubDate>Sun, 22 May 2022 11:07:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/work-efficiency/5-ways-to-keep-high-efficiency-and-focus/</guid><description>&lt;p>日常工作中，可能由于各种各样的信息干扰和诱惑，人在保持高效工作与专注上要面对的挑战其实不小。回顾我自己的一些工作经验和体会，我总结了 5 个能帮助我保持专注和高效的习惯：&lt;/p>
&lt;ol>
&lt;li>拒绝注意力迷宫——不要在电脑上登录微信等常用的 IM 工具，关闭手机通知提醒&lt;/li>
&lt;li>异步沟通——直接留言与文档协作&lt;/li>
&lt;li>延迟学习——意外的发现放进 Todo list&lt;/li>
&lt;li>劳逸结合——让身体舒展，让脑子清理&lt;/li>
&lt;li>佩戴耳机，聆听音乐&lt;/li>
&lt;/ol>
&lt;h1 id="1-拒绝注意力迷宫不要在电脑上登录微信等常用的-im-工具关闭手机通知提醒">1. 拒绝注意力迷宫——不要在电脑上登录微信等常用的 IM 工具，关闭手机通知提醒&lt;/h1>
&lt;p>微信等常用社交软件就像一个黑洞，吞噬人的大量时间。只是由于一条新的消息到达加上你想要消灭小红点的强迫症，你自己很快就陷入各种信息的诱惑之中了，看看这种可能的注意力转移路径：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/lost.jpg" alt="">
 &lt;figcaption>图1：注意力迷宫&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>而成功逃出迷宫可能得是一段可观的时间之后的事情了。&lt;strong>我不得不尝试关闭手机上的各种社交软件的通知，这样很大程度降低了我拿起手机查看的频率&lt;/strong>。但是慢慢地，桌面端的微信客户端功能越来越多，先是可以查看朋友圈了，后来又可以刷视频号了……于是我又开始发现，桌面版的微信同样会让我很容易走神，我就开始不在上班时间登录桌面版微信，这同样能够帮助我专注于每天的工作。&lt;/p>
&lt;p>屏蔽了手机通知，主动不去在电脑上登录微信，看似我跟不上很多信息了，但是至少我专注了，而且事实是，现在互联网上的很多信息同质化严重，真假难辨，你没有必要跟上。&lt;/p>
&lt;h1 id="2-异步沟通直接留言与文档协作">2. 异步沟通——直接留言与文档协作&lt;/h1>
&lt;p>异步沟通是沟通双方不需要对收到的消息立马进行回应，而是等到自己某个空档或者习惯的时间窗口再统一进行消息阅读和回复等，比如电子邮件天然就是一种异步沟通的典范，只是国人大都不习惯邮件沟通的这种方式。&lt;/p>
&lt;p>之所以提倡异步沟通，对我个人而言，主要是两方面的需要：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降低思维上下文切换的开销&lt;/strong>：因为人在切换要做的事情的时候，是需要回想事情的缘由、进度以及既定思路的，这些就是开销；&lt;/li>
&lt;li>&lt;strong>降低焦虑&lt;/strong>：焦虑是因为容易纠结别人消息一直未读、已读不回等，仿佛对方不回复，自己就没法继续工作了。想要不焦虑，只能调整自己的预期，预期大家都是异步沟通，也就平和了。&lt;/li>
&lt;/ul>
&lt;p>怎么做呢？常见分两种吧。&lt;/p>
&lt;p>&lt;strong>第一种，有一个零碎的事情需要别人帮忙提供意见或者决策，直接留言&lt;/strong>。以前我总是觉得有什么事情等到对方有空了再说，但是这样事情可能就拖过头了。现在的我会倾向于：&lt;strong>想要沟通的事情，如果不是太复杂，一两句话就能说清楚的，那我就直接在 IM 软件里给对方留言&lt;/strong>，之后这个事情我也就不用担心自己会忘了，同时我也可以放心去做其他事情了，至于他是即时回复还是晚点回复，对我都不是问题，因为我一定是晚点才会回来看消息的。这里其实还有个好处，我总觉得我自己多少有些拖延症，但是通过这种有事早点留言的方式，我就不得不在更快的时间内处理完这个事情，因为一旦对方回复了我，我真的就不好意思拖着了。&lt;/p>
&lt;p>&lt;strong>第二种，涉及团队间沟通等复杂问题的，以协作文档形式沟通&lt;/strong>。最近我负责的业务需要接入另一个中台团队他们的服务，但是因为只有一份简单的文档，又缺少很多上下文，所以很多东西看不明白。在架构师同事帮忙拉了群之后，我先是很认真地整理了一份问题清单，上面写清楚每一个问题的背景（e.g. 我想要用他们的服务做什么事），以及我参考的他们的文档的出处（e.g. 我理解的某个接口是我可以用来完成我想做的事），以及我的具体问题是什么（e.g. 有些地方跟我的需求有出入），同时尽可能以我自己的理解复述了一边，在文档上请求对方给予确认。到了第二个工作日的时候，很让我惊讶的是，同事在看到文档后，并没有在文档上直接回复，而是复制了问题再逐个发回群里逐个回复。后来我将他的回复拷贝回文档上，而他可能也意识到了我的用意，才开始在文档上直接回复。就这样，一次基于文档的异步沟通就这么完成，而且信息很聚焦，对于一个问题，沟通过程和结论都在一份文档里。&lt;strong>文档沟通的形式，一个是便于异步沟通，双方不用反复翻看聊天记录寻找上下文；另一个是帮我自己理清楚真正的问题，以及问题的条理表达，这既是对对方时间的尊重，也是确保沟通高效的方式。&lt;/strong>&lt;/p>
&lt;h1 id="3-延迟学习意外的发现放进-todo-list">3. 延迟学习——意外的发现放进 Todo list&lt;/h1>
&lt;p>刚开始入行工作没多久的时候，我就养成了一种至今都在使用的习惯：延迟学习。这种延迟学习不是指什么知识的学习都要延迟，而是指一些与当前需要优先完成的事情无关的有趣的东西都可以放进 Todo list，可以等业余时间再去学习研究，享受知识的快乐。&lt;/p>
&lt;p>举个稍微具体的例子，程序员写代码的时候，为了解决一个问题，都会尝试在搜索引擎上寻找答案或者灵感，往往在这个时候会发现一些自己从来都不知道的技术，这些技术或者有趣或者酷炫，&lt;/p>
&lt;blockquote>
&lt;p>“哇！&lt;code>(✧◡✧)&lt;/code>好想赶紧学会掌握住啊！”&lt;/p>
&lt;/blockquote>
&lt;p>就像一个沙漠里寻找水源的人突然发现了一箱金子，这个意外发现很让人激动，但是容易让人忘了目标。而我在工作过程中也确实因为各种意外收获的技术思路而拓展了很多技术视野，当然，都是在没有影响本职工作的前提下，怎么做的呢？用 Todo list！&lt;/p>
&lt;p>最开始的时候我使用了 Trello 来分门别类管理我想延后完成的一些技术学习：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/my-trello-boards.png" alt="">
 &lt;figcaption>图2：我的 Trello 看板&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>Blog：是我一些已经基本掌握的知识，我想要在业余时间整理分享的内容&lt;/li>
&lt;li>labs：是我一些临时想到的技术上想要折腾的点子，放在心里手会发痒，所以先写下来，就不会总惦记着了&lt;/li>
&lt;li>Topics：是我一些想要在一些技术分享会上交流的想法，可能会整理成幻灯片等&lt;/li>
&lt;/ul>
&lt;p>比如，我的 Blog 看板下就有这些：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/Blog-board.png" alt="">
 &lt;figcaption>图3：我的 Blog 看板&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>有些点子放了好几年，也都一直没去写，也有些点子很快就放弃了，也有一些干一半，还有一些真的就去写了，都很正常。有些想法当时很冲动，之后再去看一眼，就觉得实在没必要，所以延后是一种验证自己是否只是三分钟热度的好办法，真正的热爱会在之后依旧充满干劲。&lt;/p>
&lt;p>除了记录点子，我也会把过程中想到的、看到的相关片段记录到对应卡片上，比如一些截图、日志或者自己给自己留的问题：


 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/card-example.png" alt="">
 &lt;figcaption>图4：一个记录过程中零碎信息的示例&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>而现在，因为喜欢使用 Notion，我在 Notion 记录了很多类似的东西，一旦后续整理完写成博客后，就会将其从Notion上删除：


 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/work-efficiency/notion-list.png" alt="">
 &lt;figcaption>图5：我在 Notion 上记录的东西&lt;/figcaption>
 &lt;/figure>
&lt;/p></description></item><item><title>多时钟解决雪花算法的时间回拨问题</title><link>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</link><pubDate>Sun, 27 Mar 2022 16:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</guid><description>&lt;p>分布式 ID 生成算法用于在分布式系统中生成全局唯一的 ID 标识，而 twitter 提出的雪花算法便是其中一种知名的算法，其每次会生成一个 64 位的全局唯一整数，算法的基本思想非常巧妙：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> 0 1010......101 1010101010 101010101010
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">\&lt;/span>_/ &lt;span style="">\&lt;/span>___________/ &lt;span style="">\&lt;/span>________/ &lt;span style="">\&lt;/span>__________/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第1位不使用 41位毫秒时间戳 10位机器ID 12位序列号
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了开头的第 1 位不使用，接下来的 41 位时间戳是从指定的起始时间到当前时间所经历的毫秒数，比如设定系统起始时间为 2022 年 3 月 15 日 0 点整，则在 2022 年 4 月 1 日中午 12:00:00.123 时，此时间戳的值应该为 &lt;code>1,512,000,123&lt;/code>，整个时间戳片段，支持最多 &lt;code>69.7&lt;/code> 年，这显然也超出了绝大多数 IT 系统的存活年限。&lt;/p>
&lt;p>而 10 位机器 ID，对应最多容纳一个 1024 个 ID 生成器实例的分布式集群，12 位序列号从 0 到 4095 周而复始连续递增，可以支持单个实例每毫秒 4096 次 ID 生成请求，意味着整个 ID 生成器实例的集群，理论上每毫秒便可以支持最多 &lt;code>4194304&lt;/code> 个 ID 生成，效率非常高。&lt;/p>
&lt;p>雪花算法生成的 ID 的全局唯一的理论基础是全局唯一性与单实例唯一性的结合，全局唯一性由唯一的机器 ID 保证，不同的机器ID保证不同实例生成的 ID 必然不会一致，而单实例唯一由同一毫秒结合不同的序列号来保证，这里的序列号只能做到理论上限，即理论上一毫秒内不会有超过 4096 次的请求。&lt;/p></description></item><item><title>数据库数据加密的 4 种常见思路的对比</title><link>https://blog.hackerpie.com/posts/architecture/data-encrpytion/</link><pubDate>Sun, 20 Mar 2022 13:53:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/architecture/data-encrpytion/</guid><description>&lt;p>最近由于工作需要，我对欧洲的通用数据保护条例做了调研和学习，其中有非常重要的一点，也是常识性的一条，就是需要对用户的个人隐私数据做好加密存储，避免用户隐私明文数据泄露。&lt;/p>
&lt;h1 id="方案分析">方案分析&lt;/h1>
&lt;p>思考如何对用户隐私数据做好加密处理，可以先从分析典型的数据读写链路开始：&lt;/p>
&lt;pre tabindex="0">&lt;code> _________ query _________ read _________
 | | ----------------&amp;gt; | | ----------------&amp;gt; | |
 | 应用 | | DB | | Disk |
 | | &amp;lt;================ | | &amp;lt;================ | |
 --------- rows --------- data page ---------
&lt;/code>&lt;/pre>&lt;p>按照此链路分析，可以按照数据加密的着手点，划分数据加密的 4 类解决方案：&lt;/p>
&lt;ul>
&lt;li>应用层加解密：由应用程序自行负责数据的加解密，这是最自由，但也是最繁琐的一种方案；&lt;/li>
&lt;li>DB 前置处理：在数据库服务器开始服务之前嵌入加密逻辑，典型代表是数据库代理服务；&lt;/li>
&lt;li>磁盘存取环节：这种方案的基本思路则是绕到数据库的身后，在文件系统中注入钩子进程，这样可以在磁盘数据读写之前嵌入加密逻辑，一般&lt;/li>
&lt;li>DB 后置处理：在数据库服务之后嵌入加密逻辑，依赖数据库提供的触发器以及函数定制功能等。&lt;/li>
&lt;/ul>
&lt;p>下面就这几类方案展开分析。&lt;/p>
&lt;h2 id="应用层加解密方案">应用层加解密方案&lt;/h2>
&lt;p>采用这种方案的话，数据加解密对数据库无感知，由应用在存入数据前完成加密，在读取数据后完成解密。这种方案的优点是：&lt;/p>
&lt;ul>
&lt;li>迁移性好：因为不依赖任何数据库特性或者操作系统特性，只需要部署代码即可运行；&lt;/li>
&lt;li>实现灵活：逻辑放在应用层，各种定制或者扩展都非常方便进行，可以轻松实现按表/按列的加密存储。&lt;/li>
&lt;/ul>
&lt;p>当时，缺点也非常明显：&lt;/p>
&lt;ul>
&lt;li>影响使用数据库高级特性：比如数据库索引以及执行计划等;&lt;/li>
&lt;li>大幅影响数据库查询性能：比如 Like 的前缀查询以及 Where 的范围查询等，都会因为数据加密后而只能全表扫描；&lt;/li>
&lt;li>开发维护成本高：每次新增需要加解密数据时都需要对应完成开发调试与测试，开发人员在应用里既要关注核心业务逻辑，还要关注大量的数据加解密的逻辑，当有多个应用或者系统需要集成加解密功能时，每个应用或者系统都需要重复建设此能力。&lt;/li>
&lt;/ul>
&lt;p>在应用层实现加解密方案的话，实现上可以考虑结合各类 orm 的回调函数机制，如 golang 中流行的 ORM 框架 gorm 所提供的 Callbacks 机制，又或者是 Ruby on Rails 框架中 Active Record 的 Callbacks 机制，这些机制都能有效帮助我们将业务代码和控制代码进行相互隔离。&lt;/p></description></item><item><title>Funny Pieces of Codes Make Weekend Happier</title><link>https://blog.hackerpie.com/posts/others/funny-code-pieces/</link><pubDate>Sun, 13 Mar 2022 16:10:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/others/funny-code-pieces/</guid><description>&lt;p>Sunny weekends make me cheerful always, and there are also some funny pieces of codes make it greater. Hope the following codes make you smile, too.&lt;/p>
&lt;p>Although I hardly use Ruby programming language for a long time, I still remember a piece of code from Sidekiq, which is a asynchronous jobs framework for Ruby:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L51-L53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Sidekiq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> self.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Aha! It is a unused method of which the name is a emoticon, and seems that the author of the code is annoying while he or she was writing it. However, there is also a corresponding and serious unit test for it:&lt;/p></description></item><item><title>Golang 编写易于单元测试的代码</title><link>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</link><pubDate>Sun, 06 Mar 2022 17:40:19 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</guid><description>&lt;h2 id="聊聊单测这个事">聊聊单测这个事&lt;/h2>
&lt;p>单元测试一直是大家老生长谈的话题之一，尽管各种测试方法论和测试工具集层层出不穷，但是实际上，在我所工作过的公司中，还没有见过能把单测坚持好的团队。单测的概念不复杂，单测的重要性大家也都是认同的，但是是什么造成单测没有执行下来呢？我觉得主要是两类原因吧：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>开发工期太赶&lt;/strong>：时间只够写功能性代码，测试代码只能舍弃，系统功能依赖不可重复的人力操作&lt;/li>
&lt;li>&lt;strong>项目设计问题&lt;/strong>：项目代码结构设计不良，导致单测代码难以编写，或者运行需要过多复杂的依赖，加上项目已存在大量代码，不敢重构&lt;/li>
&lt;/ul>
&lt;p>第一个原因见仁见智，也不是我想聊的重点。我最近更多的实践和感悟是，如果一个项目从一开始就没有考虑好单测的需要，等到后期就几乎难以改造成易于单元测试执行的结构了。而另一方面，我也是最近才对单测这个事情有一种顿悟的感觉。所以，下面也是想通过一个小 demo 项目，来总结如何设计在 golang 里编写易于单测展开的代码。&lt;/p>
&lt;p>项目设计问题导致的单测难以展开，一般都是因为代码组件之间形成了静态的依赖关系，比如对数据库的依赖，对外部服务的依赖，等等。这些依赖，可能是直接的，也可能是依赖的依赖，也就是间接的。而按照单测的定义，一个足够小的代码单元的测试，应该只关注这个单元的输入和输出即可，外加足以驱动单测执行的最小依赖集合，而不应该担心除此之外的其他一切东西。实际项目中，我们也会将代码进行分层设计，按照职责划分不同的代码模块，但是由于依赖管理的设计意识不足，常会发现模块之间形成了静态的依赖关系，导致编写单测时，不得不去关注各种间接的依赖，这就好比一个芯片在生产阶段就已经焊死在了主板之上，以至于如果我们需要对芯片的功能进行验证的话，就只能将整个主板制作完整之后，才能通过启动主板来检查芯片的功能，想想这有多离谱。&lt;/p>
&lt;h3 id="说明">说明&lt;/h3>
&lt;p>出于演示目的，我编写了一个逻辑上不严谨的小示例项目，代码托管在 &lt;a href="https://github.com/HackerPie/go-microblog">HackerPie/go-microblog&lt;/a>。demo 实现了两个用于管理指定用户微博的 Restful API，按照后续讨论章节的内容，这份代码相应地通过多个 git tag 来识别对应的代码版本，分别为&lt;code>v1&lt;/code>、&lt;code>v2&lt;/code>、&lt;code>v3&lt;/code>和&lt;code>v4&lt;/code>。&lt;/p>
&lt;h4 id="概述">概述&lt;/h4>
&lt;p>尽管只是一个小 demo，我还是希望提前说明下这个 demo 的分层设计。demo 核心逻辑存放在 &lt;code>internal&lt;/code> 目录里，因为只是 demo，所以只划分了 &lt;code>service&lt;/code>、&lt;code>repo&lt;/code> 以及 &lt;code>model&lt;/code> 三层：&lt;/p>
&lt;p>

 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/unit-testing/demo_layers.png" alt="">
 &lt;figcaption>demo 应用分层&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;p>各层说明：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>service&lt;/strong>: 该层代码负责请求的处理与响应，同时负责核心业务逻辑，一般真实项目里，我会进一步分开服务处理和核心业务逻辑层，但是作为示例项目，就简化了；
&lt;ul>
&lt;li>&lt;strong>adapter&lt;/strong>: adapter 主要定义各类 dto 对象和数据库模型对象之间的转换适配，我认为这仍旧属于 &lt;code>service&lt;/code> 层的逻辑，但是在实际代码中，我会独立一个目录来管理；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>repo&lt;/strong>: 该层代码负责单一数据模型的持久化操作，即数据的 CURD；&lt;/li>
&lt;li>&lt;strong>model&lt;/strong>: 该层定义各类数据结构，按照使用场景不同，进一步划分 &lt;code>dto&lt;/code> 和 &lt;code>db&lt;/code>
&lt;ul>
&lt;li>&lt;strong>dto&lt;/strong>: 数据传输对象，用于定义一些需要返回给客户端或者从客户端请求反序列化的数据结构；&lt;/li>
&lt;li>&lt;strong>db&lt;/strong>: 数据库模型定义，用于描述数据库表的结构，此层不负责任何数据读写操作。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>各层代码在项目代码结构中的管理如图：


 &lt;figure>
 &lt;img src="https://blog.hackerpie.com/images/posts/unit-testing/layout.png" alt="">
 &lt;figcaption>internal 代码结构组织&lt;/figcaption>
 &lt;/figure>
&lt;/p>
&lt;h2 id="v1-依赖具体实现的版本">v1: 依赖具体实现的版本&lt;/h2>
&lt;p>&lt;a href="https://github.com/HackerPie/go-microblog/tree/v1">v1 版本&lt;/a> 代码中，是一个经典的代码分层之间直接依赖具体实现的例子：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// cmd/api_server.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>r := gin.Default()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.GET(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, service.ListUserMBlogs)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.POST(&lt;span style="font-style:italic">&amp;#34;/users/:user_id/blogs&amp;#34;&lt;/span>, service.PublishNewBlog)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>r.Run(&lt;span style="font-style:italic">&amp;#34;:8000&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// internal/service/micro_blogs_service.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> ListUserMBlogs(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>	mblogs, err := repo.ListUserMBlogs(userID)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> PublishNewBlog(c *gin.Context) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>	&lt;span style="font-weight:bold">if&lt;/span> err = repo.NewUserMBlog(userID, req.Content); err != &lt;span style="font-weight:bold">nil&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">// intrnal/repo/micro_blogs_repo.go
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>&lt;span style="font-weight:bold">func&lt;/span> ListUserMBlogs(userID &lt;span style="">int&lt;/span>) ([]*dbModel.MicroBlog, &lt;span style="">error&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>	err := db.Model(dbModel.MicroBlog{}).Where(&lt;span style="font-style:italic">&amp;#34;user_id = ?&amp;#34;&lt;/span>, userID).Scan(&amp;amp;mblogs).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> NewUserMBlog(userID &lt;span style="">int&lt;/span>, content &lt;span style="">string&lt;/span>) &lt;span style="">error&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="font-style:italic">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>	&lt;span style="font-weight:bold">return&lt;/span> db.Create(&amp;amp;mblog).Error
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在这个版本的实现中，Web 接口 &lt;code>/users/:user_id/blogs&lt;/code> 依赖了 &lt;code>service.ListUserMBlogs&lt;/code> 的实现，而其又直接依赖了 &lt;code>repo.ListUserMBlogs&lt;/code> 函数，而后者又依赖了 &lt;code>db&lt;/code>，也就是 &lt;code>gorm.DB&lt;/code> 对象指针，亦即数据库连接。假如我们需要为 &lt;code>service.ListUserMBlogs&lt;/code> 编写单元测试，用于验证几类显而易见的测试场景：&lt;/p></description></item><item><title>MySQL + go 如何安全处理 decimal 类型数据</title><link>https://blog.hackerpie.com/posts/mysql/handle-decimal-fields/</link><pubDate>Wed, 02 Mar 2022 18:31:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/mysql/handle-decimal-fields/</guid><description>&lt;p>在电商或者金融相关的场景中，商品价格等数据都会涉及到小数的表示或者计算，如果使用编程语言内置的浮点数类型，会有精度丢失的风险。在应用领域，&lt;code>decimal&lt;/code> 类型应运而生，MySQL 数据库中内置支持 &lt;code>decimal&lt;/code> 数据类型，而程序设计上，一般编程语言都会有标准库或者第三方库对 &lt;code>decimal&lt;/code> 类型提供实现。本文快速展示下如何实现全链路对 &lt;code>decimal&lt;/code> 类型数据的读取处理，而不用担心会丢失数据的精度。&lt;/p>
&lt;h2 id="数据库层---mysql">数据库层 - MySQL&lt;/h2>
&lt;p>在 MySQL 层，&lt;code>decimal&lt;/code> 类型的值使用二进制表示，其大致转换过程是：&lt;/p>
&lt;ol>
&lt;li>将待存储的数据按照整数和小数部分一分为二，比如 &lt;code>1234567890.1234&lt;/code>，分为 &lt;code>1234567890&lt;/code> 和 &lt;code>1234&lt;/code>；&lt;/li>
&lt;li>针对整数部分，从低位到高位，按照每 9 位数字为一组，进行分割，比如 &lt;code>1234567890&lt;/code> 将分为 &lt;code>1&lt;/code> 和 &lt;code>234567890&lt;/code>；&lt;/li>
&lt;li>使用最短字节序列分别表示每个分组的整数，上面的 &lt;code>1&lt;/code> 即 &lt;code>0b00000001&lt;/code>，而 &lt;code>234567890&lt;/code> 则对应 &lt;code>0x0D-FB-38-D2&lt;/code>；&lt;/li>
&lt;li>对于小数部分，使用类似的分组（从高位到低位）处理方式，即 1234 表示为 &lt;code>0x04D2&lt;/code>；&lt;/li>
&lt;li>最后，将最高位置反，得到 &lt;code>0x81 0D FB 38 D2 04 D2&lt;/code>，也就是使用了 7 个字节来表示这个数字。&lt;/li>
&lt;/ol>
&lt;p>Bonus: 如果是小数，比如 &lt;code>-1234567890.1234&lt;/code>，则只需要将上面第 5 步的所有位置反即可，也就是 &lt;code>0x7E F2 04 C7 2D FB 2D&lt;/code>&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>MySQL 通过设计巧妙的可变长度的二进制转换，实现了对严格要求精度的小数的表示。&lt;/p>
&lt;h2 id="网络传输层---mysql">网络传输层 - MySQL&lt;/h2>
&lt;p>存储在 MySQL 底层存储上的 decimal，我们知道是二进制了之后，也就对精度问题的持久化存储放心了，但是，又带来两个问题：&lt;/p></description></item><item><title>当反射 map[string]interface{} 遇上 MapIndex 方法，返回值的 Kind 不是具体类型？</title><link>https://blog.hackerpie.com/posts/reflect/why-reflect-map-index-function-returns-interface/</link><pubDate>Sat, 19 Feb 2022 15:38:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/reflect/why-reflect-map-index-function-returns-interface/</guid><description>&lt;h2 id="什么是反射">什么是反射？&lt;/h2>
&lt;p>反射是一种在运行时用于探测甚至修改内存数据以及程序行为的机制，在 go 语言中通过 &lt;code>reflect&lt;/code> 包实现。直白来说，利用反射，我们可以实现包括但不限于的以下这些场景：&lt;/p>
&lt;ul>
&lt;li>数据的反序列化，比如 json、yaml 等格式数据从纯文本到内存数据结构的反序列化过程&lt;/li>
&lt;li>动态修改内存中的数据，比如创建新的字典数据、修改结构体的字段的值等&lt;/li>
&lt;li>动态调用对象的某个方法或者包里的某个函数等&lt;/li>
&lt;li>检查数据的类型以及对象的方法列表等&lt;/li>
&lt;/ul>
&lt;h2 id="所以这次想说什么问题呢">所以，这次想说什么问题呢？&lt;/h2>
&lt;p>今天想分享的，是我前几天在一个使用 golang 反射功能对 map[string]interface{} 类型的数据做处理的过程中，遇到的一个反直觉的问题。下面是相关代码片断示例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>myData := &lt;span style="font-weight:bold">map&lt;/span>[&lt;span style="">string&lt;/span>]&lt;span style="font-weight:bold">interface&lt;/span>{}{}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>json.Unmarshal(&lt;span style="font-style:italic">&amp;#34;{\&amp;#34;name\&amp;#34;: \&amp;#34;martin\&amp;#34;, \&amp;#34;score\&amp;#34;: 99}&amp;#34;&lt;/span>, &amp;amp;myData)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>HandleData(myData) &lt;span style="font-style:italic">// 进行数据的处理过程
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">func&lt;/span> HandleData(data &lt;span style="font-weight:bold">interface&lt;/span>{}) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> value := reflect.ValueOf(data)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> keyValue := value.MapIndex(reflect.ValueOf(&lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>)) &lt;span style="font-style:italic">// 从数据中取对应键 name 的值，应该为 &amp;#34;martin&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-weight:bold">switch&lt;/span> keyValue.Kind() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">case&lt;/span> reflect.String:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> doSth()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他 case，但是都没有包含 reflect.Interface 的匹配
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">// ... 其他后续代码
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在编写上面的代码的过程中，我期待程序会进入 &lt;code>case reflect.String:&lt;/code> 的逻辑分支进行处理，但是事实上，并没有。在网上搜索了一番之后，StackOverflow 上的这个&lt;a href="https://stackoverflow.com/questions/14142667/reflect-value-mapindex-returns-a-value-different-from-reflect-valueof">问答&lt;/a>给出了可以奏效的方法：&lt;/p></description></item><item><title>Prefix or Suffix oh-my-zsh's shell prompt</title><link>https://blog.hackerpie.com/posts/skills/prefix-or-suffix-zsh-prompt/</link><pubDate>Wed, 16 Feb 2022 23:30:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/prefix-or-suffix-zsh-prompt/</guid><description>&lt;p>Almost every developer loves his/her cool and colorful shell, so I install &lt;a href="https://ohmyz.sh/">oh-my-zsh&lt;/a> on my laptops and remote servers. However, as I use similar themes of oh-my-zsh and I also have the exactly same user name, most time I could not distinguish the actual machine on which I was operating.&lt;/p>
&lt;p>I tried to search online about how to decorate the zsh prompt so that I can insert a machine label within it. Unfortunetely, all articles which I could find specified that it has to overwrite the &lt;code>PS1&lt;/code> or &lt;code>PROMPT&lt;/code> environment variable in the &lt;code>~/.zshrc&lt;/code> file. These kinds of solutions will nail the prompt even though users change their zsh theme in the future.&lt;/p></description></item><item><title>瞎聊：避免手握锤子看啥都是钉子</title><link>https://blog.hackerpie.com/posts/tittle-tattle/something-learned-from-techparty-blog-migration/</link><pubDate>Wed, 12 Jan 2022 11:24:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/tittle-tattle/something-learned-from-techparty-blog-migration/</guid><description>&lt;p>前两天在给 &lt;a href="http://techparty.org/">TechParty&lt;/a> 设计和制作新的官网，选型了&lt;a href="http://www.sxl.cn/">上线了&lt;/a>作为网站设计和托管的平台。最后的一个大活就是如何将 TechParty 原来的 218 篇博客文章迁移到新的官网上，一站式管理。比较遗憾的是，上线了的博客系统并没有提供编程接口用于迁移已有博客，所以唯一的方式就是自行想办法将所有文章逐一拷贝到他们的富文本编辑器中。&lt;/p>
&lt;p>TechParty 旧的博客系统是用的 Jekyll，一种主要使用 markdown 作为协作语言的静态博客站点生成工具，而上线了只支持富文本编辑器，也不支持 markdown，所以大体思路就是直接拷贝 Jekyll 生成好的 TechParty 博客的网页内容到上线了的编辑器中。但是问题是，这里面可是有 218 篇文章呢！不是一个小的工作量，所以作为程序员，第一反应就是尝试能不能将这个过程自动化？&lt;/p>
&lt;h3 id="尝试-python--selenium">尝试 python + selenium&lt;/h3>
&lt;p>第一个尝试的方案就是基于 Python + Selenium 的方式来实现整个过程的自动化。整个方案花了一下午大概4个小时的时间，包括解决 pip 依赖安装的问题、如何模拟鼠标长按选中博客文章正文的操作、如何模拟复制、如何模拟人工在上线了编辑器里点击和编辑等，最终整个方案因为无法完美模拟人工点击上线了的各个编辑框（为了进入编辑态，非编辑态时，页面上的各个控件显示为普通的文本）而失败……&lt;/p>
&lt;h3 id="人肉复制粘贴">人肉复制粘贴&lt;/h3>
&lt;p>第二天早上，痛定思痛，觉得自动化的路子虽然看起来比较聪明，但是实际上还有一些缺点或者未知问题：&lt;/p>
&lt;ul>
&lt;li>可复用性低：因为这种从 Jekyll 博客到上线了博客迁移的需求显然对我自己是一次性的任务，而对于别人可能压根没有什么需求&lt;/li>
&lt;li>未知的异常处理：哪怕我解决了交互模拟的问题，我还是无法预知脚本后续自动执行的过程中还会不会有其他问题需要解决，尽管脚本自动化很酷，但是干过的人都知道，它不是一劳永逸的事情，往往你还是需要人盯着，以备随时介入处理突发的情况，而且一旦修复完问题，你还需要脚本到底是从头再来，还是断点作业，问题只多不少，无穷无尽……&lt;/li>
&lt;/ul>
&lt;p>在决定是否改用人工方式之前，我算了道简单的数学题：&lt;/p>
&lt;ul>
&lt;li>迁移一篇文章的主要操作是：打开原文链接 -&amp;gt; 复制原文标题 -&amp;gt; 在上线了新建一篇博客 -&amp;gt; 粘贴标题 -&amp;gt; 回到原文复制原文发布时间 -&amp;gt; 粘贴到上线了的文章中 -&amp;gt; 复制原文正文 -&amp;gt; 粘贴到上线了的编辑器中 -&amp;gt; 点击上线了的“上线”按钮。如此往复就可以把所有文章都复制完。&lt;/li>
&lt;li>以上一篇文章的复制操作，我大致觉得 60 秒绝对足够了，事实上对于熟练操作之后应该不需要这么长的时间&lt;/li>
&lt;li>所以理论上复制所有文章需要的时间是： &lt;code>218 x 60 = 13080 秒 = 218 分钟 = 3 小时 38 分钟&lt;/code>&lt;/li>
&lt;li>而更加合理一点的是按照每个文章 30 秒，那总体的时间就是减半的，也就是 &lt;code>1 小时 49 分钟&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>很有意思，当我想的是我需要完成 &lt;code>218&lt;/code> 篇文章的搬迁的时候，我主观上觉得这是一个人肉操作难以短时间内完成的任务，至少可能要一整天都在干这个事情，除非用程序来自动完成。但是通过分解和评估，事实上不管是3个多小时还是2个小时，我都觉得这时间是要比写代码和调试程序的时间短的，而且结果可控的多：我很确定这是一个纯粹的时间问题，只要无脑操作，一定时间后，这个事情一定会完成，不用担心过程还有没有大的问题。&lt;/p></description></item><item><title>我的刻意练习——双拼输入</title><link>https://blog.hackerpie.com/posts/skills/double-input-method/</link><pubDate>Thu, 23 Dec 2021 14:38:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/skills/double-input-method/</guid><description>&lt;p>作为一个程序员，每天都需要和键盘打交道，自然少不了打字这个事情，以前就知道有五笔输入法，但是也听说练习起来很难，加上拼音输入法很简便，自然就使用的拼音输入法。但是久了之后，总是觉得全拼输入法太死板了，有没有不需要逐个打入每个拼音字母就可以快速打出需要的字的输入法的呢？答案是有的：双拼输入法，是的，就是我在写这篇文章时所使用的输入法。当然，我现在的打字速度就跟乌龟爬行一样慢……&lt;/p>
&lt;h2 id="什么是双拼输入法呢">什么是双拼输入法呢？&lt;/h2>
&lt;p>与全拼输入法需要挨个输入拼音字母不同的是，双拼是将汉语拼音中的所有声母和韵母都映射到键盘上，所以打字的时候，我们的思维转回自然的拼音规律：声母+韵母，非常简单直观。换句话说，对于每个汉字，固定只需要 2 次敲击键盘就可以了，比起全拼自然是会更高效的，只是刚开始从全拼切换过来确实很痛苦，我自己也是在刻意练习中。比如“双拼输入法”这五个字，对应的拼音就是：&lt;/p>
&lt;pre tabindex="0">&lt;code>shuang pin shu ru fa
&lt;/code>&lt;/pre>&lt;p>按照声母和韵母分开的话，就是：&lt;/p>
&lt;pre tabindex="0">&lt;code>sh uang
p in
sh u
r u
f a
&lt;/code>&lt;/pre>&lt;p>以小鹤双拼来讲，对应的键盘输入顺序就是：&lt;code>u&lt;/code>、&lt;code>l&lt;/code>、&lt;code>p&lt;/code>、&lt;code>b&lt;/code>、&lt;code>u&lt;/code>、&lt;code>u&lt;/code>、&lt;code>r&lt;/code>、&lt;code>u&lt;/code>、&lt;code>f&lt;/code>、&lt;code>a&lt;/code>。&lt;/p>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/posts/typewriting/double_input_method_example.png" alt="">
&lt;/p>
&lt;p>所以双拼输入法的原理极其简单，但是练习起来还是有一些痛苦的。&lt;/p>
&lt;h2 id="个人练习的心得体会">个人练习的心得体会&lt;/h2>
&lt;h3 id="第一周">第一周&lt;/h3>
&lt;p>第一周的打字速度跟龟速一样，基本上是打每个字都得停顿一下提前想下接下来每个字的拼音以及对应的码键。这期间，我可以把我的电脑和手机的输入法都改为双拼，使用的小鹤双拼，虽然打字速度慢得叫人别扭，但是还是可以勉强忍受的。&lt;/p>
&lt;h3 id="第二周">第二周&lt;/h3>
&lt;p>经过第一周的刻意练习后，基本上就能记住每个双拼码的键位了，所以打字速度有一定程度的提升，这个阶段的最大问题就是经常不自觉就按照全拼的输入法来打字了，比如想要打“成”字，一打得快了，就是先打了“c”，实际上应该是“i”。又或者是“就”这个字，应该是“jq”，但是总是一顺手就打成了“ji”，哪怕现在已经是第三周了，也是如此。除了输入习惯的错误，另一个错误就是没有选对字，因为打字的时候注意力都在思考键位和纠正输入的键上，所以总是不自觉刚把拼音打完，就直接空格了，结果很可能选到的词是错误的。&lt;/p>
&lt;h3 id="第三周此刻是2022-01-12的上午">第三周（此刻是2022-01-12的上午）&lt;/h3>
&lt;p>第三周会和第二周差不多，会稍微更注意候选词的问题，但是仍旧没有彻底改掉全拼遗留的输入习惯，容易一快了就敲错键，所以大部分时候的打字都还是需要在退格和重新输入中往复。不过好的一点是，打字速度还是有一些提升的，一些常用字可以很快甚至肌肉记忆般敲出来了，整体顺利和流畅的话，也能感受到双拼带给人的节奏感，期待未来某一天能够靠着双拼输入法一“写”千里。&lt;/p>
&lt;h2 id="感悟">感悟&lt;/h2>
&lt;ul>
&lt;li>刻意练习，就是决心把自己丢进不适应的状态中，并且尝试在&lt;strong>不改变环境&lt;/strong>的前提下努力改变状态，比如我一开始就故意将自己的所有设备的输入法都改为双拼，后来跟别人聊天的时候，发现自己打字好慢，还特别多错字，特别着急，但是这个时候我也没有去临时改回全拼，而是坚持继续用双拼，慢慢就发现打字速度还是能提升，也就再也没有必要考虑改回双拼输入了。想起以前我纠正自己打字时候的指法也是一样的道理。&lt;/li>
&lt;/ul>
&lt;h2 id="好看的码表图">好看的码表图&lt;/h2>
&lt;p>以下图片是我从知乎讨论区（文末附了链接）看到的一个图片，我觉得比较好看，就拿来当壁纸了，以备对双拼码表不熟悉的时候可以直接回到桌面看看，但是实际上也基本没有用上，分享给有需要的同学。


 &lt;img src="https://blog.hackerpie.com/images/posts/typewriting/xiaohe_shuangpin_keyboard.jpeg" alt="">
&lt;/p>
&lt;h2 id="学习资料">学习资料&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://www.zhihu.com/question/20698750">知乎：怎样记忆双拼输入法的回答&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Unicode？UTF-8？GBK？……聊聊字符集和字符编码格式</title><link>https://blog.hackerpie.com/posts/text-processing/character-sets-and-encoding-formats/</link><pubDate>Sun, 12 Dec 2021 18:25:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/text-processing/character-sets-and-encoding-formats/</guid><description>&lt;h2 id="按照习惯起个调">按照习惯起个调&lt;/h2>
&lt;p>作为程序员，经常会在编程语言、操作系统、网络以及文本编辑等多个层面遇上字符集或者字符编码的问题，尽管一般都能快速通过搜索引擎找到解决方案，但是对于这种字符集以及其相关的字符编码格式的知识，倒是未曾系统梳理。恰逢近期有了一些收获，趁热记录分享下。&lt;/p>
&lt;h2 id="从-unicode-和-utf-8-说起">从 Unicode 和 UTF-8 说起&lt;/h2>
&lt;p>对于类 Unix 操作系统（比如 Mac OS 以及 Linux 操作系统等）的用户来说，会更多地接触 UTF-8 编码格式，我也是其中一个。而我过往总是容易跟另一个词—— Unicode 混淆，所以，当我们在讨论 UTF-8 和 Unicode 的时候，我们在讨论什么？&lt;/p>
&lt;h3 id="unicode-字符集简介">Unicode 字符集简介&lt;/h3>
&lt;p>当我们说 Unicode 的时候，是在讨论一种字符集（character set）。Unicode 翻译成中文叫“统一码”，是一种可以简单理解为收录了世界上所有语言的文字和符号的全球标准。大家知道，英语的基本组成元素是 26 个英文字母加上各种标点符号；而汉语的文字则相对繁杂，大量汉字，每个文字都有各自的拼音，拼音里还要区分音调，这里提到的汉字、拼音、音调以及汉字自身的标点符号，跟英语的英文字母以及标点符号等，统统收录在了 Unicode 字符集中，而类似的，还有繁体中文、日文、韩文、俄罗斯语、越南语、泰语、蒙古语等等。&lt;/p>
&lt;p>收录了这么多的字符，就会带来一个问题：怎么整理和编排记录这些内容呢？编号！类比在一些常见的场景中，当一个集体中包含很多的个体时，为了用一种统一且简单的方式区分，我们最容易想到的就是编号。比如，给班里的同学安排座位号，给学生安排学号，给员工安排工号，等等。&lt;/p>
&lt;p>但是，计算机是不能直接理解十进制这种人类易于理解的数字的，它只能理解二进制的数值，所以，在计算机里，我们可以用编码（使用特定的二进制序列来表示一个特定的值）的方式来给这些字符和符号进行一一映射。目前 Unicode 实际应用版本 UCS-2 在计算机中使用了 2 个字节来编码一个字符，也就是 16 位的编码空间，在表示上，采用类如 &lt;code>U+????&lt;/code> 的形式，其中每个“?”都是一个十六进制数。注意，Unicode 还有个 4 字节编码版本，亦即 UCS-4，不在这里讨论。&lt;/p>
&lt;p>以下是一些示例的 Unicode 字符及其对应编码：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>字符&lt;/th>
 &lt;th>编码值&lt;/th>
 &lt;th>说明&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>牛&lt;/td>
 &lt;td>U+725B&lt;/td>
 &lt;td>汉字&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>ù&lt;/td>
 &lt;td>U+00F9&lt;/td>
 &lt;td>拼音 u 的四声&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>,&lt;/td>
 &lt;td>U+002C&lt;/td>
 &lt;td>英文逗号&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>，&lt;/td>
 &lt;td>U+FF0C&lt;/td>
 &lt;td>中文逗号&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>😁&lt;/td>
 &lt;td>U+D83D&lt;/td>
 &lt;td>emoji 表情：笑脸&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>⚔&lt;/td>
 &lt;td>U+2694&lt;/td>
 &lt;td>emoji 表情：剑&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>是不是挺有意思的？另外是否也注意到，同样是逗号，但是英文的逗号和中文的逗号，并不是同一个符号，哪怕看起来非常相似！相信很多初学编程的同学也都踩过在代码中输入了中文逗号导致代码编译出错的坑吧！&lt;/p></description></item><item><title>Kafka 核心设计思考——来自官方文档的总结</title><link>https://blog.hackerpie.com/posts/kafka/kakfa-main-design/</link><pubDate>Thu, 09 Dec 2021 10:16:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/kafka/kakfa-main-design/</guid><description>&lt;h2 id="前言">前言&lt;/h2>
&lt;p>最近在学习 Kafka 的一些设计原理，偶然间发现 Kafka 官方文档中独列了 &lt;a href="https://kafka.apache.org/documentation/#design">Design&lt;/a> 一章。两天看完后觉得很兴奋，因为文档中很详细地从各方面阐述了 Kafka 官方对于 Kafka 设计的目标以及设计权衡等，让我恍然大悟 Kafka 的独特与简洁。这种快乐是阅读网上各种零散的博客文章无法比拟的。我此处总结更多是为了提升自己的领悟和理解程度，行文之中会夹杂个人主观理解，我建议大家抽出时间阅读原汁原味的&lt;a href="https://kafka.apache.org/documentation/#design">官方文档&lt;/a>。&lt;/p>
&lt;h2 id="kafka-设计目标与设计概述">Kafka 设计目标与设计概述&lt;/h2>
&lt;p>设计一个系统，精准的目标是第一步。Kafka 官方在最开始的时候，对 Kafka 的设计理想是将其做成一个可以帮助大型公司应对各种可能的实时数据流处理的通用平台。这句话里边有几个重点：“大型公司”、“实时”、“通用”，对应到系统设计上，就是需要支持大量数据的低延迟处理，并且需要考虑各种不同的数据处理场景。在官方阐述中，Kafka 着眼于以下几个核心指标：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>高吞吐量&lt;/strong>：因为 Kafka 需要处理大量的消息；&lt;/li>
&lt;li>&lt;strong>低延迟&lt;/strong>：消息系统的关键设计指标；&lt;/li>
&lt;li>&lt;strong>支持加载离线数据&lt;/strong>：这是 Kafka 考虑的所谓“各种可能的”数据处理场景，支持从离线系统中加载数据，或者将数据加载到离线系统中，都是无法逃避的；&lt;/li>
&lt;li>&lt;strong>支持分区的、分布式的、实时的数据流处理以产生新的、派生的数据流&lt;/strong>：这个指导了 Kafka 里 topic 分区模型以及消费者模型的设计；&lt;/li>
&lt;li>&lt;strong>容错与可靠性&lt;/strong>：Kafka 作为消息中间件，核心场景之一就是作为系统间的连接器，需要保证整体业务的正常运作，可靠的消息投递机制以及应对节点故障的高可用设计等，必不可少。&lt;/li>
&lt;/ul>
&lt;p>理解了 Kafka 的设计目标以及核心指标，后续对 Kafka 的整体架构设计就会有一个方向了，因为 Kafka 的整体设计细节还算比较多，但是归根结底都是围绕这几个核心指标去做的设计，我尝试分门别类先汇总一下，可能不是很准确，希望请大家看的时候顺便赐教：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>核心指标&lt;/th>
 &lt;th>实现的角度&lt;/th>
 &lt;th>具体设计手段&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>高吞吐量&lt;/td>
 &lt;td>读写缓存&lt;/td>
 &lt;td>依赖文件系统自身的 Page Cache，而不是自己实现内存缓存&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>高吞吐量&lt;/td>
 &lt;td>高效的数据结构&lt;/td>
 &lt;td>采用顺序读写的结构，而不是 B 树等&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>高吞吐量&lt;/td>
 &lt;td>降低大量小的 I/O&lt;/td>
 &lt;td>消息分批发布，按批投递&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>高吞吐量&lt;/td>
 &lt;td>提高消息投递吞吐量&lt;/td>
 &lt;td>由消费者批量拉取&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>高吞吐量&lt;/td>
 &lt;td>支持分批消息&lt;/td>
 &lt;td>支持异步发送消息&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>低延迟&lt;/td>
 &lt;td>避免昂贵的字节拷贝&lt;/td>
 &lt;td>统一的消息格式，零拷贝技术&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>低延迟&lt;/td>
 &lt;td>优化传输性能&lt;/td>
 &lt;td>通过批量消息压缩减小传输数据量&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>低延迟&lt;/td>
 &lt;td>提升读取性能&lt;/td>
 &lt;td>顺序读，日志文件分段存储，应用二分查找&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>低延迟&lt;/td>
 &lt;td>降低负载均衡延迟&lt;/td>
 &lt;td>producer 直连 broker&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>离线数据加载&lt;/td>
 &lt;td>支持周期性大量数据加载&lt;/td>
 &lt;td>依赖存储层顺序读写的常量时间复杂度的访问优势以及低廉的磁盘成本要求&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>离线数据处理&lt;/td>
 &lt;td>支持并行处理&lt;/td>
 &lt;td>通过分区设计以及 consumer 的 offset，支持 Hadoop 一类的并行作业以及断点作业&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>可靠性&lt;/td>
 &lt;td>支持“有且仅有一次”的消息投递语义&lt;/td>
 &lt;td>producer 的 ID 与消息 Sequence Number，类事务提交语义&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>可靠性&lt;/td>
 &lt;td>容错处理与高可用&lt;/td>
 &lt;td>ISR 机制与 Leader 均匀分布设计&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>除了上表所列内容，还有少量设计思考暂时不好归类，比如：&lt;/p></description></item><item><title>后缀表达式之逆波兰表示法</title><link>https://blog.hackerpie.com/posts/algorithms/queue-and-stack/reverse-polish-representation/</link><pubDate>Sun, 05 Dec 2021 20:56:28 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/queue-and-stack/reverse-polish-representation/</guid><description>&lt;h2 id="从中缀表达式说起">从中缀表达式说起&lt;/h2>
&lt;p>对于人类来说，中缀表达式是最直观自然的，比如“3+5x4”或者“(3+5)x4”，一般来说，对于中缀表达式，在程序中会用一个抽象语法树来表示表达式和求值，比如：&lt;/p>
&lt;pre tabindex="0">&lt;code> 3+5x4

 +
 / \
 / \
 3 x
 / \
 / \
 5 4
--------------------------------
 (3+5)x4

 x
 / \
 / \
 + 4
 / \
 / \
 3 5
&lt;/code>&lt;/pre>&lt;p>后续表达式求值使用二叉树的中序遍历便可。&lt;/p>
&lt;p>但是这种表达式对于计算机来说，会有2个可以考虑提升的问题：&lt;/p>
&lt;ul>
&lt;li>对于计算机不够直观，需要在树的结构上进行遍历和求值；&lt;/li>
&lt;li>额外的括号来用于明确运算优先级。&lt;/li>
&lt;/ul>
&lt;h2 id="后缀表达式">后缀表达式&lt;/h2>
&lt;p>后缀表达式，也叫&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">逆波兰表达式&lt;/a>，前述的表达式对应的后缀表达式为：&lt;/p>
&lt;ul>
&lt;li>&lt;code>3+5x4&lt;/code>：&lt;code>3 5 4 x +&lt;/code>&lt;/li>
&lt;li>&lt;code>(3+5)x4&lt;/code>：&lt;code>3 5 + 4 x&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>可以看出后缀表达式的特点：&lt;/p>
&lt;ul>
&lt;li>操作符在操作数的末尾，比如 &lt;code>5 x 4&lt;/code> 表示为 &lt;code>5 4 x&lt;/code>；&lt;/li>
&lt;li>无需括号表达优先级&lt;/li>
&lt;/ul>
&lt;p>从计算机的角度，后缀表达式还有以下特点：&lt;/p>
&lt;ul>
&lt;li>由于没有括号，可以节省内存&lt;/li>
&lt;li>可以基于栈结构实现后缀表达式的求值&lt;/li>
&lt;li>&lt;strong>如果对抽象语法树进行末序遍历，刚好可以得到逆波兰表达式，这点比较有意思&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="将中缀表达式转为后缀表达式">将中缀表达式转为后缀表达式&lt;/h3>
&lt;p>为了将中缀表达式转为后缀表达式，一般需要用到的是&lt;a href="https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95">调度场算法&lt;/a>，算法中需要用到一个输出队列和一个操作符栈，完整的算法细节比较多，这里简化为简单的四则运算（支持括号）来描述精简版算法，如果需要支持完整的运算符或者函数等，需要自行学习完整的调度场算法。&lt;/p>
&lt;p>以下用伪代码描述（&lt;strong>注意：&lt;/strong> 算法中的“单词符号”一词参考编译原理中的“token”一词，意思是一样的，我为了伪代码不会中英混杂，才写了中文名字，不一定精确）：&lt;/p>
&lt;pre tabindex="0">&lt;code>声明 Q：输出队列
声明 S：操作符栈

遍历中缀表达式中的每一个单词符号 x：
 如果 x 是一个操作数，直接将 x 追加到输出队列 Q 末尾，否则往下检查；
 如果 x 是一个左括号“(”，将 x 压入操作符栈 S 栈顶，否则往下检查；
 如果 x 是一个操作符：
 如果操作符栈 S 栈顶为一个优先级大于等于 x 的操作符，则将 S 栈顶的运算符弹出并且追加到输出队列 Q 末尾，最后将 x 压入栈顶；
 如果操作符栈 S 栈顶为一个优先级小于 x 的操作符，或者不为操作符（在这个简化算法里，只有可能是左括号），则直接将 x 压入栈顶即可。
 如果 x 是一个右括号“)”，则将操作符栈 S 栈顶到往下第一个左括号“(”之间的元素依次弹出并且追加到输出队列末尾，将“(”出栈丢弃，x 也不用入栈。注意：如果栈到底后仍没有找到左括号，则说明表达式不合法，左右括号不匹配。
最后将栈 S 中的元素全部依次弹出并且入队列 Q。
&lt;/code>&lt;/pre>&lt;h4 id="实例演示">实例演示&lt;/h4>
&lt;p>用一个稍微复杂的四则运算表达式来举例：&lt;code>(12+5)x(8-1)-6x6&lt;/code>。&lt;/p></description></item><item><title>技术面试如何“试”</title><link>https://blog.hackerpie.com/posts/2021/interview-thinking/</link><pubDate>Sun, 07 Nov 2021 13:03:10 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/interview-thinking/</guid><description>&lt;p>毕业7年了，经历过多家不同公司的面试，这些公司的面试方式不尽相同，给我的喜恶程度不一；反过来，自己作为面试官，前后也为公司筛选物色了不少候选人，我希望我所认可的人能在后续的工作表现中证明我没看错人。我时不时会想：在技术面试中，以怎样的方式对候选人进行评估筛选，才足够高效精准？不妨先从自己所经历过的面试形式聊起吧。&lt;/p>
&lt;h2 id="我所经历过的几类面试风格">我所经历过的几类面试风格&lt;/h2>
&lt;p>细想一路走来，我所经历过的面试风格大致分为几类：&lt;/p>
&lt;ol>
&lt;li>全凭一张嘴，双方直接聊&lt;/li>
&lt;li>家庭作业型&lt;/li>
&lt;li>理论知识问答&lt;/li>
&lt;li>算法能力考查&lt;/li>
&lt;/ol>
&lt;h3 id="全凭一张嘴双方直接聊">全凭一张嘴，双方直接聊&lt;/h3>
&lt;p>这种面试风格，存在于早期的互联网企业面试中，而据我了解，目前一些小公司也会采用这种方式。就我自己来说，15年我面试 4399 以及大疆的时候，均是采用的这种风格的面试。&lt;/p>
&lt;p>面试双方就简历上的项目展开讨论，了解候选人在项目中的具体工作和成果，以及候选人在编程素养等方面的水平。这种面试方式简单快速，但是有效与否，很大程度上依赖候选人的表达能力以及面试官自身经验能力水平以及对人才的判断能力。&lt;/p>
&lt;p>采用这种面试风格的公司，大抵是一些小型公司或者初创公司，因为这类公司一般相对难以吸引到拥有“优秀”背景的人才前来面试，除非事前双方都是知根知底的，于是公司必然会在人才招募上务实。如果本身吸引到的人才数量有限背景有限，公司自己还平添很多繁琐的面试环节或者提高通过门槛，最终可能一个人都招不到。所以，开门见山，直奔主题。&lt;/p>
&lt;h3 id="家庭作业型">家庭作业型&lt;/h3>
&lt;p>这种面试形式，是在简历通过筛选后，面试官给候选人发送一份家庭作业一样的项目需求，描述一个极小型项目的设计要求，然后让候选人自己在业余时间完成。之后的技术面试则一方面结合这个小项目进行实现思路以及架构设计交流，另一方面则通过过往项目经验了解候选人的能力水平。我在 15 年面试 ThoughtWorks 以及 20 年面试 crypto.com 公司的时候，都体验过这种面试形式，也是我个人最为喜欢的形式。而根据朋友的分享，我了解到 AWS 中国也是采用的此类面试形式。&lt;/p>
&lt;p>我之所以喜欢这种面试风格，主要是因为方式灵活以及代码更容易让技术面试双方建立共同语言。灵活性方面，它给我自己发挥的空间最大，比如我想向面试官展现我的开发习惯，比如单元测试和代码注释等，那我就会在这种作业型项目上用心完善单测和注释。其次我也会注意文档的编写和注释，特别是一份帮助面试官方便快速运行你的代码的 README 文档。这些，都不需要像其他面试一样临场发挥，我只需要思考如何准备得更好就行了。另一方面，代码是技术人之间的共同语言，这种方式拉近了我和面试官之间的距离。比如我在去年面试 crypto.com 的过程中，我在交完作业到开始正式面试中间的这段时间里，我和 crypto.com 的面试官在微信上就已经开始就代码问题进行了多次讨论。在这种非正式的交流过程中，我得以一种比较轻松自在的方式去表达我的思考，而面试官也在此过程中向我展示了他自身的技术水平，这种方式让我感觉就是在进行如常的技术交流而已，仿佛是在一个同事或者同行一起探讨而已。&lt;/p>
&lt;p>尽管我自己喜欢这种面试风格，但是身边还是会有朋友或者同事并不认同这种方式，甚至觉得恶心。主要原因有两种，一是这种方式会更多地占用候选人的业余时间，二是这种方式可能会存在候选人作弊，由他人代为完成了作业。只不过我真觉得这两对我而言都不是问题。假如我需要追求一个未来3-5年适合我的公司，我觉得充分的准备以完整展现自己，是值得投入时间的。而第二个问题，我觉得配合面试流程中对作业中的实现细节以及架构思路等进行讨论，是可以快速判断这个代码是不是候选人自己独立完成的。&lt;/p>
&lt;h3 id="理论知识问答">理论知识问答&lt;/h3>
&lt;p>这种就是大家常说的“八股文”了，就是面试官按照题库给出数据结构、数据库、计算机网络以及编程语言等等科目相关的基础知识问题，由候选人做出正确的回答。大家常吐槽的题目比如红黑树的原理、MySQL innoDB 存储引擎的索引设计、TCP 三次握手/四次挥手以及 Golang 语言的 goroutine 调度原理等等。而由于这种面试环节中的题目过于基础和客观，导致候选人不得不在面试之前花费大量的时间和精力进行复习，但是入职后在工作岗位上却由于没有实践机会后快速遗忘，留下了“面试造火箭，日常拧螺丝”的调侃。&lt;/p>
&lt;p>至于采用这种面试风格的公司，皆是各类校招社招人才热捧的大公司，比如国内的 BAT，美团字节以及 Shopee 等等。这些公司所提供的薪资水平在业界出于中上甚至天花板水平，自然每年都能够吸引到大量优秀人才前往应聘。&lt;/p>
&lt;p>我自己在去年面试腾讯和字节的经历中，一路摸爬滚打，每天起早摸黑复习基础知识，或者是根据面试过程中暴露的薄弱知识点进行强化复习，最终才终于通过这些公司的技术基础关。&lt;/p>
&lt;p>尽管我并不喜欢这种方式，但是在 Shopee 公司担任面试官的时候，按照部门统一面试要求，我还是不得不机械地从题库中挑选各个知识点的题目，逐一向候选人提问。在一个半小时的时间里，我需要按序完成对候选人项目经验、编程语言基础、数据结构、计算机网络、数据库理论、操作系统原理、网络安全的理论知识考查，另外还包含一道中等难度的编程题，因为面试评估采用各环节得分累加的形式，我无法跳过其中某一部分。我仅有的发挥空间，大概就是面试开场的项目经验交流以及对候选人的回答决定是否追问了。&lt;/p>
&lt;p>这种面试形式，更像是一种应试考核，尽管不够个性化，但是却仍然不失为一种筛选人才的方式。因为本身这类热门公司就能够吸引到超级多优秀人才，在简历筛选环节留下来的人选，绝大部分人基础都不会太差，基本素养也不至于太糟糕，而大公司在实现一种盈利机制的稳定之后，并不需要太多领军型人才，更多是需要一些踏实勤奋的人去保证这套机制的运作如常，甚至允许部分蛀虫的存在。在这种背景下，大公司的面试筛选机制便可以相对简单粗暴，公司只需要确保挑选出来的人在某个角度客观上比其他人突出即可。古代科举考试以及现代高考或者公务员考试制度，大致如此，虽说无法挖掘人的特长或者个性，但是确实公平。&lt;/p>
&lt;h3 id="算法能力考查">算法能力考查&lt;/h3>
&lt;p>除开上面几种类型，我遇到的这种类型特点是面试绝不寒暄，也不多聊理论，简单自我介绍后，面试官直接给出算法题目，要求直接完成算法题实现。去年在 flexport 公司就是这种面试形式，当然，我没有通过。而众所周知，谷歌、微软、字节跳动、pony.ai 等公司都是比较重视算法能力的，如果候选人想要追求这类公司的岗位机会，算法能力太差是注定不行的。而今年在和一个海归的朋友聊的时候，他也聊到美企普遍重视算法能力，所以面试多是简单粗暴的多道算法题。这就让人忍不住又得提一下 Homebrew 作者 Max Howell 因为没有完成翻转二叉树的算法题而没有通过谷歌面试的故事。&lt;/p>
&lt;p>尽管好的算法对于软件设计来说确实可以降本增效，但是对于大部分工程师来说，更多时候他们需要完成的是如何通过技术方案的组合来给出一个商业产品的解决方案。这也让我想起18年底的时候，一个刚入职微软半年左右的朋友，通过猎头找到我，希望跟我了解 Shopee 的工作情况，他正在考虑跳槽 Shopee。因为他觉得入职微软之后大失所望，尽管他准备微软的面试上花了很大力气，微软在他的想象里，一直是个高效专业的公司，但是实际他当时所在的团队所维护的代码，实在难以恭维，而且很多所学毫无用武之地。&lt;/p>
&lt;h3 id="小结">小结&lt;/h3>
&lt;p>这里我们先汇总对比下几种面试风格：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>形式&lt;/th>
 &lt;th>形式简述&lt;/th>
 &lt;th>举例公司&lt;/th>
 &lt;th>好处&lt;/th>
 &lt;th>不足&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>纯口头交流&lt;/td>
 &lt;td>全程口头沟通，交流技术想法等&lt;/td>
 &lt;td>早期的大疆、4399&lt;/td>
 &lt;td>简单快速，成本低&lt;/td>
 &lt;td>重度依赖候选人表达能力以及面试官慧眼识人能力&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>家庭作业型&lt;/td>
 &lt;td>面试前完成作业，面试中交流作业实现思路等&lt;/td>
 &lt;td>thoughtworks、crypto.com、AWS&lt;/td>
 &lt;td>给候选人更多发挥空间，能更真实考查候选人的编码习惯和规范等&lt;/td>
 &lt;td>加大业余时间成本，需要避免候选人作弊，难以通过作业考查复杂架构能力&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>理论知识问答&lt;/td>
 &lt;td>结构化面试，一问一答，客观问题作答&lt;/td>
 &lt;td>腾讯、字节跳动&lt;/td>
 &lt;td>简单粗暴、相对公平&lt;/td>
 &lt;td>相对死板，可能错过高潜人才&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>算法能力考查&lt;/td>
 &lt;td>直接完成算法编写，每轮面试以编写算法代码为主&lt;/td>
 &lt;td>微软、flexport&lt;/td>
 &lt;td>相对公平&lt;/td>
 &lt;td>相对死板，可能错过高潜人才&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="面试方式与体验">面试方式与体验&lt;/h2>
&lt;p>这里想插入说一声的是，面试是公司形象宣传的第一站，好的面试体验带给候选人好的印象，甚至可以成为口碑传播的基础，所以对于面试形式的选择，除了效率，还要考虑候选人的体验。就我自己而言，由于我非常喜欢家庭作业型的面试风格，我个人也感觉在这类面试中，我的表现是最好的。尽管由于客观原因，我都没有去成这些公司，但是我至今仍对这些公司存有好感，以至于在面试后的很长一段时间，我都会持续地向身边找工作的朋友安利这类公司。我的逻辑很简单：能给候选人发挥空间的公司，相信在公司内部，文化也会相对更开放。所以，如果你是20年底到现在找我推荐公司的朋友，很大概率都会听我提到 crypto.com。&lt;/p></description></item><item><title>部分应用与柯理化</title><link>https://blog.hackerpie.com/posts/programming-paradigm/partial-application-and-currying/</link><pubDate>Sun, 15 Aug 2021 21:18:18 +0800</pubDate><guid>https://blog.hackerpie.com/posts/programming-paradigm/partial-application-and-currying/</guid><description>&lt;p>在最近学习函数式编程的过程中，反复接触到的就是“柯理化”这个概念，特别数学范有没有？虽然看过多次，但是一直不是很好地理解它，恰逢今天在阅读《Scala 函数式编程》这本书的过程中加深了理解，便写个文章，总结一下。&lt;/p>
&lt;h2 id="柯理化">柯理化&lt;/h2>
&lt;p>柯理化，英文叫“Currying”，命名源自逻辑学家 Haskell Curry 的名字。在数学和编程领域，&lt;strong>柯理化&lt;/strong>用于将一个接收多个参数的函数转换为一系列只接收单个输入参数的函数。比如，将一个接收三个参数的函数 &lt;code>f&lt;/code> 进行柯理化，会得到三个新的函数：&lt;/p>
&lt;pre tabindex="0">&lt;code>x = f(a, b, c) 变为：
 h = g(a)
 i = h(b)
 x = i(c)
或者使用匿名函数按序调用的形式，则为：
 x = g(a)(b)(c)
&lt;/code>&lt;/pre>&lt;p>这样讲或许仍有点不好理解，我们用个数学函数的例子来分解。假如我们有函数 &lt;code>f(a, b, c) = a² + b - c&lt;/code>，并且有 &lt;code>a = 2&lt;/code>、&lt;code>b = 3&lt;/code>、&lt;code>c = 1&lt;/code>，则一般数学求解过程中，我们可以直接将 a、b、c 的值对应代入函数右侧式子，得到 &lt;code>2² + 3 - 1 = 6&lt;/code>，于是我们知道 &lt;code>f(2, 3, 1) = 6&lt;/code>。这个过程很直观很好理解，也很亲切对不对？&lt;/p>
&lt;p>但是，假如我们要求每次只能代入函数的一个输入值，会是怎样的过程呢？&lt;/p>
&lt;ul>
&lt;li>第一步，我们代入 &lt;code>a = 2&lt;/code>，我们将得到 &lt;code>f(2, b, c) = 2² + b - c&lt;/code>，我们可以记 &lt;code>g(b, c) = f(2, b, c) = 4 + b - c&lt;/code>；&lt;/li>
&lt;li>第二步，我们代入 &lt;code>b = 3&lt;/code>，我们得到 &lt;code>g(3, c) = 4 + 3 - c&lt;/code>，我们可以记 &lt;code>h(c) = g(3, c) = 7 - c&lt;/code>；&lt;/li>
&lt;li>最后一步，我们代入 &lt;code>c = 1&lt;/code>，我们得到 &lt;code>h(1) = 7 - 1 = 6&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>上述的过程，向我们展示了我们是如何通过每次代入一个输入值而得到一个输入值数量减 1 的新函数。&lt;/p></description></item><item><title>数据结构：单调栈</title><link>https://blog.hackerpie.com/posts/algorithms/monotonous-stacks/monotonous-stacks/</link><pubDate>Wed, 04 Aug 2021 23:13:28 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/monotonous-stacks/monotonous-stacks/</guid><description>&lt;h1 id="什么是单调栈">什么是单调栈&lt;/h1>
&lt;p>单调栈是指从栈顶到栈底，栈内元素的值符合单调性的一种特殊数据结构。从栈顶到栈底，元素的值单调递减，称为单调递减栈；反之，称为单调递增栈。&lt;/p>
&lt;pre tabindex="0">&lt;code> \ 9 / \ 1 /
 | 7 | | 3 |
 | 5 | | 5 |
 | 3 | | 7 |
 | 2 | | 9 |
 ------- -------
单调递减栈 单调递增栈
&lt;/code>&lt;/pre>&lt;h1 id="单调栈的维护">单调栈的维护&lt;/h1>
&lt;p>为了维持栈的单调性，在往栈内插入元素时，需要比较循环比较栈顶元素与待插入元素的值的大小，以单调递增栈举例，需要始终确保栈顶元素的值大于等于待插入元素的值方可插入，否则需要先弹出栈顶元素之后，重复“检查-弹出”的流程，直到栈为空，或者栈顶元素的值大于等于待插入元素的值。&lt;/p>
&lt;p>假设需要插入的元素按照序列 &lt;code>5, 2, 3, 7, 1&lt;/code> 从左到右遍历，且需要维护单调递增栈，则插入过程为：&lt;/p>
&lt;pre tabindex="0">&lt;code> \ / \ / \ / \ / \ /
 | | | 2 | | 3 | | | | 1 |
 | 5 | | 5 | | 5 | | 7 | | 7 |
 ------- ------- ------- ------- -------
 (1) (2) (3) (4) (5)
&lt;/code>&lt;/pre>&lt;p>(1) 待插入 5，栈为空，直接插入 5；&lt;br>
(2) 待插入 2，栈顶元素为 5，大于待插入元素 2，2 可以直接插入；&lt;br>
(3) 待插入 3，栈顶元素为 2，不满足大于等于 3 的要求，所以弹出栈顶元素 2；此时新的栈顶元素为 5，大于 3，3 直接入栈；&lt;br>
(4) 待插入 7，栈顶元素为 3，不满足大于等于 7 的要求，所以弹出栈顶元素 3；此时新的栈顶元素为 5，仍然小于 7，于是也弹出栈顶元素 5；最后栈为空，直接插入 7；&lt;br>
(5) 待插入 1，栈顶元素为 7，大于待插入元素 1，1 可以直接入栈。&lt;/p></description></item><item><title>算法题解：二叉树寻路</title><link>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</link><pubDate>Sat, 31 Jul 2021 18:20:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</guid><description>&lt;p>本题来自 Leetcode 的 &lt;a href="https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/">1104 题&lt;/a>，是一道很有趣的考察二叉树数据结构的题，同时由于二叉树父子节点之间的特殊关系，同时还可以运用到位运算来巧妙解题。&lt;/p>
&lt;p>先贴一下题目：&lt;/p>
&lt;blockquote>
&lt;p>在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。&lt;br>
如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；&lt;br>
而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。


 &lt;img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2019/06/28/tree.png" alt="">

给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。&lt;/p>
&lt;/blockquote>
&lt;p>示例 1：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：label = 14
输出：[1,3,4,14]
&lt;/code>&lt;/pre>&lt;p>示例 2：&lt;/p>
&lt;pre tabindex="0">&lt;code>输入：label = 26
输出：[1,2,6,10,26]
&lt;/code>&lt;/pre>&lt;h3 id="算法题解思路1运用二叉树的节点的数值特性推导出公式求解">算法题解思路1：运用二叉树的节点的数值特性推导出公式求解&lt;/h3>
&lt;p>观察这个“之”字形二叉树，我们可以得出几个特点：&lt;/p>
&lt;ol>
&lt;li>假如所有节点都是按照从左到右依次递增，按照二叉树的特性，我们可以归纳总结出：
&lt;pre tabindex="0">&lt;code>记 vi = 某个节点的数值
v(左子节点) = 2 x vi
v(右子节点) = 2 x vi + 1

相反：
v(父节点) = vi / 2
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>对于每层(第一层为根节点)的第一个和最后一个节点，会有：
&lt;pre tabindex="0">&lt;code>v（第一个节点）= 2^(n-1) // 2 的 n-1 次方，n为当前层数
v（最后一个节点）= 2^n - 1 // 2 的 n 次方减 1，n为当前层数
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>对于任意一个数值，可以求出其所在的层数为：
&lt;pre tabindex="0">&lt;code>level = log2(N) + 1
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>从根节点开始，所有奇数层的节点是从左到右依次递增的；而所有偶数层的节点是从右到左依次递增的；&lt;/li>
&lt;li>对于某一层的所有节点来说，它们都是一个等差数列，所以数列对称位置上的两个节点数值之和总是相等，即第一个节点和最后一个节点的值之和一定等于第二个节点和倒数第二个节点的值之和。结合第 2 点，这个和始终为 2^(n-1) + 2^n - 1。&lt;/li>
&lt;/ol>
&lt;p>结合以上5点性质，我们写出求任意一个节点的伪代码为：&lt;/p></description></item><item><title>算法题解：扣分后的最大得分</title><link>https://blog.hackerpie.com/posts/algorithms/dynamic-programming/maximum-number-of-points-with-cost/</link><pubDate>Sun, 18 Jul 2021 16:48:43 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/dynamic-programming/maximum-number-of-points-with-cost/</guid><description>&lt;p>题目来自 Leetcode 的 &lt;a href="https://leetcode-cn.com/problems/maximum-number-of-points-with-cost/">5815 题&lt;/a>。&lt;/p>
&lt;p>题目的核心是：从二维矩阵中的每行中选取一个格子，每次选择一个格子后，所累计的最新积分等于前面已获积分加上被选格子的分数减去上一个格子和当前被选格子的列差。用公式表达更清晰：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>points &lt;span style="font-style:italic">// 表示 m x n 的二维矩阵每个格子的分数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>score(r, c) &lt;span style="font-style:italic">// 表示选取到 r 行 c 列所获得的最大得分
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span>score(r+1, c^) = score(r, c) + points[r+1, c^] - abs(c - c^)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>通过这个关系，可以确定两个事情：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>这是一个典型的动态规划问题&lt;/strong>：问题的最优解依赖子问题的最优解，且子问题的最优解相互影响，这一点是和贪心算法最大的不同；&lt;/li>
&lt;li>在为每一行选择一个格子时，要使 &lt;code>score(r+1, c^)&lt;/code> 的值最大，需要找到一对特殊的 &lt;code>(c, c^)&lt;/code> 的值，这也就是意味着：每次在为每一行挑选最优的格子时，需要针对结合上一行的每一列，与当前行的每一列，找出最优组合。&lt;/li>
&lt;/ol>
&lt;p>按照这个思路来写代码的话，整个算法的时间复杂度是 &lt;code>O(RC²)&lt;/code>，空间复杂度是 &lt;code>O(C)&lt;/code>。直接提交，会触发 TLE（Time Limit Exceed）。&lt;/p>
&lt;h3 id="优化思路">优化思路&lt;/h3>
&lt;p>回到最开始列的式子那里，调整式子的写法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-golang" data-lang="golang">&lt;span style="display:flex;">&lt;span>score(r+1, c^) = score(r, c) - abs(c-c^) + points[r+1, c^]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可见，其中 points[r+1, c^] 是不变量，要使 &lt;code>score(r+1, c^)&lt;/code> 的值最大，只需要满足 &lt;code>score(r, c) - abs(c-c^)&lt;/code> 最大即可。&lt;/p>
&lt;p>由于 &lt;code>abs(c-c^)&lt;/code> 表示相邻两行的两个格子的列差，&lt;code>(c-c^)&lt;/code>的正负结果受两者的相对位置关系影响，于是，我们分开两种情况来考虑：&lt;/p></description></item><item><title>依赖倒置原则</title><link>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</link><pubDate>Wed, 07 Jul 2021 21:22:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</guid><description>&lt;p>说起依赖倒置原则，已经不是个新鲜的词了，虽然也知道依赖倒置原则的具体设计模式，但是一直觉得难以理解何为“倒置”，直到今晚重新静心阅读了 Wikipedia 才恍然大悟！欣喜之余，赶紧写篇文章总结。&lt;/p>
&lt;h3 id="传统软件分层设计模式">传统软件分层设计模式&lt;/h3>
&lt;p>在软件设计开发的时候，我们都会自然而然思考系统的分层设计，比如以一个典型的三层架构来举例：&lt;/p>
&lt;pre tabindex="0">&lt;code>---------------
 服务层 （提供 API 服务）
---------------
 ↓
---------------
 业务逻辑层 （封装具体的业务逻辑）
---------------
 ↓
---------------
 存储层 （处理数据存取）
---------------
&lt;/code>&lt;/pre>&lt;p>依照此架构设计，我们可能自然而然地将各层代码实现直接封装在三个不同的代码包，其中 &lt;code>package.service&lt;/code> 直接依赖 &lt;code>package.business&lt;/code>，而 &lt;code>package.business&lt;/code> 则直接依赖 &lt;code>package.repository&lt;/code>。因此形成以下链式依赖链：&lt;/p>
&lt;pre tabindex="0">&lt;code>package.service ---&amp;gt; package.business ---&amp;gt; package.repository
&lt;/code>&lt;/pre>&lt;p>这种分层代码设计风格直接&lt;strong>耦合了依赖双方的实现&lt;/strong>，假如被依赖的包需要修改代码逻辑，则很可能导致依赖它的上层代码需要相应修改，极端场景下，这种耦合带来的变动影响可能扩散到整个依赖链。&lt;br>
其次，由于上层代码依赖了下层代码的具体实现，导致了上层代码的可复用性降低。举个具体例子，我们有一个运行了很久的系统，出于技术考量，我们需要将其存储层从 MySQL 移植到 MongoDB 上，而整个系统的核心业务逻辑并不需要也不应该有任何改变，如果是采用上述这种分层架构，则会导致我们除了替换存储层代码实现，还要相应修改业务逻辑层的代码，这就是我说的直接依赖实现会降低依赖一方的可复用性降低。&lt;/p>
&lt;h3 id="依赖倒置原则">依赖倒置原则&lt;/h3>
&lt;p>先照本宣科讲下依赖倒置原则的含义：&lt;/p>
&lt;blockquote>
&lt;p>高层级的模块不应该依赖低层级的模块。它们都应该依赖抽象（比如，接口）&lt;br>
抽象不应该依赖实现细节。实现细节（具体的实现）应该依赖抽象&lt;/p>
&lt;/blockquote>
&lt;p>有点抽象，有点拗口，有点无情，有点无理取闹对不对？&lt;br>
还是尝试用大白话解释一下：&lt;/p>
&lt;ol>
&lt;li>高层级的模块应该依赖的是低层级的模块的行为的抽象，取决于具体编程语言，可以是抽象类或者接口等技术；&lt;/li>
&lt;li>第2句话其实很简单，只有一个意思：只要依赖了实现，就是耦合了代码，所以我们需要始终依赖的是抽象，而不是实现。&lt;/li>
&lt;/ol>
&lt;p>将上面举的例子按照依赖倒置原则设计，就是这样子了：&lt;/p>
&lt;pre tabindex="0">&lt;code>package.service ---&amp;gt; package.business.interface
 ↑
 ↑ 实现
 ↑
 package.business ---&amp;gt; package.repository.interface
 ↑
 ↑ 实现
 ↑
 package.repository
&lt;/code>&lt;/pre>&lt;p>以上面的模式来说，&lt;code>package.service&lt;/code> 不再直接依赖于 &lt;code>package.business&lt;/code>，而是依赖了 &lt;code>package.business.interface&lt;/code> 接口，也就是 &lt;code>package.business&lt;/code> 的抽象。&lt;br>
另一方面，&lt;code>package.business&lt;/code> 也不再是一个被依赖方，而是对 &lt;code>package.business.interface&lt;/code> 的实现，也就是也依赖了 &lt;code>package.business.interface&lt;/code> 抽象。&lt;code>package.business&lt;/code> 从传统分层结构里的被依赖方变成了上面模式中的实现抽象接口的依赖方，这就是“倒置”一词的来由。倒置并不是说这种模式反转了依赖的方向，变成低层级代码依赖高层级代码，而是说原来的被依赖方也变成了依赖方，减少了高层级代码到低层级实现之间的依赖。&lt;/p></description></item><item><title>对于测试数据管理的思考</title><link>https://blog.hackerpie.com/posts/2021/test-data-management-thinking/</link><pubDate>Sat, 03 Jul 2021 12:25:10 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/test-data-management-thinking/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在研发流程管理中，测试环节，不管是白盒测试还是黑盒测试，都是确保研发交付质量的关键。在过往的工作经验之中，测试数据构造一直是影响开发人员自测和测试人员测试质量的一个重要因素，开发人员疲于为测试或者产品体验构造特定场景所需的测试数据，而测试人员往往总因为测试数据不符合用例前置条件的要求，被迫等待开发人员构造数据，最终导致大量的沟通成本和时间成本。&lt;/p>
&lt;p>为什么测试数据构造会如此麻烦？我认为主要还是业务本身的流程过长带来的问题，比如看一个典型的供应链商品采购仓储环节的流程：


 &lt;img src="https://blog.hackerpie.com/images/posts/2021/%e6%b5%81%e7%a8%8b.jpg" alt="">
&lt;/p>
&lt;p>在一个黑盒测试的场景下，假如测试人员需要针对“入库预约”环节进行测试，为了避免脏数据导致业务流程中断，最好的方式是从流程起点重新构造整套测试数据，然而在人手操作的情况下，这显然是难以完成的。&lt;/p>
&lt;h2 id="测试数据管理">测试数据管理&lt;/h2>
&lt;p>我调研了国内外关于测试数据构造相关的一些讨论，发现了测试数据管理，英文 Test Data Management，为了逼格，可以简称“TDM”，这个术语的存在。关于测试数据管理，大家都在说它的成本有多高，但是至今却也没有找到相对通用的解决方案，更别说成熟的解决方案了。&lt;/p>
&lt;h3 id="测试数据管理的方案思考">测试数据管理的方案思考&lt;/h3>
&lt;p>按照测试数据管理的切入点以及执行的方式，我觉得可以归纳总结出以下几种形式：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>复制生产环境数据&lt;/strong>：这种方式产生的数据，一般都满足严格的业务测试需求，数据的质量比较高，但是引入隐私安全和监管风险，且数据量比较大，存储成本高；&lt;/li>
&lt;li>&lt;strong>复制部分生产环境数据&lt;/strong>：这种方式降低存储成本，但是提高了维护成本，特别是关系型数据库，在所谓“部分”数据的前提下，需要针对不同库表指定不同的数据过滤方案；&lt;/li>
&lt;li>&lt;strong>复制生产数据，进行数据混淆处理&lt;/strong>：这种方式可以起到一定的隐私安全防护，但是类似复制生产环境数据的方案，需要针对不同库表指定不同的数据混淆规则，同时需要注意关系数据库的主键外键关系等；&lt;/li>
&lt;li>&lt;strong>执行接口调用，生成业务数据&lt;/strong>：这种方式在接口正常符合和逻辑正确的前提下，方便获得符合测试条件的数据。但是有维护开发成本，需要跟着接口设计调整，改动相对高频。另外特定场景，比如支付，需提供后门接口，以便测试脚本绕过支付等涉及第三方服务的业务，留下安全隐患。另外脚本不得不适配不同的接口协议和复杂接口认证流程等；&lt;/li>
&lt;li>&lt;strong>直接向数据库插入符合测试前置条件的新数据&lt;/strong>：自由度最高，数据完整度可控，能够获得隔离性最高的测试数据集。维护成本高，耦合技术方案存储层设计。管理成本高，需要一种高效组织和检索的方式以避免重复和凌乱的测试数据集。但是这种方式是相对稳定的方案。&lt;/li>
&lt;/ul>
&lt;h3 id="我的方案">我的方案&lt;/h3>
&lt;p>（待续……）&lt;/p>
&lt;h2 id="参考资料">参考资料&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://www.informatica.com/services-and-training/glossary-of-terms/test-data-management-definition.html">What is Test Data Management?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.delphix.com/glossary/what-is-test-data-management">What is Test Data Management?&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>解决 Mac OS 下 MySQL 客户端连接 caching_sha2_password 插件加载失败问题</title><link>https://blog.hackerpie.com/posts/2021/fix-mysql-caching-sha2-password-problem/</link><pubDate>Sun, 20 Jun 2021 11:29:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/fix-mysql-caching-sha2-password-problem/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>在开发我自己的 &lt;a href="https://github.com/Martin91/gofixtures">&lt;code>gofixtures&lt;/code>&lt;/a> 项目时，项目单测需要用到 MySQL，于是模仿 go-txdb 的方式，使用 docker 在本地起了 MySQL 容器。执行测试时，出现如下错误：&lt;/p>
&lt;pre tabindex="0">&lt;code>mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2059 (HY000): Authentication plugin &amp;#39;caching_sha2_password&amp;#39; cannot be loaded: dlopen(/usr/local/mysql/lib/plugin/caching_sha2_password.so, 2): image not found
&lt;/code>&lt;/pre>&lt;h2 id="原因分析">原因分析&lt;/h2>
&lt;p>结论：本地客户端版本过低，不支持服务器端版本的鉴权方式。&lt;/p>
&lt;h3 id="环境">环境&lt;/h3>
&lt;p>客户端：&lt;/p>
&lt;ul>
&lt;li>&lt;code>mysql Ver 14.14 Distrib 5.7.13, for osx10.11 (x86_64) using EditLine wrapper&lt;/code>&lt;/li>
&lt;li>macOS 10.14.6 Mojave&lt;/li>
&lt;/ul>
&lt;p>服务器端：&lt;/p>
&lt;ul>
&lt;li>version: 8.0.25&lt;/li>
&lt;li>runtime environment: docker container&lt;/li>
&lt;/ul>
&lt;h3 id="原因">原因&lt;/h3>
&lt;p>MySQL 从 8.0 版本开始缺省使用 &lt;code>caching_sha2_password&lt;/code> 作为验证方式，而 5.7 并不支持这种验证方式（5.7 默认使用 &lt;code>mysql_native_password&lt;/code>）。&lt;/p></description></item><item><title>《Paxos Made Simple》中文翻译：Paxos 如此简单</title><link>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</link><pubDate>Wed, 28 Oct 2020 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</guid><description>&lt;h2 id="写在前面">写在前面&lt;/h2>
&lt;p>个人在学习理解 Paxos 算法的过程中，花了比较多的时间，从最开始直接查看中文博客资料，感觉都是看完不知所以然或者有很多疑问，于是决定死磕《Paxos Made Simple》论文原文。但是由于有些英文的意思我自己理解起来还是有点困惑，于是过程中遇到无法理解的内容，一方面是会翻阅前辈们已经写过的论文的翻译作为参考，二是在搜索引擎里就一些难以理解的点搜索中英文的讨论，以此解决自己心中的困惑。在磕磕碰碰中完成论文的阅读之后，仍有一些不尽透彻之处，加上个人认为此论文已有的翻译质量参差不齐，所以斗胆想通过翻译以及必要译注再次加深自己的理解，另外可能的话，也希望本次翻译能够帮助到未来可能会遇到和我一样困惑的人。&lt;/p>
&lt;h3 id="部分关键术语表">部分关键术语表&lt;/h3>
&lt;p>论文中有一些关键术语，我已经力求用词准确，并在论文中尽力保持术语翻译的一致性，目的是尽量充分传达论文本身用词的精准，建议读者可先仔细阅读此表。&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>原文术语&lt;/th>
 &lt;th>翻译中使用术语&lt;/th>
 &lt;th>译者注&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>value(s)&lt;/td>
 &lt;td>值&lt;/td>
 &lt;td>值可能比较抽象，觉得太抽象的读者建议理解为提案的“内容”亦可&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>learn&lt;/td>
 &lt;td>获知&lt;/td>
 &lt;td>有些文章译作“了解”或者“学习”，但是这里反复斟酌，还是觉得“获知”更贴切，目的性更强烈&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>propose&lt;/td>
 &lt;td>提议&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>chosen&lt;/td>
 &lt;td>选定&lt;/td>
 &lt;td>一个被选定的值，意味着一个被“一致”确认下来的值&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>agent&lt;/td>
 &lt;td>代理&lt;/td>
 &lt;td>依旧觉得翻译成“代理”过于字面化&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>proposer(s)&lt;/td>
 &lt;td>提议者&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>acceptor(s)&lt;/td>
 &lt;td>接受者&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>learner(s)&lt;/td>
 &lt;td>学习者&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>fail / failure&lt;/td>
 &lt;td>失效/故障&lt;/td>
 &lt;td>意味着系统已经完全不能工作&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>proposal&lt;/td>
 &lt;td>提案&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>accept&lt;/td>
 &lt;td>接受&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>number&lt;/td>
 &lt;td>编号&lt;/td>
 &lt;td>&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>distinguished&lt;/td>
 &lt;td>特定的&lt;/td>
 &lt;td>文中用于形容某个经过选举而被选中的角色&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h2 id="翻译全文">翻译全文&lt;/h2>
&lt;h3 id="paxos-如此简单">Paxos 如此简单&lt;/h3>
&lt;p>2001年11月1日&lt;/p>
&lt;h3 id="摘要">摘要&lt;/h3>
&lt;p>当用浅显易懂的英语来表达的话，Paxos 是非常简单的。&lt;/p>
&lt;h3 id="1-导引">1 导引&lt;/h3>
&lt;p>Paxos 算法——一个用于实现一个容忍错误的分布式系统的算法，让很多人觉得难以理解，这可能是因为对于很多读者们而言，原来的表述太过于让人摸不着头脑&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>了。事实上，它是最简单浅显的分布式算法。它的核心是一个一致性算法——“synod”算法&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。在下一节中，将会看到这个一致性算法不可避免地遵循一些我们希望它能够满足的特性。最后一节阐述了完整的 Paxos 算法，这个算法是通过将一致性（的实现）直接应用到用于构建分布式系统的（多副本）状态机&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>这种方法中得到的——这种所谓的方法应该是众所周知的，因为它是分布式系统理论中最常被引用的论文的主题。&lt;/p>
&lt;h3 id="2-一致性算法">2 一致性算法&lt;/h3>
&lt;h4 id="21-问题描述">2.1 问题描述&lt;/h4>
&lt;p>假设有一个由多个进程组成的集合，集合里的每个进程都可以提议（可能不同的）值&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>。一致性算法保证在被提议的这些值中只有一个值能够被选定。一旦一个值被选定，则所有进程都需要能够获知（learn）这个被选定的值。一致性的安全性要求做到：&lt;/p></description></item><item><title>谨防猴子补丁以及Python中排查技巧</title><link>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</link><pubDate>Sun, 22 Sep 2019 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</guid><description>&lt;h3 id="背景">背景&lt;/h3>
&lt;p>前两天晚上线上系统突发故障，在立马打开线上错误日志之后，却只能得到一堆毫无意义的程序调用栈(traceback)的输出，于是团队成员陷入漫长而又抓瞎的问题排查过程中。问题很幸运地得到了解决，但是我一直想不明白为什么日志里打印的调用栈毫无意义，按照经验，它应该打印的是异常产生过程中的调用栈才是。在经过后续的源码分析和排查之后，我才发现其实是因为项目中一个老旧的代码使用了&lt;strong>猴子补丁&lt;/strong>导致，这也是这篇文章想要讨论的内容。&lt;/p>
&lt;h3 id="什么是猴子补丁">什么是猴子补丁&lt;/h3>
&lt;p>猴子补丁是一种用来在运行时修改（增加、变更、删除等）系统软件行为的编程方式。在动态语言里有广泛的猴子补丁应用的影子，比如 Ruby 的打开类的特性支持运行时扩展类的定义甚至替换方法的实现，Python 的方法或者函数由于可以在运行时进行替换而使得猴子补丁的应用非常方便，其他像 JavaScript 语言同样可以应用猴子补丁。&lt;/p>
&lt;h4 id="猴子补丁是把双刃剑">猴子补丁是把双刃剑&lt;/h4>
&lt;p>猴子补丁以其灵活性，可以实现补丁代码和应用代码的完全分离，同时使得应用代码在调用方式上保持调用方式始终不变。
从应用代码的角度来看，它调用的就是某个模块的原始定义的方法或者函数；而从被调用的方法或者函数的角度来看，猴子补丁的存在对它是透明的存在，以下展示一个 Python 语言的 Demo：&lt;/p>
&lt;p>我们从一个极简例子开始，向这个美好的世界问好：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="font-style:italic">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> __name__ == &lt;span style="font-style:italic">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greet()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假如执行以上脚本，得到的结果是：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ python demo.py
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Hello World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这个很简单，接下来假如打一个猴子补丁：我们扩充原来的 &lt;code>greet&lt;/code> 的行为，现在除了打印信息，还要打印下当前的时间：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">from&lt;/span> &lt;span style="font-weight:bold">datetime&lt;/span> &lt;span style="font-weight:bold">import&lt;/span> datetime
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(&lt;span style="font-style:italic">&amp;#34;Hello World!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># monkey patch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>original_greet = greet
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> greet_with_time():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> original_greet()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(datetime.now())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>greet = greet_with_time &lt;span style="font-style:italic"># replace the implementation&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># monkey patch&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">if&lt;/span> __name__ == &lt;span style="font-style:italic">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> greet() &lt;span style="font-style:italic"># 这里的调用和原来没有变化&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>运行它，得到的结果是：&lt;/p></description></item><item><title>Mac OS 环境 Rails 6.0 下 webpack-dev-server wrong version 问题解决方案</title><link>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</link><pubDate>Fri, 06 Sep 2019 15:18:30 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</guid><description>&lt;h3 id="错误信息">错误信息&lt;/h3>
&lt;p>昨天装上了 Ruby on Rails 6.0，满心欢喜初始化项目并且按照指引安装了 webpacker 之后，执行熟悉无比的 &lt;code>rails c&lt;/code> 命令，却给了一个报错：&lt;/p>
&lt;pre tabindex="0">&lt;code># 错误信息片段

yarn check v1.7.0
success Folder in sync.
Done in 0.15s.
yarn check v1.7.0
error &amp;#34;webpack-dev-server#yargs#cliui&amp;#34; is wrong version: expected &amp;#34;^4.0.0&amp;#34;, got &amp;#34;5.0.0&amp;#34;
error &amp;#34;webpack-dev-server#yargs#yargs-parser&amp;#34; is wrong version: expected &amp;#34;^11.1.1&amp;#34;, got &amp;#34;13.1.1&amp;#34;
error Found 2 errors.
info Visit https://yarnpkg.com/en/docs/cli/check for documentation about this command.
&lt;/code>&lt;/pre>&lt;h3 id="解决方案">解决方案&lt;/h3>
&lt;p>目前关于 Rails 6.0 相关的资料感觉不多，所幸找到了一篇日文版的帖子，成功解决了上边的问题：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ brew upgrade yarn
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>$ yarn upgrade
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>最终问题解决，又能愉快地前进了！&lt;/p>
&lt;p>**注意：**我自己已经一年多没怎么开发 Rails 项目了，全栈开发那就更久远了。Rails 6.0 改动比较大，很多新的组件我自己也还没有来得及熟悉，所以这篇文章就先不做上面解决方案的原理分析了，仅为备忘，可能会有其他人遇到一样的问题。&lt;/p></description></item><item><title>pymysql 开启调试模式</title><link>https://blog.hackerpie.com/posts/2019/enable-debug-mode-of-pymysql/</link><pubDate>Sun, 18 Aug 2019 18:32:01 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/enable-debug-mode-of-pymysql/</guid><description>&lt;p>今天在排查线上一个奇怪的数据库连接问题，所以打开了 pymysql 的源码在阅读，发现 pymysql 在其 &lt;code>connections&lt;/code> 模块里内置了一个 &lt;code>DEBUG&lt;/code> 变量用于控制是否开启调试模式，是的话，会将当前连接的操作以及报文内容都打印到控制台。&lt;/p>
&lt;h4 id="使用方法">使用方法&lt;/h4>
&lt;p>在你的服务器初始化代码里，加上对 &lt;code>DEBUG&lt;/code> 的设置，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">import&lt;/span> &lt;span style="font-weight:bold">pymysql&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pymysql.install_as_MySQLdb()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>pymysql.connections.DEBUG = &lt;span style="font-weight:bold">True&lt;/span> &lt;span style="font-style:italic"># 这是我新加的一行&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>重启服务器后，访问相关接口，会看到标准输出里有类似下面的一些输出：&lt;/p>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/pymysql-debug.png" alt="clipboard.png">
&lt;/p></description></item><item><title>django 快速启动数据库客户端程序</title><link>https://blog.hackerpie.com/posts/2019/quick-launch-database-client-in-django/</link><pubDate>Thu, 15 Aug 2019 08:18:30 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/quick-launch-database-client-in-django/</guid><description>&lt;p>实际工作经历中，免不了有时候需要连接数据库进行问题排查分析的场景，之前一直习惯通过 &lt;code>mysql -uxxx -hxxxx -P1234 ...&lt;/code> 这样的方式来启动命令行形式的 MySQL 数据库客户端程序，只是用起来比较麻烦，每次都要拷贝各个配置参数，还要记得不要在命令里显式打印密码。后来想起来在开发 Ruby on Rails 程序的时候，其提供了 &lt;code>rails dbconsole&lt;/code> 的命令，可以方便直接启动对应的数据库客户端命令行程序，联想到 Django 理论上也有，所以找到了 &lt;code>python manage.py dbshell&lt;/code> 这个命令，使用效果和自己手动敲 mysql 命令行是一样的，省去繁琐的参数设定步骤。&lt;/p>
&lt;h4 id="使用效果">使用效果&lt;/h4>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/dbshell.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="用法">用法&lt;/h4>
&lt;p>其用法可以直接查询命令行帮助文档：&lt;/p>
&lt;pre tabindex="0">&lt;code># python manage.py dbshell -h
Usage: manage.py dbshell [options]

Runs the command-line client for specified database, or the default database if none is provided.

Options:
 -v VERBOSITY, --verbosity=VERBOSITY
 Verbosity level; 0=minimal output, 1=normal output,
 2=verbose output, 3=very verbose output
 --settings=SETTINGS The Python path to a settings module, e.g.
 &amp;#34;myproject.settings.main&amp;#34;. If this isn&amp;#39;t provided, the
 DJANGO_SETTINGS_MODULE environment variable will be
 used.
 --pythonpath=PYTHONPATH
 A directory to add to the Python path, e.g.
 &amp;#34;/home/djangoprojects/myproject&amp;#34;.
 --traceback Raise on exception
 --database=DATABASE Nominates a database onto which to open a shell.
 Defaults to the &amp;#34;default&amp;#34; database.
 --version show program&amp;#39;s version number and exit
 -h, --help show this help message and exit
&lt;/code>&lt;/pre></description></item><item><title>不严谨的不同语言下大 Excel 文件写入的性能比较</title><link>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</link><pubDate>Sat, 23 Mar 2019 21:11:06 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</guid><description>&lt;h3 id="背景">背景&lt;/h3>
&lt;p>去年因为线上系统需要导出大量数据（大概是 11 万行）到 Excel，代码是 Python 2.7 写的，除去数据库查询耗时，整个的 Excel 文件生成也还要耗费几十秒的时间，这听起来真是一个非常夸张的事情。后来为其更换了号称性能表现最好的 pyexcelerate 库，性能确实有提升，但是仍是差强人意的在小几十秒。&lt;/p>
&lt;p>昨天突发奇想，如果是换成其他语言，这个 excel 导出是否还需要这么长时间？于是经过一番试验之后，就有了今天的这篇文章。&lt;/p>
&lt;p>**特别声明：**试验只是为了感官上做个简单对比，测试结果采集数据只考虑了耗时，没有考虑资源消耗等情况，需要严谨的性能对比的读者，可以放弃阅读了。&lt;/p>
&lt;h3 id="测试内容">测试内容&lt;/h3>
&lt;p>使用不同的语言及其版本，测试各自完成包含 100,000 行 x 50 列单元格的 excel 文件的生成，对比其各自耗费时间，3次重复执行取其平均值后进行横向比较。&lt;/p>
&lt;h4 id="已经测试的语言及版本">已经测试的语言及版本&lt;/h4>
&lt;ul>
&lt;li>Ruby 2.6 + axlsx 2.0.1&lt;/li>
&lt;li>Python 2.7 + pyexcelerate 0.7.3&lt;/li>
&lt;li>Python 3.6 + pyexcelerate 0.7.3&lt;/li>
&lt;li>Go 1.10.1 + gooxml 0.8&lt;/li>
&lt;/ul>
&lt;h4 id="测试代码">测试代码&lt;/h4>
&lt;p>&lt;a href="https://github.com/Martin91/excel-writors-benchmark">https://github.com/Martin91/excel-writors-benchmark&lt;/a>&lt;/p>
&lt;h4 id="结果">结果&lt;/h4>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/posts/benchmark-excel.png" alt="benchmark.png">
&lt;/p>
&lt;h4 id="结论">结论&lt;/h4>
&lt;p>就这个测试场景来说：&lt;/p>
&lt;ol>
&lt;li>Go 1.10.1 + gooxml 0.8 是最快的；&lt;/li>
&lt;li>同样是 pyexcelerate 0.7.3，Python 2.7 性能优于 Python 3.6;&lt;/li>
&lt;li>Ruby 2.6 + axlsx 2.0.1 表现最不给力，这里有个题外话，选择的 axlsx 本身并不是性能最好的 gem，只是流行度够高，Ruby 有一个专门针对性能优化后的 gem，但是因为知之甚少，没有采用。&lt;/li>
&lt;/ol></description></item><item><title>利用 Postman Chrome app 和 Chrome 浏览器共享网站 cookie</title><link>https://blog.hackerpie.com/posts/2019/share-cookies-between-chrome-and-postman/</link><pubDate>Mon, 14 Jan 2019 09:22:19 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/share-cookies-between-chrome-and-postman/</guid><description>&lt;h3 id="声明">声明&lt;/h3>
&lt;p>文章内容已过期，Postman 桌面版已实现本文末尾的缺憾，可直接阅读&lt;a href="https://blog.postman.com/introducing-interceptor-integration-for-native-postman-apps/">官方博客&lt;/a>。&lt;/p>
&lt;h3 id="背景">背景&lt;/h3>
&lt;p>作为一个Web工程师，最熟悉的日常工作莫过于后台接口开发与联调测试，而在接口测试上，大家最喜爱的工具清单里，必然少不了 Postman 这一利器。然而，有时接口测试需要准备好登录态，或者其他状态数据，而这些数据往往就存在浏览器 Cookie 里边。结合本文介绍的工具，便可以无缝在 Postman Chrome app （为什么强调是 Postman Chrome app，文章末尾会说明）和 Chrome 浏览器之间共享 Cookie，而这个共享过程对用户是透明的。&lt;/p>
&lt;h3 id="工具清单">工具清单&lt;/h3>
&lt;p>以下工具请自行安装，我只贴下官方的软件界面截图。&lt;/p>
&lt;ol>
&lt;li>Chrome 浏览器&lt;/li>
&lt;li>&lt;a href="https://chrome.google.com/webstore/detail/postman/fhbjgbiflinjbdggehcddcbncdddomop?hl=en">Postman Chrome app&lt;/a>


 &lt;img src="https://blog.hackerpie.com/images/posts/postman-app.png" alt="clipboard.png">
&lt;/li>
&lt;li>&lt;a href="https://chrome.google.com/webstore/detail/postman-interceptor/aicmkgpgakddgnaphhhpliifpcfhicfo?hl=en">Postman Interceptor&lt;/a>


 &lt;img src="https://blog.hackerpie.com/images/posts/postman-interceptor.png" alt="clipboard.png">
&lt;/li>
&lt;/ol>
&lt;h3 id="使用步骤">使用步骤&lt;/h3>
&lt;p>以下我们以 Github 网站为例，演示下如何实现 Cookie 共享。&lt;/p>
&lt;h4 id="一确认-postman-interceptor-插件安装成功如图所示">一、确认 &lt;strong>Postman Interceptor&lt;/strong> 插件安装成功（如图所示）&lt;/h4>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/posts/postman-interceptor-installed.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="二启动-postman在右上角的卫星小图标那里开启-chrome-interceptor">二、启动 Postman，在右上角的卫星小图标那里开启 Chrome Interceptor&lt;/h4>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/posts/enable-postman-interceptor.png" alt="clipboard.png">
&lt;/p>
&lt;h4 id="三在-chrome-浏览器里正常登陆-github-网站此步骤没什么好演示的-">三、在 Chrome 浏览器里正常登陆 GitHub 网站（此步骤没什么好演示的 ╭(╯^╰)╮）&lt;/h4>
&lt;h4 id="四在-postman-chrome-app-中直接模拟请求通知接口">四、在 Postman Chrome app 中直接模拟请求通知接口&lt;/h4>
&lt;p>接口路径：https://github.com/notifications?_pjax=%23js-pjax-container


 &lt;img src="https://blog.hackerpie.com/images/posts/chrome-visit.png" alt="clipboard.png">

也就是说，这个时候，我们虽然没有对 Postman 做特殊的 Cookie 设置，但是它的请求的登录态都被服务器验证通过了，cookie 共享成功！&lt;/p>
&lt;h3 id="假如这个时候退出浏览器的登录态呢">假如这个时候退出浏览器的登录态呢？&lt;/h3>
&lt;p>我们先从 GitHub 退出登录，还是刚才的请求，这个时候的响应是：


 &lt;img src="https://blog.hackerpie.com/images/posts/chrome-visit2.png" alt="clipboard.png">

是的，因为 Chrome 里已经退出登录，所以 Postman 这边也自然失去登录态了，说明两边 Cookie 是同步的。&lt;/p></description></item><item><title>记一次Redis数据库配置导致的连接数泄露的问题</title><link>https://blog.hackerpie.com/posts/2018/ji-yi-ci-redisshu-ju-ku-pei-zhi-dao-zhi-de-lian-jie-shu-xie-lou-de-wen-ti/</link><pubDate>Sat, 10 Feb 2018 20:35:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2018/ji-yi-ci-redisshu-ju-ku-pei-zhi-dao-zhi-de-lian-jie-shu-xie-lou-de-wen-ti/</guid><description>&lt;h3 id="问题背景">问题背景&lt;/h3>
&lt;p>去年圣诞节当天，突然收到一个我经手过的项目的告警邮件，错误消息显示**“Redis::CommandError: ERR max number of clients reached”**。


 &lt;img src="https://blog.hackerpie.com/images/posts/20180210/redis%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98.002.jpeg" alt="Redis 连接数告警">
&lt;/p>
&lt;p>什么情况？难道这个项目翻车了？第一反应是这台服务器运行着自建的 Redis 数据库，但是客户端只有同个内网的一个 Ruby on Rails 的应用，怎么会有连接数爆掉的可能？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4 id="理论连接数计算">理论连接数计算&lt;/h4>
&lt;p>老衲掐指一算：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>sidekiq 客户端所需连接数&lt;/strong>: 对面 Rails 应用有 10 个 Unicorn 工作进程，每个unicorn进程初始化一个 sidekiq 客户端，一个 sidekiq 客户端默认连接池大小是 5，而且是懒惰策略，按需连接的，最大值是 10 x 5 = 50；&lt;/li>
&lt;li>&lt;strong>显式 Redis 连接&lt;/strong>: 程序代码里有一个 $redis 全局变量，初始化了一个 redis 连接，10个工作进程，也就是 10 个连接；&lt;/li>
&lt;li>&lt;strong>sidekiq 服务端所需连接数&lt;/strong>: sidekiq server 端 concurrency 配置是 10，那么按照官方文档，另有加上 2 个连接，也就是12个连接；&lt;/li>
&lt;li>&lt;strong>Rails cache 所需连接数&lt;/strong>: 按照&lt;code>redis-store&lt;/code> gem 源码，默认连接池大小应该是 5，10个 unicorn 工作进程，按需连接，最大值是 10 x 5 = 50。&lt;/li>
&lt;/ol>
&lt;p>在不考虑其他可能还用到 Redis 连接的情况下，目前已知的最大 Redis 连接数需求是 122，这个数远小于 Redis 理论最大连接数啊，而且当时显示连接数到达上万！而且这个项目已经很少访问，压力极其小，不大可能会达到理论所需连接数啊！&lt;/p></description></item><item><title>解读 Rails: Migrations</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-migrations/</link><pubDate>Sat, 14 Oct 2017 22:29:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-migrations/</guid><description>&lt;p>此文翻译自&lt;a href="http://www.monkeyandcrow.com/blog/reading_rails_migrations/">Reading Rails - Migrations&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>今天我们将会探讨一下 Rails 经常被忽视的可靠的工作伙伴 —— Migrator。它是如何搜寻你的 migrations 并且执行它们的呢？我们将再一次慢慢地挖掘 Rails 的源代码，并在此过程中慧海拾珠。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>为了跟随本文的步骤，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开相关的代码库，或者直接在&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github&lt;/a>上查看这些代码。&lt;/p>
&lt;h3 id="动身启程">动身启程&lt;/h3>
&lt;p>在展开讨论之前，此处并无特殊准备要求。或许你已经创建好了项目所需要的但是仍是空的数据库。如果你执行 &lt;code>rake db:migrate&lt;/code>，所有的未执行的 migrations 就会开始执行。让我们从查看 &lt;code>databases.rake&lt;/code> 里的 Rake 任务的源码开始动起来：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>desc &lt;span style="font-style:italic">&amp;#34;Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog).&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>task &lt;span style="font-style:italic">:migrate&lt;/span> =&amp;gt; [&lt;span style="font-style:italic">:environment&lt;/span>, &lt;span style="font-style:italic">:load_config&lt;/span>] &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActiveRecord::Migration.verbose = ENV[&lt;span style="font-style:italic">&amp;#34;VERBOSE&amp;#34;&lt;/span>] ? ENV[&lt;span style="font-style:italic">&amp;#34;VERBOSE&amp;#34;&lt;/span>] == &lt;span style="font-style:italic">&amp;#34;true&amp;#34;&lt;/span> : &lt;span style="">true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ActiveRecord::Migrator.migrate(ActiveRecord::Migrator.migrations_paths, ENV[&lt;span style="font-style:italic">&amp;#34;VERSION&amp;#34;&lt;/span>] ? ENV[&lt;span style="font-style:italic">&amp;#34;VERSION&amp;#34;&lt;/span>].to_i : &lt;span style="">nil&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>虽然我们并不打算揭露 Rake 本身的工作机制，但是值得注意的是，执行 &lt;code>migrate&lt;/code> 要求另外两个任务 &lt;code>[:environment, :load_config]&lt;/code> 的首先执行。这能确保 Rails 的运行环境以及你的 &lt;code>database.yml&lt;/code> 文件被加载进来。&lt;/p>
&lt;p>上面的 rake 任务通过环境变量配置了 &lt;code>ActiveRecord::Migration&lt;/code> 以及 &lt;code>ActiveRecord::Migrator&lt;/code>。环境变量是一种非常有效的可用于向你的应用程序传递信息的方式。缺省地，诸如&lt;code>USER&lt;/code>的很多（环境）变量都是已经设置好的，他们也可以在每个（终端）命令执行时单独设置。举个例子，如果你通过 &lt;code>VERBOSE=false rake db:migrate&lt;/code> 调用了 Rake 任务，&lt;code>ENV[&amp;quot;VERBOSE&amp;quot;]&lt;/code>的值就会是字符串&lt;code>&amp;quot;false&amp;quot;&lt;/code>。&lt;/p></description></item><item><title>动态密码算法介绍与实现</title><link>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</link><pubDate>Sat, 18 Feb 2017 09:54:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</guid><description>&lt;p>动态密码，亦称一次性密码（One Time Password, 简称 OTP），是一种高效简单又比较安全的密码生成算法，在我们的生活以及工作中随处可见，身为开发者，也或多或少在自己的业务系统中集成了二步验证机制，那么，技术运用，既要知其然，更要知其所以然，动态密码算法是怎样的？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="读前指引">读前指引&lt;/h2>
&lt;ul>
&lt;li>通过这篇文章，你可以了解以下知识：
&lt;ul>
&lt;li>动态密码的背景知识&lt;/li>
&lt;li>动态密码的分类&lt;/li>
&lt;li>不同动态密码的生成算法，HOTP 以及 TOTP&lt;/li>
&lt;li>HOTP 以及 TOTP 的简单的 Ruby 编程语言的实现&lt;/li>
&lt;li>两类算法各自注意事项&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>限于篇幅，我不会讨论以下几点，有兴趣的同学可以参考我文章末尾给出的参考资料了解：
&lt;ul>
&lt;li>不同动态密码的安全性分析&lt;/li>
&lt;li>计时动态密码如何确保有效期间内，密码不被二次使用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="动态密码背景介绍">动态密码背景介绍&lt;/h2>
&lt;p>从我的角度理解，动态密码是指随着某一事件（密码被使用、一定的时间流逝等）的发生而重新生成的密码，因为动态密码本身最大优点是防重复执行攻击(replay attack)，它能很好地避免类似静态密码可能被暴力破解等的缺陷，现实运用中，一般采用“静态密码+动态密码”相结合的双因素认证，我们也称二步验证。&lt;/p>
&lt;p>而动态密码其实很早就出现在我们的生活里了，在移动支付发展起来之前，网银是当时最为流行的在线支付渠道，当时银行为了确保大家的网银账号支付安全，都会给网银客户配发动态密码卡，比如中国银行电子口令卡（按时间差定时生成新密码，口令卡自带电池，可保证连续使用几年），或者工商银行的电子银行口令卡（网银支付网页每次生成不同的行列序号，用户根据指定行列组合刮开密码卡上的涂层获取密码，密码使用后失效），又或者银行强制要求的短信验证码，这些都可以纳入动态密码的范畴。&lt;br>


 &lt;img src="https://blog.hackerpie.com/images/secureRSA.jpeg" alt="中行电子口令卡">



 &lt;img src="https://blog.hackerpie.com/images/password_card.jpg" alt="工行电子银行口令卡">
&lt;/p>
&lt;p>而随着移动互联网的发展以及移动设备的智能化的不断提高，设备间的同步能力大幅提升，以前依赖独立设备的动态密码生成技术很快演变成了手机上的动态密码生成软件，以手机软件的形式生成动态密码的方式极大提高了动态密码的便携性，一个用户一个手机就可以管理任意多个动态密码的生成，这也使得在网站上推动二步验证减少了很多阻力，因为以往客户可能因为使用口令卡太麻烦，而拒绝打开二步验证机制，从而让自己的账号暴露在风险之下。最为知名的动态密码生成软件，当属 Google 的 Authenticator APP。&lt;br>


 &lt;img src="https://blog.hackerpie.com/images/google-auth.jpeg" alt="Google Authenticator">
&lt;/p>
&lt;h2 id="动态密码算法探索之旅">动态密码算法探索之旅&lt;/h2>
&lt;h3 id="动态密码的分类">动态密码的分类&lt;/h3>
&lt;p>一般来说，常见的动态密码有两类：&lt;/p>
&lt;ul>
&lt;li>**计次使用：**计次使用的OTP产出后，可在不限时间内使用，知道下次成功使用后，计数器加 1，生成新的密码。用于实现计次使用动态密码的算法叫 HOTP，接下来会对这个算法展开介绍；&lt;/li>
&lt;li>**计时使用：**计时使用的OTP则可设定密码有效时间，从30秒到两分钟不等，而OTP在进行认证之后即废弃不用，下次认证必须使用新的密码。用于实现计时使用动态密码的算法叫 TOTP，接下来会对这个算法展开介绍。&lt;/li>
&lt;/ul>
&lt;p>在真正开展算法介绍之前，需要补充介绍的是：动态密码的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值进行密码算法计算，使用的算法有对称算法、HASH、HMAC等。记住这一点，这个是所有动态密码算法实现的基础。&lt;/p>
&lt;h3 id="hotp">HOTP&lt;/h3>
&lt;p>HOTP 算法，全称是“An HMAC-Based One-Time Password Algorithm”，是一种基于事件计数的一次性密码生成算法，详细的算法介绍可以查看 &lt;a href="https://tools.ietf.org/html/rfc4226">RFC 4226&lt;/a>。其实算法本身非常简单，算法本身可以用两条简短的表达式描述：&lt;/p>
&lt;blockquote>
&lt;p>HOTP(K,C) = Truncate(HMAC-SHA-1(K,C))
PWD(K,C,digit) = HOTP(K,C) mod 10^Digit&lt;/p>
&lt;/blockquote>
&lt;p>上式中：&lt;/p>
&lt;ul>
&lt;li>K 代表我们在认证服务器端以及密码生成端（客户设备）之间共享的密钥，在 RFC 4226 中，作者要求共享密钥最小长度是 128 位，而作者本身推荐使用 160 位长度的密钥&lt;/li>
&lt;li>C 表示事件计数的值，8 字节的整数，称为移动因子（moving factor），需要注意的是，这里的 C 的整数值需要用二进制的字符串表达，比如某个事件计数为 3，则C是 &lt;code>&amp;quot;11&amp;quot;&lt;/code>（此处省略了前面的二进制的数字0）&lt;/li>
&lt;li>HMAC-SHA-1 表示对共享密钥以及移动因子进行 HMAC 的 SHA1 算法加密，得到 160 位长度（20字节）的加密结果&lt;/li>
&lt;li>Truncate 即截断函数，后面会详述&lt;/li>
&lt;li>digit 指定动态密码长度，比如我们常见的都是 6 位长度的动态密码&lt;/li>
&lt;/ul>
&lt;h4 id="truncate-截断函数">Truncate 截断函数&lt;/h4>
&lt;p>由于 SHA-1 算法是既有算法，不是我们讨论重点，故而 Truncate 函数就是整个算法中最为关键的部分了。以下引用 Truncate 函数的步骤说明：&lt;/p></description></item><item><title>周末到了，来段代码压压惊</title><link>https://blog.hackerpie.com/posts/archive/zhou-mo-dao-le-lai-duan-dai-ma-ya-ya-jing/</link><pubDate>Sat, 26 Nov 2016 21:43:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhou-mo-dao-le-lai-duan-dai-ma-ya-ya-jing/</guid><description>&lt;p>最近一段时间，写了两篇关于 sidekiq 的源码分析，但是一直想要补充的一段 sidekiq 里边的代码其实是挺有趣也挺逗的，所以这个星期就不要长篇大论的源码分析，来点轻松点的吧。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>这个代码是这样的 o(╯□╰)o：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq.rb#L51-L53&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Sidekiq&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> self.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ...
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Haha, are you kidding me? 见过用特殊字符或者特殊语言文字做方法名的，但是用颜文字，我还是第一次见。但是别笑，本着工科男严谨与求知的精神，我全局搜索了下这个方法的调用，结果更搞笑的结果来了，这个方法根本就没有真实调用，但是相应的测试用例同样非常逗 2333333333！！！&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>describe &lt;span style="font-style:italic">&amp;#34;❨╯°□°❩╯︵┻━┻&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> before { $stdout = StringIO.new }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> after { $stdout = STDOUT }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> it &lt;span style="font-style:italic">&amp;#34;allows angry developers to express their emotional constitution and remedies it&amp;#34;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.&lt;span style="">❨╯°□°❩╯︵┻━┻&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> assert_equal &lt;span style="font-style:italic">&amp;#34;Calm down, yo.&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\n&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>, $stdout.string
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>哈哈，这只是难道为了方便程序员怒火中烧的时候表达想掀桌的内心吗？&lt;/p></description></item><item><title>Sidekiq 信号处理源码分析</title><link>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</link><pubDate>Sun, 20 Nov 2016 10:08:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</guid><description>&lt;h3 id="引言">引言&lt;/h3>
&lt;p>在之前的文章&lt;a href="https://blog.hackerpie.com/blog/articles/2016/10/29/sidekiqren-wu-diao-du-liu-cheng-fen-xi/">《Sidekiq任务调度流程分析》&lt;/a>中，我们一起仔细分析了 Sidekiq 是如何基于多线程完成队列任务处理以及调度的。我们在之前的分析里，看到了不管是 &lt;code>Sidekiq::Scheduled::Poller&lt;/code> 还是 &lt;code>Sidekiq::Processor&lt;/code> 的核心代码里，都会有一个由 &lt;code>@done&lt;/code> 实例变量控制的循环体：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> start
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @thread ||= safe_thread(&lt;span style="font-style:italic">&amp;#34;scheduler&amp;#34;&lt;/span>) &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> initial_wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done &lt;span style="font-style:italic"># 这是 poller 的循环控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> enqueue
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> wait
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Sidekiq.logger.info(&lt;span style="font-style:italic">&amp;#34;Scheduler exiting...&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> run
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">while&lt;/span> !@done &lt;span style="font-style:italic"># 这是我们常说的 worker 循环控制&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> process_one
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Sidekiq::Shutdown
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_stopped(self)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">rescue&lt;/span> Exception =&amp;gt; ex
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @mgr.processor_died(self, ex)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>也就是说，这些 &lt;code>@done&lt;/code> 实例变量决定了 &lt;code>poller&lt;/code> 线程跟 &lt;code>worker&lt;/code> 线程是否循环执行？一旦 &lt;code>@done&lt;/code> 被改为 &lt;code>true&lt;/code>，那循环体就不再执行，线程自然也就是退出了。于是，单从这些代码，我们可以断定， Sidekiq 就是通过设置 &lt;code>@done&lt;/code> 的值来通知一个线程安全退出（graceful exit）的。我们也知道，生产环境中，我们是通过发送信号的方式来告诉 sidekiq 退出或者进入静默(quiet)状态的，那么，这里的 &lt;code>@done&lt;/code> 是怎么跟信号处理联系起来的呢？这些就是今天这篇文章的重点了！&lt;/p></description></item><item><title>sidekiq任务调度流程分析</title><link>https://blog.hackerpie.com/posts/archive/sidekiqren-wu-diao-du-liu-cheng-fen-xi/</link><pubDate>Sat, 29 Oct 2016 16:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sidekiqren-wu-diao-du-liu-cheng-fen-xi/</guid><description>&lt;p>&lt;a href="http://sidekiq.org/">sidekiq&lt;/a>是 Ruby 中一个非常优秀而且可靠的后台任务处理软件，其依赖 Redis 实现队列任务的增加、重试以及调度等。而 sidekiq 从启动到开始不断处理任务、定时任务以及失败任务的重试，都是如何调度的呢？遇到问题的时候，又该如何调优呢？&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="注意">注意&lt;/h3>
&lt;ol>
&lt;li>今天的分析所参考的 sidekiq 的源码对应版本是 4.2.3；&lt;/li>
&lt;li>今天所讨论的内容，将主要围绕任务调度过程进行分析，无关细节将不赘述，如有需要，请自行翻阅 sidekiq 源码；&lt;/li>
&lt;li>文章内容真的很长，请做好心理准备。&lt;br>


 &lt;img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/0fc8f347a4c7cba67066b2527bdb8f94.png!large" alt="">
&lt;/li>
&lt;/ol>
&lt;h3 id="你将了解到什么">你将了解到什么？&lt;/h3>
&lt;ol>
&lt;li>sidekiq 的任务调度机制：定时任务、重试任务的检查机制，队列任务的排队以及队列权重对处理优先级的影响；&lt;/li>
&lt;li>sidekiq 的中间件机制以及在此基础上实现的任务重试机制。&lt;/li>
&lt;/ol>
&lt;h2 id="先抛结论">先抛结论&lt;/h2>
&lt;h3 id="时序图">时序图&lt;/h3>
&lt;p>对于复杂的调用关系，我习惯用时序图帮助我理解其中各部分代码之间相互协作的关系（注意：为了避免太多细节造成阅读负担，我将参数传递以及返回值等冗杂过程去除了，只保留与任务调度相关的关键调用）：
![sidekiq 任务调度时序图](/images/medias/sidekiq job dispatcher.png)&lt;/p>
&lt;h3 id="人话">人话&lt;/h3>
&lt;p>Sidekiq 整个任务调度过程中依赖几个不同角色的代码共同协作，其分工如下：


 &lt;img src="https://ruby-china-files.b0.upaiyun.com/photo/2016/fe43bace416ba3bb7f7d77b397683bf4.png!large" alt="">
&lt;/p>
&lt;h2 id="源码之旅--启动">源码之旅 —— 启动&lt;/h2>
&lt;p>当我们在执行 &lt;code>sidekiq&lt;/code> 时，源码中的 &lt;code>bin/sidekiq.rb&lt;/code> 文件便是第一个开始执行的文件，让我们看看&lt;a href="https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12">里边的主要代码&lt;/a>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/bin/sidekiq#L9-L12&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">begin&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli = Sidekiq::CLI.instance
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli.parse
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cli.run &lt;span style="font-style:italic"># &amp;lt;===== 这边走&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># ...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>紧靠 &lt;code>begin&lt;/code> 后边的两行代码首先创建 &lt;code>Sidekiq::CLI&lt;/code> 类的一个实例，接着调用实例方法 &lt;code>#parse&lt;/code> 解析 sidekiq 的配置参数，其中包括队列的配置、worker 数量的配置等，在此不展开了。接着实例方法 &lt;code>#run&lt;/code> 将带着我们继续往下走，让我们继续看 &lt;code>lib/sidekiq/cli.rb&lt;/code> 里边的代码：&lt;/p></description></item><item><title>嘿，小心你的双等号==</title><link>https://blog.hackerpie.com/posts/archive/pay-attention-to-your-double-equals/</link><pubDate>Sun, 17 Jan 2016 01:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/pay-attention-to-your-double-equals/</guid><description>&lt;p>前两天在写代码的时候，突然收到警告说项目代码中存在 XSS 漏洞，遂立即根据报告的 URL 排查页面代码，虽然很快就修复了，而且同样问题的讨论两年前就有了，看&lt;a href="https://ruby-china.org/topics/16633">RubyChina: 别用 raw 和 html_safe&lt;/a>，一般来说相对有经验的老鸟也应该都知道这个点，但是还是觉得有必要写出来，再次提醒一下其他小伙伴，避免踩坑。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="问题根源">问题根源&lt;/h2>
&lt;p>其中，在找到的漏洞出现的地方，都存在类似以下这样的 slim 代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>input class=&lt;span style="font-style:italic">&amp;#39;xxx&amp;#39;&lt;/span> value==params[&lt;span style="font-style:italic">:account&lt;/span>]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>问题就出在双等号 &lt;code>==&lt;/code> 上，因为在 &lt;strong>slim&lt;/strong> 跟 &lt;strong>ERB&lt;/strong> 模板（其他模板比如 HAML 之类的就不清楚了）中，双等号其实是 Rails 的 &lt;code>raw&lt;/code> 这个 helper 方法的缩写，&lt;a href="http://edgeguides.rubyonrails.org/active_support_core_extensions.html#output-safety">参考链接&lt;/a>：&lt;/p>
&lt;blockquote>
&lt;p>To insert something verbatim use the raw helper rather than calling html_safe:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>&amp;lt;%= raw @cms.current_template %&amp;gt; &amp;lt;%# inserts @cms.current_template as is %&amp;gt;
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>or, equivalently, use &lt;code>&amp;lt;%==&lt;/code>:&lt;/p>
&lt;/blockquote>
&lt;pre>&lt;code>&amp;lt;%== @cms.current_template %&amp;gt; &amp;lt;%# inserts @cms.current_template as is %&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>也就是说上面的代码等同于：&lt;/p></description></item><item><title>谨防 ActiveSupport::Cache::Store 缓存 nil 值</title><link>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</link><pubDate>Fri, 30 Oct 2015 20:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</guid><description>&lt;p>Rails 中的 &lt;strong>&lt;a href="https://github.com/rails/rails/tree/master/activesupport">active_support&lt;/a>&lt;/strong> 组件主要基于 Rails 需要提供了很多非常有用的基础工具以及对 Ruby 内置类进行扩展。其中的 cache 模块主要提供了 Rails 中底层缓存的定义以及简单实现。今天要跟大家探讨的是之前在使用此模块所遇到的一个坑，有兴趣学习其基本用法的可以点击以下两个链接：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-store">Rails Guides: ActiveSupport::Cache::Store&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html">Rails API: ActiveSupport::Cache::Store&lt;/a>&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h3 id="从-activesupportcachestorefetch-聊起">从 ActiveSupport::Cache::Store#fetch 聊起&lt;/h3>
&lt;p>之前在实现一个需要从外部服务请求数据的功能时，处于性能考虑，我在代码中使用了缓存，并且设置缓存失效时间为 7 天，示例代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> read_external_service(params)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 这段代码稍微解释下：&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 当缓存命中时，则直接读取缓存，如果无期待缓存，则通过 HTTP 向外请求结果，并且将结果&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># 缓存下来，这样子，当下次继续调用时，则可直接返回缓存内容，而无需重复向外请求&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rails.cache.fetch &lt;span style="font-style:italic">&amp;#39;example_cache_key_here&amp;#39;&lt;/span>, &lt;span style="font-style:italic">expires_in&lt;/span>: 7.days &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> response = HTTParty.get &lt;span style="font-style:italic">&amp;#39;https://example.com/example/request/path&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> JSON.parse(response.body)[&lt;span style="font-style:italic">&amp;#34;data&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码其实不复杂，核心代码就是使用了 &lt;a href="http://api.rubyonrails.org/classes/ActiveSupport/Cache/Store.html#method-i-fetch">&lt;code>ActiveSupport::Cache::Store#fetch&lt;/code>&lt;/a> 方法。&lt;/p>
&lt;p>一切都很正常地运行着，直到有一天，线上系统不断报警，出错原因就是这段代码总是返回 &lt;code>nil&lt;/code> ，而调用者又因为没有判断 &lt;code>nil&lt;/code> 值，就会出现 &lt;code>undefined method 'xxx' for nil:NilClass&lt;/code> 错误。在 debug 时，我尝试了直接调用外部服务接口，发现请求都有正确返回数据，不可能返回 &lt;code>nil&lt;/code> 啊，难道是缓存了 &lt;code>nil&lt;/code> 值？下面就直接通过代码验证一下！&lt;/p></description></item><item><title>Apdex——衡量服务器性能的标准</title><link>https://blog.hackerpie.com/posts/archive/the-correct-way-to-metric-server-response-time/</link><pubDate>Thu, 30 Jul 2015 12:12:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/the-correct-way-to-metric-server-response-time/</guid><description>&lt;p>日常工作中，我们总是习惯于通过量化的标准去衡量我们对事物的评价，比如美食点评的星级、酒店的星级、每个个人的信用评分等等。而作为一个 Web 工程师，我们也总是在意于我们网站的性能，因为网站的性能会最直接地影响用户的体验。今天要介绍的就是一种同样能够帮助工程师对应用性能进行量化评估的标准 —— Apdex 。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Apdex 全称是 Application Performance Index，是由 Apdex 联盟开放的用于评估应用性能的工业标准。Apdex 联盟起源于 2004 年，由 &lt;a href="http://apdex.org/bios.html">Peter Sevcik&lt;/a>发起。Apdex 标准从用户的角度出发，将对应用响应时间的表现，转为用户对于应用性能的可量化为范围为 0-1 的满意度评价。&lt;/p>
&lt;h3 id="术语">术语&lt;/h3>
&lt;p>Apdex 定义了应用响应时间的最优门槛为T，另外根据应用响应时间结合 T 定义了三种不同的性能表现：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Satisfied（满意）&lt;/strong>：应用响应时间低于或等于 T（T 由性能评估人员根据预期性能要求确定），比如 T 为 1.5s，则一个耗时 1s 的响应结果则可以认为是 satisfied 的。&lt;/li>
&lt;li>&lt;strong>Tolerating（可容忍）&lt;/strong>：应用响应时间大于 T，但同时小于或等于 4T。假设应用设定的 T 值为 1s，则 4 * 1 = 4 秒极为应用响应时间的容忍上限。&lt;/li>
&lt;li>&lt;strong>Frustrated（烦躁期）&lt;/strong>：应用响应时间大于 4T。&lt;/li>
&lt;/ul>
&lt;h3 id="公式">公式&lt;/h3>
&lt;p>&lt;!-- raw HTML omitted -->Apdex&lt;!-- raw HTML omitted -->t&lt;!-- raw HTML omitted --> = (Satisfied Count + Tolerating Count / 2) / Total Samples&lt;!-- raw HTML omitted -->&lt;/p></description></item><item><title>申请以及集成 Stripe 的 Alipay 支付方案</title><link>https://blog.hackerpie.com/posts/archive/shen-qing-yi-ji-ji-cheng-stripe-de-alipay-zhi-fu-fang-an/</link><pubDate>Sat, 28 Mar 2015 12:12:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shen-qing-yi-ji-ji-cheng-stripe-de-alipay-zhi-fu-fang-an/</guid><description>&lt;p>        最近在一个项目需要支持人民币支付，并且客户要求希望能够收完款后的结算是用美元，所以就想到了去年 Stripe 宣布已经跟支付宝达成合作意向，所以经过一番咨询跟集成，终于把 Stripe 集成进来，并且启用了支付宝收款。这篇文章介绍功能申请以及集成的完整过程。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="功能申请">功能申请&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://dashboard.stripe.com/register">注册 Stripe 账号&lt;/a>；&lt;/li>
&lt;li>加入 &lt;a href="https://stripe.com/alipay">beta 用户组&lt;/a>，电子邮箱跟注册的 Stripe 账号保持一致；&lt;/li>
&lt;li>联系 Stripe 员工&lt;br>
发送邮件到 &lt;a href="mailto:support@stripe.com">support@stripe.com&lt;/a>，声明你需要在你的 Stripe 账号中启用 Alipay 的支付功能，并且提供你的 Stripe 账号。然后，等待回复就是，一般当天都能收到回复的。&lt;/li>
&lt;/ol>
&lt;h2 id="集成">集成&lt;/h2>
&lt;h3 id="0-时序图可结合后边代码一起理解">0. 时序图(可结合后边代码一起理解)&lt;/h3>
&lt;p>

 &lt;img src="https://blog.hackerpie.com/images/medias/stripe_checkout_flow.png" alt="Stripe 支付流程">
&lt;/p>
&lt;h3 id="1-引入-stripejs-以及初始化脚本">1. 引入 stripe.js 以及初始化脚本&lt;/h3>
&lt;p>假设支付页面上有个开始支付按钮，其 html 代码为:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">button&lt;/span> id=&lt;span style="font-style:italic">&amp;#39;pay&amp;#39;&lt;/span>&amp;gt;支付&amp;lt;/&lt;span style="font-weight:bold">button&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>请在 html 代码里合适的地方（比如&lt;code>&amp;lt;body&amp;gt;&lt;/code>标签的底部）加载 stripe.js：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">script&lt;/span> src=&lt;span style="font-style:italic">&amp;#34;https://checkout.stripe.com/checkout.js&amp;#34;&lt;/span>&amp;gt;&amp;lt;/&lt;span style="font-weight:bold">script&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在脚本中初始化 stripe.js，并且注册支付按钮的事件监听函数：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>$(&lt;span style="font-weight:bold">function&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">var&lt;/span> stripeHandler = StripeCheckout.configure({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key: &lt;span style="font-style:italic">&amp;#39;pk_test_xxxxxxxxxxxxxxxxxxxxxxxx&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 可以查看 https://dashboard.stripe.com/account/apikeys
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> image: &lt;span style="font-style:italic">&amp;#39;https://placehold.it/200x200&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 显示在支付对话框的图片，可自己指定
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> alipay: &lt;span style="font-weight:bold">true&lt;/span>, &lt;span style="font-style:italic">// 启用支付宝支付
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> token: &lt;span style="font-weight:bold">function&lt;/span>(token){ &lt;span style="font-style:italic">// 用户填写完资料并且 Stripe 校验成功后的回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// 此时应该提交 token.id 到后台，比如 http://example.com/orders/1?stripeToken={token.id}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> $(&lt;span style="font-style:italic">&amp;#39;#pay&amp;#39;&lt;/span>).click(&lt;span style="font-weight:bold">function&lt;/span>(){
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stripeHandler.open({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name: &lt;span style="font-style:italic">&amp;#39;Business Name&amp;#39;&lt;/span>, &lt;span style="font-style:italic">// 收款方或商家名称，比如 Beansmile
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> description: &lt;span style="font-style:italic">&amp;#34;商品描述内容&amp;#34;&lt;/span>, &lt;span style="font-style:italic">// 待支付商品的描述
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> amount: 50 * 100, &lt;span style="font-style:italic">// 支付金额，单位是“分”
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> opened: &lt;span style="font-weight:bold">function&lt;/span>(){ &lt;span style="font-style:italic">// 支付对话框打开后的回调函数
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> &lt;span style="font-style:italic">// Do something
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> });
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>});
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-通过-token-请求收款">2. 通过 token 请求收款&lt;/h3>
&lt;p>服务器端是 Ruby on Rails 实现，所以在 Gemfile 中引入 Stripe 官方的 Ruby SDK(具体配置方法请自行查阅其 README)：&lt;/p></description></item><item><title>How do I fix Passenger application startup problem</title><link>https://blog.hackerpie.com/posts/archive/how-do-i-fix-passenger-application-startup-problem/</link><pubDate>Sat, 10 Jan 2015 01:54:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/how-do-i-fix-passenger-application-startup-problem/</guid><description>&lt;p>Recent days I was working on deploying one of my Rails project on a complete new VPS. I had operated according to my experience for deploying sites before, but at the last step, after I have deployed the site, it always raised error message &amp;ldquo;An error occurred while starting up the preloader: it did not write a startup response in time.&amp;rdquo; when I try to visit the site. But, thanks to much hard work and retry, I found the source of the problem and finally fix it.&lt;/p></description></item><item><title>在 coding.net 上部署 Jekyll 博客</title><link>https://blog.hackerpie.com/posts/archive/zai-coding-dot-netshang-bu-shu-jekyllbo-ke/</link><pubDate>Sat, 20 Dec 2014 12:59:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zai-coding-dot-netshang-bu-shu-jekyllbo-ke/</guid><description>&lt;p>自从 &lt;a href="https://ruby-china.org/topics/22858">coding 推出 PaaS 演示平台以及开放自定义域名&lt;/a>之后，很多人开始尝试在 coding 上部署自己的博客，其中就有 &lt;a href="http://jekyllrb.com/">jekyll&lt;/a>，coding 上就有官方推荐的 &lt;a href="https://coding.net/u/chenwj233/p/jekyll-demo/git">jekyll-demo&lt;/a>。但是因为这个 Demo 的 README 文档中只是简单介绍配置步骤而已，没有详细介绍原理以及灵活配置的地方，我在参照着迁移 jekyll 博客的过程中也遇到一些问题。现在写下文章，希望能够把原理理清楚。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>**声明：**这篇文章主要是对原来的 Demo 的几个主要思路做一个补充说明，而并非 coding 演示平台使用操作的详细教程，所以在有些细节上不一定覆盖到，建议最终的部署代码需要以官方推荐的 repo 里的代码为主。&lt;/p>
&lt;h2 id="基本原理">基本原理&lt;/h2>
&lt;p>因为 Coding 提供的演示平台是通用的 PaaS 平台，并非类似 Github 或者 Gitcafe 的 Pages 服务，所以 jekyll 部署到演示平台需要解决三个问题：&lt;/p>
&lt;p>&lt;strong>1. 运行问题&lt;/strong>，blog 需要以常规 Web 程序的方式运行；&lt;br>
&lt;strong>2. 启动脚本&lt;/strong>，部署完成后自动启动服务器；&lt;br>
&lt;strong>3. 自动更新&lt;/strong>，blog 内容更新 push 后能够自动生成新的页面。&lt;/p>
&lt;p>第一个问题我们可以通过 &lt;a href="https://github.com/adaoraul/rack-jekyll">rack-jekyll&lt;/a> 解决；第二个问题通过 Coding 约定的 &lt;code>Procfile&lt;/code> 文件解决；第三个问题我们通过 Coding 的 &lt;a href="https://coding.net/help/about_git/what_is_web_hook">Webhook&lt;/a> 结合脚本解决。&lt;/p>
&lt;h3 id="1-将-jekyll-博客变为一个在线运行的-rack-程序">1. 将 Jekyll 博客变为一个在线运行的 Rack 程序&lt;/h3>
&lt;p>Jekyll 原本是一个用于生成静态博客站点的框架，但是为了能够在 coding 演示平台上直接运行 Jekyll 博客，我们需要一个能够在 &lt;a href="http://unicorn.bogomips.org/">Unicorn&lt;/a> 服务器上运行 Jekyll 的方法。通过原来 coding 提供的 Demo，找到了一个叫 &lt;a href="https://github.com/adaoraul/rack-jekyll">rack-jekyll&lt;/a> 的工具。&lt;/p></description></item><item><title>RAILS中利用YAML文件完成数据对接</title><link>https://blog.hackerpie.com/posts/archive/railszhong-jie-he-yamlwen-jian-wan-cheng-shu-ju-dui-jie/</link><pubDate>Wed, 12 Nov 2014 20:15:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/railszhong-jie-he-yamlwen-jian-wan-cheng-shu-ju-dui-jie/</guid><description>&lt;p>最近在做的Ruby on Rails项目中，需要将远程数据库中的数据对接到项目数据库中，但是远程的数据不仅数据表名跟字段命名奇葩，数据结构本身跟项目数据结构出入比较大，在数据导入过程中代码经历了几次重构，最后使用了YAML文件解决了基本数据&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>对接的问题。在此写一篇博文，我会尽量重现一路过来的代码变更，算是分享一下我的思考过程，也算是祭奠一下自己的苦逼岁月。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="假设以及数据结构预览">假设以及数据结构预览&lt;/h3>
&lt;p>因为远程数据库服务器为Oracle Server，我在项目中使用到了&lt;a href="http://sequel.jeremyevans.net/">Sequel&lt;/a>这个gem用于连接数据库以及数据查询，因为数据库连接的内容不是本文的重点，故后续代码直接用&lt;code>remote_database&lt;/code>表示数据库连接，而根据&lt;a href="http://sequel.jeremyevans.net/rdoc/files/doc/dataset_basics_rdoc.html">Sequel的用法&lt;/a>，我们可以直接使用&lt;code>remote_database[table_name]&lt;/code>连接到具体的表。&lt;/p>
&lt;p>本次需要从远程数据库中导入的基本数据主要有学生信息表（包含班级名称）、老师信息表以及专业信息表，相应地，项目中（以下称为“本地”）也已经创建好了对应的model。其中学生信息表的表名以及部分数据字段的从本地到远程的映射关系如表所示：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>表名或字段名&lt;/th>
 &lt;th>本地&lt;/th>
 &lt;th>远程&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>表名&lt;/td>
 &lt;td>students&lt;/td>
 &lt;td>XSJBXX&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>姓名&lt;/td>
 &lt;td>name&lt;/td>
 &lt;td>XM&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>学号&lt;/td>
 &lt;td>number&lt;/td>
 &lt;td>XH&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>年级&lt;/td>
 &lt;td>grade&lt;/td>
 &lt;td>NJ&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>班级&lt;/td>
 &lt;td>belongs_to :klass    &lt;/td>
 &lt;td>BJMC(班级名称)&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;p>老师信息表的表名以及部分数据字段的映射关系为：&lt;/p>
&lt;table>
 &lt;thead>
 &lt;tr>
 &lt;th>表名或字段名&lt;/th>
 &lt;th>本地&lt;/th>
 &lt;th>远程&lt;/th>
 &lt;/tr>
 &lt;/thead>
 &lt;tbody>
 &lt;tr>
 &lt;td>表名&lt;/td>
 &lt;td>teachers&lt;/td>
 &lt;td>JZGJBXX&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>姓名&lt;/td>
 &lt;td>name&lt;/td>
 &lt;td>XM&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>职称&lt;/td>
 &lt;td>title&lt;/td>
 &lt;td>ZC&lt;/td>
 &lt;/tr>
 &lt;tr>
 &lt;td>证件号码&lt;/td>
 &lt;td>id_number&lt;/td>
 &lt;td>ZJHM&lt;/td>
 &lt;/tr>
 &lt;/tbody>
&lt;/table>
&lt;h3 id="数据对接第一版属性方法显式赋值">数据对接第一版：属性方法显式赋值&lt;/h3>
&lt;p>第一个导入的数据表是学生的信息表，在最开始的时候，因为只需要考虑一张单独的表，所以代码写得简单粗暴，基本过程就是：根据需要的信息，查询对应的远程数据字段，然后使用属性方法赋值，最后保存接入的数据。对接方法的部分相关代码示例（为了方便阅读以及保护项目敏感信息，本文对项目中原有代码进行了缩减以及修改）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># app/models/student.rb&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Student&lt;/span> &amp;lt; ActiveRecord::Base
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> import_data_from_remote
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students = remote_database[&lt;span style="font-style:italic">:xsjbxx&lt;/span>].page(page)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> remote_students.each &lt;span style="font-weight:bold">do&lt;/span> |remote_student|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name, number, grade = *remote_student.values_at(&lt;span style="font-style:italic">:xm&lt;/span>, &lt;span style="font-style:italic">:xh&lt;/span>, &lt;span style="font-style:italic">:nj&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_name = remote_student[&lt;span style="font-style:italic">:bjmc&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass = Klass.find_or_create_by name: class_name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> student = Student.find_by_create_by name: name,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">number&lt;/span>: number,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">grade&lt;/span>: grade,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">klass&lt;/span>: klass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>上面的代码，呃，中规中矩，基本体现了各取所需的指导思想，但是总觉得怎么有点不好呢？&lt;/p></description></item><item><title>sublime text 2基于语法的配置文件</title><link>https://blog.hackerpie.com/posts/archive/sublime-text-2ji-yu-yu-fa-de-pei-zhi-wen-jian/</link><pubDate>Sun, 03 Aug 2014 23:13:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sublime-text-2ji-yu-yu-fa-de-pei-zhi-wen-jian/</guid><description>&lt;p>最近在学习Python编程语言，但是遇到一个小小的问题，就是原来Ruby的编码规范是用2个空格缩进的，所以以前在Sublime的全局用户配置中设置了&lt;code>&amp;quot;tab_size&amp;quot;: 2&lt;/code>，所以在编辑Python文件的时候就每次都要从菜单中设置&lt;code>tab_size&lt;/code>的大小为4。后来经过搜索，发现Sublime Text 2实际上是支持语法特定的配置的，具体的步骤是：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;ol>
&lt;li>
&lt;p>先打开一个Python代码文件，或者是设置当前文件的语法为&amp;quot;Python&amp;quot;；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击菜单栏中的“Sublime Text 2 -&amp;gt; Preferences -&amp;gt; Settings - More -&amp;gt; Syntax Specific - User”；&lt;/p>
&lt;/li>
&lt;li>
&lt;p>可以看到打开了一个名字为&amp;quot;Python.sublime-setting&amp;quot;的文件，如果打开的文件的名字不是Python，请回头检查第一步。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在打开的特定语言的配置文件中，直接设置:&lt;/p>
&lt;pre tabindex="0">&lt;code>{ &amp;#34;tab_size&amp;#34;: 4, &amp;#34;translate_tabs_to_spaces&amp;#34;: true }
&lt;/code>&lt;/pre>&lt;p>以上的设置会默认覆盖全局配置。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>以上步骤参考自&lt;a href="http://lukecafe.com/2013/03/daily-tips-sublime-text2-setting-and-ipa-generation/">今日技巧：Sublime Text 2语法缩进配置和ipa文件生成&lt;/a>。&lt;/p></description></item><item><title>Spree 2.3.0已经发布</title><link>https://blog.hackerpie.com/posts/archive/spree-2-dot-3-0yi-jing-fa-bu/</link><pubDate>Mon, 28 Jul 2014 21:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/spree-2-dot-3-0yi-jing-fa-bu/</guid><description>&lt;p>**声明：**原文来自Spree官方博客&lt;a href="http://spreecommerce.com/blog/spree-2-3-released">Spree 2.3.0 Released&lt;/a>，原文发布日期是2014-06-30，本文仅作翻译。&lt;/p>
&lt;p>&lt;strong>简要介绍：&lt;/strong>&lt;a href="http://spreecommerce.com/">Spree&lt;/a>是一个基于&lt;a href="http://rubyonrails.org/">Ruby on Rails&lt;/a>开发的开源在线商城框架，提供了从商品展示购买、下单支付到库存管理以及订单管理等一系列基本功能，并且支持通过第三方扩展的形式定制或者扩展框架的功能，最新版本的Spree已经支持最新的Rails版本。&lt;/p>
&lt;p>Spree 2.3的最新更改已经加入对Rails 4.1的支持，提供了更好的配置项的存储，更好的针对多店铺的支持，以及更好的游客追踪。Spree 2.3的发布，有赖于总的97位贡献者以及他们总的700多个的commit记录。现在，我们非常兴奋地宣布：Spree 2.3发布了！&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h3 id="rails-41-的支持">Rails 4.1 的支持&lt;/h3>
&lt;p>现在，Rails 4.1已经得到了Spree 2.3的支持。如果你希望基于Rails 4.1进行开发，那么Spree 2.3就是特为你准备的发布版。&lt;/p>
&lt;h3 id="基于序列化记录的配置项">基于序列化记录的配置项&lt;/h3>
&lt;p>现在，所有的配置项存储在一个记录上，而不是存储在&lt;code>spree_preferences&lt;/code>表中。这意味着，为了获取一个配置项，比如价格的计算器配置，就会触发一个数据库查询，所查询的那一行记录有一个包含了所有配置信息的命名为&lt;code>preferences&lt;/code>的列。&lt;/p>
&lt;p>而在此之前，对于每一个配置记录本身，可能都会有一个单独的数据库调用，而在查询到所请求的配置项之后，还是有可能会有任意数目的数据库调用产生。而现在，我们总的只需要调用一次，这意味着程序本身将会有一些速度上的提升。&lt;/p>
&lt;h3 id="更好的多店铺支持">更好的多店铺支持&lt;/h3>
&lt;p>我们已经添加了一个名为&lt;code>Spree::Store&lt;/code>的model，用于支持基本的多店铺/多域名的站点。其在&lt;code>spree-multi-domain&lt;/code>这个扩展的基础上提供了针对多店铺/多域名的基本框架。一些原有的配置项被转移到了这个model上，以此实现根据具体的店铺提供不同配置值：&lt;/p>
&lt;ul>
&lt;li>&lt;code>Spree::Config[:site_name]&lt;/code> 迁移到了 &lt;code>name&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:site_url]&lt;/code> 迁移到了 &lt;code>url&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_meta_description]&lt;/code> 迁移到了 &lt;code>meta_description&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_meta_keywords]&lt;/code> 迁移到了 &lt;code>meta_keywords&lt;/code>&lt;/li>
&lt;li>&lt;code>Spree::Config[:default_seo_title]&lt;/code> 迁移到了 &lt;code>seo_title&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>一个数据库迁移文件将会负责把这些原有的配置项转移到一个新的默认的store实例上。&lt;/p>
&lt;p>一个新的名为&lt;code>ControllerHelpers::Store&lt;/code>的Concern提供了一个&lt;code>current_store&lt;/code>helper，可以在请求的域名的基础上，通过它获取当前店铺。&lt;/p>
&lt;h3 id="更好的游客追踪">更好的游客追踪&lt;/h3>
&lt;p>现在，我们用了一个签名的cookie在浏览器中存储游客的唯一的token。通过它允许关闭了浏览器的顾客可以在再次访问时继续完成他们的购物流程。更重要的是，这也帮助作为商店主人的你方便地识别游客的订单。由于我们在访客来访时都会设置&lt;code>cookies.signed[:guest_token]&lt;/code>，所以除了订单，或许你可以把cookie用于其他用途。&lt;/p>
&lt;p>举个实际例子，如果游客需要收藏一个商品，你可以创建一个用于记录收藏记录的model，然后把&lt;code>cookies.signed[:guest_token]&lt;/code>赋值给这个model中的&lt;code>token&lt;/code>字段。这将有助于你分析当前用户在此之前的订单以及收藏记录，这对于商品推荐将是非常有用的。&lt;/p>
&lt;h3 id="总结">总结&lt;/h3>
&lt;p>你可以从&lt;a href="https://github.com/spree/spree/releases/tag/v2.3.0">Github&lt;/a>上浏览更详细的变更列表。&lt;/p></description></item><item><title>Run a shell script auto-matically when entering/cd a directory</title><link>https://blog.hackerpie.com/posts/archive/run-a-shell-script-auto-matically-when-entering-a-directory/</link><pubDate>Sun, 04 May 2014 10:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/run-a-shell-script-auto-matically-when-entering-a-directory/</guid><description>&lt;p>I don&amp;rsquo;t know if it is common that you need to run some shell scripts which are used under only some directories, such as, one of your Rails projects.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Today I find that I always need to run &lt;code>rspec&lt;/code> command with a &lt;code>SPEC&lt;/code> option, which specifies spec files to be run. In short, everytime I should type the following command in my terminal:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>rake spec SPEC=spec/lib/
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>It is convenient to run this command as an &lt;strong>alias&lt;/strong>, but I don&amp;rsquo;t want to write this alias into the &lt;code>~/.bash_profile&lt;/code>, because it should be available under the current directory only. But how?&lt;/p></description></item><item><title>Gemfile指定gem来源的四种方式</title><link>https://blog.hackerpie.com/posts/archive/gemfilezhi-ding-gemlai-yuan-de-si-chong-fang-shi/</link><pubDate>Thu, 03 Apr 2014 00:30:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/gemfilezhi-ding-gemlai-yuan-de-si-chong-fang-shi/</guid><description>&lt;p>Gemfile的作用无非就是告诉bundler你的项目具体都需要哪些gem，这些gem都需要哪些版本，以及从哪获取这些gem。其实你的问题应该就是跟第三点有关，总的来说，gem的来源可以有四种：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h4 id="1-从镜像源安装">1. 从镜像源安装&lt;/h4>
&lt;p>这个是最直接的，通过这种方式指定的gem，bundler会从文件开头的&lt;code>source&lt;/code>中去查找这个gem：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>source &lt;span style="font-style:italic">&amp;#39;https://rubygems.org&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;rails&amp;#39;&lt;/span> &lt;span style="font-style:italic"># this gem will be installed from https://rubygems.org&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="2-从git代码库安装">2. 从git代码库安装&lt;/h4>
&lt;p>通过在&lt;code>gem&lt;/code>方法（Gemfile实际上就是一个ruby的代码文件）中指定&lt;code>git&lt;/code>参数，可以使bundler从指定的远程代码库上拉取代码，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># nokogiri will be installed from git://github.com/tenderlove/nokogiri.git&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;nokogiri&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:git&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;git://github.com/tenderlove/nokogiri.git&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="3-从github安装">3. 从github安装&lt;/h4>
&lt;p>上面第2种方法只是针对所有合法的git代码库（不仅仅是github，也可以是你自己的一个git服务器上一个代码库）而言，而如果你所需要的库来自于github，则可以通过更方便的&lt;code>github&lt;/code>参数实现目标:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;nokogiri&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:github&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;tenderlove/nokogiri&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>可以看到，只要指定了&lt;code>author/repo_name&lt;/code>的形式，bundler就能自动从github上获取你所需要的gem了。
&lt;strong>注意&lt;/strong>: 第2跟第3种方式还都可以通过&lt;code>branch&lt;/code>参数指定你所需要的代码分支，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;refinerycms&amp;#39;&lt;/span>, &lt;span style="font-style:italic">github&lt;/span>: &lt;span style="font-style:italic">&amp;#39;refinery/refinerycms&amp;#39;&lt;/span>, &lt;span style="font-style:italic">branch&lt;/span>: &lt;span style="font-style:italic">&amp;#39;master&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="4-从文件系统中安装">4. 从文件系统中安装&lt;/h4>
&lt;p>假如你有一个已经放在项目目录中（其实可以是任何地方）的gem，则可以通过&lt;code>path&lt;/code>参数指定所需的gem在文件系统中的位置，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#34;rails&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:path&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#34;vendor/rails&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>bundler将会根据path指定的路径去查找并且安装gem。&lt;/p>
&lt;h3 id="最后说一下">最后说一下&lt;/h3>
&lt;p>最后顺便说下我的一点体会，一般像这种gem来自于项目目录下的情况，大多是因为项目中用到了一些提供扩展机制的框架，比如&lt;strong>Spree&lt;/strong>以及&lt;strong>Refinery&lt;/strong>，这两者生成的扩展或者子Engine都是以gem的形式放在vendor或者lib目录下，然后从Gemfile里边进行指定，比如我的一个项目中的一个实例：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>gem &lt;span style="font-style:italic">&amp;#39;refinerycms-factories&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:path&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;vendor/extensions&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>refinerycms-factories是我用Refinery的generator生成的一个子engine，默认放在&lt;code>verdor/extensions&lt;/code>目录下。&lt;/p>
&lt;p>另一种可能比较常见的情况就是你用到了某个可能不再维护的gem，由于对源代码的改动较大，所以你干脆把这个gem的源代码下载到本地项目目录下，然后直接进行修改，最后通过&lt;code>path&lt;/code>去安装。&lt;/p>
&lt;h3 id="参考资料">参考资料&lt;/h3>
&lt;p>关于Gemfiile的更多资料，请自行猛戳：
&lt;a href="http://bundler.io/v1.5/gemfile.html">Bundler homepage&lt;/a>
&lt;a href="http://bundler.io/v1.5/man/gemfile.5.html">Gemfile manual page&lt;/a>&lt;/p></description></item><item><title>Ruby中Hash的7个日常使用范例</title><link>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</link><pubDate>Tue, 25 Mar 2014 20:05:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</guid><description>&lt;p>此文翻译自&lt;a href="http://blog.8thcolor.com/en/2014/03/7-daily-use-cases-of-ruby-hash/?utm_source=rubyweekly&amp;amp;utm_medium=email#json-to-hash">7 daily use cases of Ruby Hash&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>每一天，你都需要跟Hash相处。创建一个新的Hash或者是通过它的某一个键去检索其中的元素这样的工作，都是常见也是非常简单的。但是当你需要合并两个嵌套的Hash或者是从某一个Hash里边过滤某些键，你可能需要考虑得多一点。通过完整的&lt;a href="http://ruby-doc.org/">文档&lt;/a>，你可以找到对Hash中的每一个方法的充分解释。但是由于文档不是面向应用场景的，你可能没法很快找到你的解决方案。在下面，我分享了我日常中经常遇到的Hash中的7个常用场景，希望它们对你有用。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="1-如何将一个json转换为一个hash">1. 如何将一个JSON转换为一个Hash？&lt;/h2>
&lt;p>假设你刚刚接收到一个用JSON表示的Twitter账号的资料信息：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-json" data-lang="json">&lt;span style="display:flex;">&lt;span>&lt;span style="">data&lt;/span> &lt;span style="">=&lt;/span> &lt;span style="">&amp;#39;&lt;/span>{
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Aaron Patterson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;screen_name&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;tenderlove&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">&amp;#34;location&amp;#34;&lt;/span>: &lt;span style="font-style:italic">&amp;#34;Seattle, WA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}&lt;span style="">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你希望能够将它转化为一个Hash,这样会更方便你进行对数据的操作：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>profile = JSON.parse(data)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 在IRB中的输出结果：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;name&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Aaron Patterson&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;screen_name&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;tenderlove&amp;#34;&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;#34;location&amp;#34;&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#34;Seattle, WA&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-parse">JSON#parse&lt;/a>&lt;/p>
&lt;h2 id="2-如何将一个hash转换为一个json">2. 如何将一个Hash转换为一个JSON？&lt;/h2>
&lt;p>在你的web应用程序中，你需要追踪当前星期每一天新注册用户的数量：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>signups_of_the_week = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">monday&lt;/span>: 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">tuesday&lt;/span>: 3,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">wednesday&lt;/span>: 4,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">thursday&lt;/span>: 20,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">friday&lt;/span>: 5,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">saturday&lt;/span>: 2,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">sunday&lt;/span>: 5
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>你可以通过API的方式把它们以JSON格式提供给客户端：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;json&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>signups_of_the_week.to_json
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 在IRB中的输出结果：**&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>=&amp;gt; &lt;span style="font-style:italic">&amp;#34;{&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">monday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:2,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">tuesday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:3,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">wednesday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:4,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">thursday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:20,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">friday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:5,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">saturday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:2,&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">sunday&lt;/span>&lt;span style="font-weight:bold;font-style:italic">\&amp;#34;&lt;/span>&lt;span style="font-style:italic">:5}&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>查看文档：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-generate">JSON#generate&lt;/a>
边注：&lt;a href="http://www.ruby-doc.org/stdlib-2.1.0/libdoc/json/rdoc/JSON.html#method-i-pretty_generate">JSON#pretty_generate&lt;/a>对于更好的打印以及调试非常有用。&lt;/p></description></item><item><title>注意Rake Task中invoke方法跟execute方法的不同</title><link>https://blog.hackerpie.com/posts/archive/zhu-yi-rake-taskzhong-invokegen-executefang-fa-de-bu-tong/</link><pubDate>Fri, 21 Mar 2014 01:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhu-yi-rake-taskzhong-invokegen-executefang-fa-de-bu-tong/</guid><description>&lt;p>平时如果跟Rake Task有过接触的同学都会知道，当我们需要在一个Task里边调用另一个Task的时候，我们可以使用&lt;code>Rake::Task['task_name'].invoke&lt;/code>的方式。但是在今天的实践中，才知道&lt;code>Rake::Task#invoke&lt;/code>在默认情况下在整个运行过程中将只会被调用一次而已。话不多说，动手演示：&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>准备一个&lt;strong>say hello&lt;/strong>的task，代码：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># lib/tasks/demo.rake&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello&amp;#39; string&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> puts &lt;span style="font-style:italic">&amp;#34;Hello, World!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接下来在命令行中执行rake task:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>假设我们一个循环，需要调用上边的task共5次，那么我们可能会这么写：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>namespace &lt;span style="font-style:italic">:demo&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># ....&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> desc &lt;span style="font-style:italic">&amp;#34;Print &amp;#39;Hello, World!&amp;#39; five times&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> task &lt;span style="font-style:italic">:say_five_hello&lt;/span> &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> 5.times &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Rake::Task[&lt;span style="font-style:italic">&amp;#39;demo:say_hello&amp;#39;&lt;/span>].invoke
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ok, 让我们尝试着运行这个&lt;code>say_five_hello&lt;/code>的task，是不是真的会打印5次&amp;rsquo;Hello, World!&amp;lsquo;呢?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>$ rake demo:say_five_hello
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>=&amp;gt; Hello, World!
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>结果就是，&amp;lsquo;Hello, World!&amp;lsquo;只打印了一次，也就是说，我们的&lt;code>Rake::Task['demo:say_hello']&lt;/code>只被运行了一次。&lt;/p>
&lt;p>经过搜索，从StackOverflow找到了这个问题的相关描述，详见：&lt;a href="http://stackoverflow.com/a/12948485">How do I execute Rake tasks with arguments multiple times?&lt;/a>&lt;/p></description></item><item><title>属性方法</title><link>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</link><pubDate>Wed, 12 Mar 2014 20:58:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_attribute_methods/">Reading Rails - Attribute Methods&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>在我们&lt;a href="https://blog.hackerpie.com/blog/2014/03/07/zhui-zong-bian-geng/">上一篇的探讨&lt;/a>中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似&lt;code>attribute_method_suffix&lt;/code>这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似&lt;code>name&lt;/code>这样的模型属性以及对应生成的类似&lt;code>name_changed?&lt;/code>这样的方法的。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="声明declarations">声明（Declarations）&lt;/h3>
&lt;p>属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，&lt;code>attribute_method_suffix&lt;/code>后缀式方法是一个为每个属性都定义了一个helper方法的方法。在&lt;a href="https://blog.hackerpie.com/blog/2014/03/07/zhui-zong-bian-geng/">之前的讨论&lt;/a>中，ActiveModel使用这种方式为您的每一个属性都定义了一个&lt;code>_changed?&lt;/code>方法(&lt;strong>提示&lt;/strong>： 命令行中键入&lt;code>qw activemodel&lt;/code>查看代码)：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Dirty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ActiveModel::AttributeMethods
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_suffix &lt;span style="font-style:italic">&amp;#39;_changed?&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_change&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_will_change!&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_was&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>让我们打开ActiveModel库中的&lt;code>attribute_methods.rb&lt;/code>文件，并且看一下到底发生了什么事情。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_method_suffix(*suffixes)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self.attribute_method_matchers += suffixes.map! &lt;span style="font-weight:bold">do&lt;/span> |suffix|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AttributeMethodMatcher.new &lt;span style="font-style:italic">suffix&lt;/span>: suffix
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当你调用&lt;code>attribute_method_suffix&lt;/code>方法的时候，每一个后缀都通过&lt;code>map!&lt;/code>方法转换为一个&lt;code>AttributeMethodMatcher&lt;/code>对象。这些对象会被存储在&lt;code>attribute_method_matchers&lt;/code>中。如果你重新看一下这个module的顶部，你会发现&lt;code>attribute_method_matchers&lt;/code>是在每一个包含此module的类中使用&lt;code>class_attribute&lt;/code>定义的方法：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">AttributeMethods&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_attribute &lt;span style="font-style:italic">:attribute_aliases&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:attribute_method_matchers&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">instance_writer&lt;/span>: &lt;span style="">false&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>class_attribute&lt;/code>方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Person&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> class_attribute &lt;span style="font-style:italic">:database&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">Employee&lt;/span> &amp;lt; Person
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Person.database = Sql.new(&lt;span style="font-style:italic">:host&lt;/span>=&amp;gt;&lt;span style="font-style:italic">&amp;#39;localhost&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Employee.database &lt;span style="font-style:italic">#=&amp;gt; &amp;lt;Sql:host=&amp;#39;localhost&amp;#39;&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Ruby中并没有&lt;code>class_attribute&lt;/code>的内置实现，它是在ActiveSupport(&lt;strong>提示&lt;/strong>:命令行中键入&lt;code>qw activesupport&lt;/code>查看代码)中定义的方法。如果你对此比较好奇，可以简单看下&lt;code>attribute.rb&lt;/code>&lt;/p></description></item><item><title>跟踪model中属性（值）的变更</title><link>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</link><pubDate>Fri, 07 Mar 2014 13:02:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_change_tracking/">Reading Rails - Change Tracking&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>我们今天来看看Rails是如何追踪model里边属性的变更的。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>person = Person.find(8)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name = &lt;span style="font-style:italic">&amp;#34;Mortimer&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name_changed? &lt;span style="font-style:italic">#=&amp;gt; true&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.name_was &lt;span style="font-style:italic">#=&amp;gt; &amp;#34;Horton&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.changes &lt;span style="font-style:italic">#=&amp;gt; {&amp;#34;name&amp;#34;=&amp;gt;[&amp;#34;Horton&amp;#34;,&amp;#34;Mortimer&amp;#34;]}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.save!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>person.changes &lt;span style="font-style:italic">#=&amp;gt; {}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>name_changed?&lt;/code>方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="activemodel">ActiveModel&lt;/h3>
&lt;p>当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（&lt;strong>提示&lt;/strong>： 命令行中键入&lt;code>qw activemodel&lt;/code>查看代码）定义了没有与数据库捆绑的逻辑。我们将从&lt;code>dirty.rb&lt;/code>文件开始。在这个模块最开始的地方，代码调用了&lt;code>attribute_method_suffix&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">module&lt;/span> &lt;span style="font-weight:bold">Dirty&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">extend&lt;/span> ActiveSupport::Concern
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">include&lt;/span> ActiveModel::AttributeMethods
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> included &lt;span style="font-weight:bold">do&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> attribute_method_suffix &lt;span style="font-style:italic">&amp;#39;_changed?&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_change&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_will_change!&amp;#39;&lt;/span>, &lt;span style="font-style:italic">&amp;#39;_was&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>attribute_method_suffix&lt;/code>定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似&lt;code>_changed?&lt;/code>后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到&lt;code>def attribute_changed?&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> attribute_changed?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> changed_attributes.include?(&lt;span style="">attr&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似&lt;code>name_changed?&lt;/code>的方法时，Rails将会把&lt;code>&amp;quot;name&amp;quot;&lt;/code>作为参数&lt;code>attr&lt;/code>传给上述方法。往回看一点点，你会发现&lt;code>changed_attributes&lt;/code>只是一个包含了从属性名到旧的属性值的映射的&lt;code>Hash&lt;/code>而已：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># Returns a hash of the attributes with unsaved changes indicating their original&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># values like &amp;lt;tt&amp;gt;attr =&amp;gt; original value&amp;lt;/tt&amp;gt;.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic">#&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.name # =&amp;gt; &amp;#34;bob&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.name = &amp;#39;robert&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-style:italic"># person.changed_attributes # =&amp;gt; {&amp;#34;name&amp;#34; =&amp;gt; &amp;#34;bob&amp;#34;}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> changed_attributes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @changed_attributes ||= {}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>在Ruby中，如果你之前都没有见过&lt;code>||=&lt;/code>操作，那么你可能需要了解这其实是一个用于初始化变量值的技巧。当它第一次被访问的时候，变量的值是&lt;code>nil&lt;/code>，所以它返回了一个空的&lt;code>Hash&lt;/code>并且用其初始化&lt;code>@changed_attributes&lt;/code>。当它再一次被访问的时候，&lt;code>@changed_attributes&lt;/code>已经被赋值过了。那么现在我们可以回答我们的第一个问题了，&lt;code>name_changed?&lt;/code>方法被转发到&lt;code>attribute_changed?&lt;/code>方法，而后者会在&lt;code>changed_attributes&lt;/code>中查找特定的值。&lt;/p></description></item><item><title>解读Rails - 处理异常</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</link><pubDate>Wed, 05 Mar 2014 13:53:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</guid><description>&lt;p>此文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_handling_exceptions/">Reading Rails - Handling Exceptions&lt;/a>，限于本人水平，翻译不当之处，敬请指教！&lt;/p>
&lt;p>我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>Rails通过让你使用&lt;code>rescue_from&lt;/code>方法，让你在你的&lt;code>controller&lt;/code>里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">ApplicationController&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># Redirect users if they try to use disabled features.&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rescue_from FeatureDisabledError, InsufficientAccessError &lt;span style="font-weight:bold">do&lt;/span> |ex|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> flash[&lt;span style="font-style:italic">:alert&lt;/span>] = &lt;span style="font-style:italic">&amp;#34;Your account does not support &lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>ex.feature_name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> redirect_to &lt;span style="font-style:italic">&amp;#34;/pricing&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。&lt;/p>
&lt;p>如果需要跟着我的步骤走，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开每一个相关的代码库，或者直接从&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">github&lt;/a>查看源码即可。&lt;/p>
&lt;h3 id="定义处理器handlers">定义处理器(Handlers)&lt;/h3>
&lt;p>ActiveSupport包含了一个用于定义异常如何被处理的模块&lt;code>Rescuable&lt;/code>。第一个需要了解的方法就是&lt;code>rescue_from&lt;/code>。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（&lt;strong>提示&lt;/strong>：查看代码，请在命令行中输入&lt;code>qw activesupport&lt;/code>）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_from(*klasses, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options = klasses.extract_options!
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">unless&lt;/span> options.has_key?(&lt;span style="font-style:italic">:with&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> block_given?
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> options[&lt;span style="font-style:italic">:with&lt;/span>] = block
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>首先，&lt;code>*klasses&lt;/code>接收数量不定的异常类，所以你可以进行类似&lt;code>rescue_from(FeatureDisabledError, InsufficientAccessError)&lt;/code>这样的调用。它们将会被存放在一个数组里。&lt;/p>
&lt;p>接下来，请留意&lt;code>extract_options!&lt;/code>的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用&lt;code>:with&lt;/code>项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。&lt;/p>
&lt;p>接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> rescue_from(*klasses, &amp;amp;block)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key = &lt;span style="font-weight:bold">if&lt;/span> klass.is_a?(Class) &amp;amp;&amp;amp; klass &amp;lt;= Exception
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass.name
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">elsif&lt;/span> klass.is_a?(String)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> klass
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">#...&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这里你应该注意的是，Rails是如何判定&lt;code>klass&lt;/code>是不是继承自&lt;code>Exception&lt;/code>的。通常情况下，你可能会通过使用&lt;code>obj.is_a?(Exception)&lt;/code>来判断一个对象是不是某一个具体类型的实例，即使如此，&lt;code>klass&lt;/code>并不是&lt;code>Exception&lt;/code>，而只是&lt;code>Class&lt;/code>。那么我们又怎么找出它使哪一类呢？Ruby在&lt;code>Module&lt;/code>上定义了类似&lt;code>&amp;lt;=&lt;/code>这样的&lt;a href="http://ruby-doc.org/core-1.9.3/Module.html#method-i-3C">用于比较的操作符&lt;/a>。当操作符左边的对象是操作符右边对象的子类的时候，它会返回true。举个例子，&lt;code>ActiveRecord::RecordNotFound &amp;lt; Exception&lt;/code>返回true，而&lt;code>ActiveRecord::RecordNotFound &amp;gt; Exception&lt;/code>返回false。&lt;/p></description></item><item><title>解读Rails - 适配器模式</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</link><pubDate>Mon, 03 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</guid><description>&lt;p>本文翻译自&lt;a href="http://monkeyandcrow.com/blog/reading_rails_the_adapter_pattern/?utm_source=rubyweekly&amp;amp;utm_medium=email">Reading Rails - The Adapter Pattern&lt;/a>，限于本人水平有限，翻译不当之处，敬请指教！&lt;/p>
&lt;p>今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是&lt;a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式（Adapter Pattern）&lt;/a>。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>为了跟随本文的步骤，请使用&lt;a href="https://github.com/adamsanderson/qwandry">qwandry&lt;/a>打开相关的代码库，或者直接在&lt;a href="https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4">Github&lt;/a>上查看这些代码。&lt;/p>
&lt;h3 id="适配器模式">适配器模式&lt;/h3>
&lt;p>&lt;a href="http://en.wikipedia.org/wiki/Adapter_pattern">适配器模式&lt;/a>可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。&lt;/p>
&lt;p>当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_restaurant(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.nearest(&lt;span style="font-style:italic">:restaurant&lt;/span>, self.lat, self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>我们假设有一个针对&lt;code>locator&lt;/code>的接口，但是如果我们想要&lt;code>find_nearest_restaurant&lt;/code>能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_restaurant(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">if&lt;/span> locator.is_a? GeoFish
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.nearest(&lt;span style="font-style:italic">:restaurant&lt;/span>, self.lat, self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">elsif&lt;/span> locator.is_a? ActsAsFound
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.find_food(&lt;span style="font-style:italic">:lat&lt;/span> =&amp;gt; self.lat, &lt;span style="font-style:italic">:lon&lt;/span> =&amp;gt; self.lon)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">else&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">raise&lt;/span> NotImplementedError, &lt;span style="font-style:italic">&amp;#34;&lt;/span>&lt;span style="font-weight:bold;font-style:italic">#{&lt;/span>locator.class.name&lt;span style="font-weight:bold;font-style:italic">}&lt;/span>&lt;span style="font-style:italic"> is not supported.&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许&lt;code>find_nearest_restaurant&lt;/code>就是我们使用&lt;code>locator&lt;/code>的唯一场景。&lt;/p>
&lt;p>那假如你真的需要去支持一个新的&lt;code>locator&lt;/code>，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现&lt;code>find_nearest_hospital&lt;/code>方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。&lt;/p>
&lt;p>在这个例子中，我们可以为&lt;code>GeoFish&lt;/code>以及&lt;code>ActsAsFound&lt;/code>编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">def&lt;/span> find_nearest_hospital(locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> locator.find &lt;span style="font-style:italic">:type&lt;/span> =&amp;gt; &lt;span style="font-style:italic">:hospital&lt;/span>,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:lat&lt;/span> =&amp;gt; self.lat,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">:lon&lt;/span> =&amp;gt; self.lon
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>locator = GeoFishAdapter.new(geo_fish_locator)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>find_nearest_hospital(locator)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>特意假设的例子就到此为止，接下来让我们看看真实的代码。&lt;/p></description></item><item><title>解读Rails(系列翻译)</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-xi-lie-fan-yi/</link><pubDate>Sun, 02 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-xi-lie-fan-yi/</guid><description>&lt;p>解读Rails系列文章原文来自&lt;a href="http://monkeyandcrow.com/series/reading_rails/">Reading Rails&lt;/a>，我将尽我所能完成此系列所有文章的翻译。以下部分为原文系列对应翻译：&lt;/p>
&lt;p>在我们的工作中，我们的大部分时间都是在使用各种各样的工具，但是你知不知道它们是如何工作的呢？&lt;/p>
&lt;p>在这个系列里，我们通过阅读&lt;a href="http://rubyonrails.org/">Ruby on Rails&lt;/a>的源码去探索其内部的工作机制。我们将不仅仅只是学到与Rails有关的知识，我们也将见识到Ruby里边一些有趣的功能，以及一些有用的新技巧。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/03/jie-du-rails-gua-pei-qi-mo-shi/">解读Rails - 适配器模式&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 错误和验证器&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 验证机制是如何配置的&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - Concern&lt;/a>&lt;/li>
&lt;li>&lt;a href="">解读Rails - 更多的Migrations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2017/10/14/jie-du-rails-migrations/">解读Rails - Migrations&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/12/shu-xing-fang-fa/">解读Rails - 属性方法(Attribute Methods)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/07/zhui-zong-bian-geng/">解读Rails - 跟踪model中属性（值）的变更&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.hackerpie.com/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/">解读Rails - 处理异常&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>在Ruby中使用WebSocket</title><link>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</link><pubDate>Sat, 01 Mar 2014 21:31:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</guid><description>&lt;p>&lt;strong>声明&lt;/strong>: 此文翻译自&lt;a href="http://www.troikatech.com/blog/2014/02/26/websocket-webmachine/?utm_source=rubyweekly&amp;amp;utm_medium=email">WebSockets in Ruby&lt;/a>， 限于本人才疏学浅，其中有翻译不当之处，敬请指出，感激不尽！&lt;/p>
&lt;p>在我的主要工作中，需要构建一个一直占用相当大CPU时间片的数据系统。这个任务主要用于在地理编码以及local reference system(本地地理系统？)之间进行编码以及解码。举个例子，这个工作将帮助我们在系统中标记一条对应于街道上某个地点的记录，并且可以知道本地地理位置所对应的坐标。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>在第一次的尝试中，我开发了一个用于地理编码的Ruby库以及一个简单的基于Sinatra的web服务。当时我的解决方案表现得还不错，直到后来客户要求对每一个鼠标滑过的事件进行交互。这个需求上的更改让我不得不再一次通过Javascript语言去构建一个同样用于地理编码的基础构件，在之后的一段时间里，一切也都表现得非常好。&lt;/p>
&lt;p>而意料之中的是，我们再一次决定在系统中允许每个用户与多个街道关联。现在，每次下载800KB的数据（存储在索引数据库中，用于记录最新的会话信息）尚且可以承受；但是潜在上来说，几个MB的数据将是致命的，甚至软件也有可能在会话的响应之前被使用-而这只是用户所期待的功能之一。&lt;/p>
&lt;p>我知道我们必须寻找一个完美的解决方案，并且使一切都是可以管理控制的。在以前，我涉足过WebSocket领域（比如node.js以及Socket.IO）并且知道相关的底层知识。从之前的搜索中，我意识到Ruby在这方面的欠缺，我很快又考虑通过在节点上的Javascript端口来实现需求。这样的想法使我非常激动。&lt;/p>
&lt;h2 id="可选方案">可选方案&lt;/h2>
&lt;p>第一步是找出可用的方案。以下列举我找到的：&lt;/p>
&lt;ol>
&lt;li>&lt;a href="https://github.com/simulacre/sinatra-websocket">sinatra-websocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/faye/faye-websocket-ruby">faye-websocket&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/websocket-rails/websocket-rails">websocket-rails&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/ngauthier/tubesock">tubesock&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/seancribbs/webmachine-ruby">webmachine-ruby&lt;/a>&lt;/li>
&lt;/ol>
&lt;p>在上述五种方案中，前三种方案都是基于事件机制的，而&lt;code>tubesock&lt;/code>使用了rake hijacking技术，&lt;code>webmachine-ruby&lt;/code>通过基于&lt;code>Celluloid::IO&lt;/code>的HTTP服务器Reel提供WebSockets。&lt;/p>
&lt;p>首先，考虑到我已经使用了Sinatra，于是我试用了&lt;code>sinatra-websocket&lt;/code>。但是因为部分原因，我无法将连接方式迁移到WebSocket，所以我决定快速跳过。而且坦白说的话，我还直接跳过了&lt;code>faye-websocket&lt;/code>。&lt;/p>
&lt;p>接下来的两个备选方案遇到了同样的问题：在一个配置较低的Heroku的站点上启动Rails并且加载了整个系统之后，剩下的内存只够几十个客户端同时使用的了。除此之外，Rails的启动时间加上其他用于构建的时间偶尔会让Heroku认为系统中出现异常，结果导致进程在服务正常启动之前就已经被强行退出了。&lt;/p>
&lt;p>假如你有所留意，那么你也就知道了，剩下的唯一一个方案，就是&lt;code>webmachine-ruby&lt;/code>。&lt;/p>
&lt;h2 id="webmachine-ruby">webmachine-ruby&lt;/h2>
&lt;p>配置&lt;code>webmachine-ruby&lt;/code>的环境还是相对容易的。为了逐步进行，我首先把原来基于HTTP的服务迁移到它的资源结构。比起Rails以及Sinatra，它更加具有面向对象的味道。它的分发器是易于理解的，我非常喜欢通过&lt;a href="https://github.com/seancribbs/webmachine-ruby#visual-debugger">visual debugger&lt;/a>来摆玩这一切。&lt;/p>
&lt;p>迁移到WebSocket上后，一切都变了。我能建议的（包括文档中说明的）就是，你完全可以跳过常规的基础配置，转而提供一个可调用的配置项，比如：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>App = Webmachine::Application &lt;span style="font-weight:bold">do&lt;/span> |app|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> app.configure &lt;span style="font-weight:bold">do&lt;/span> |config|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.adapter = &lt;span style="font-style:italic">:Reel&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> config.adapter_options[&lt;span style="font-style:italic">:websocket_handler&lt;/span>] = proc &lt;span style="font-weight:bold">do&lt;/span> |websocket|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> websocket &amp;lt;&amp;lt; &lt;span style="font-style:italic">&amp;#34;hello, world&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这是相当多的文档所提到的方法。因为它只期望handler支持&lt;code>#call&lt;/code>方法，所以你可以写一个你自己的ad-hoc分发器：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">class&lt;/span> &lt;span style="font-weight:bold">WebsocketHandler&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">def&lt;/span> call(websocket)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> message = websocket.read
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic"># do something with the message, call methods on other objects, log stuff, have your fun&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>很多文档并不提及一些套接字编程的基础。假如你发现你的handler被挂起并且不再处理响应，这意味着你需要重新修改程序，但是不需要为此感到烦恼：你只需要实现一个不断从套接字中读取信息并且让&lt;code>Celluloid::IO&lt;/code>实现它的非阻塞魔术方法的循环就行了：&lt;/p></description></item><item><title>DIY an interesting timer through terminal-notifier and crontab under Mac OS X</title><link>https://blog.hackerpie.com/posts/archive/diy-an-interesting-timer-through-terminal-notifier-and-crontab-under-mac-os-x/</link><pubDate>Sun, 12 Jan 2014 15:51:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/diy-an-interesting-timer-through-terminal-notifier-and-crontab-under-mac-os-x/</guid><description>&lt;p>Today I will show you how to DIY an intersting notifier automatically running per hour under the Mac OS X 10.8 and higher, all we need are a terminal-notifier and the system built-in command line program named &lt;code>crontab&lt;/code>.&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="1-install-the-terminal-notifier">1. Install the terminal-notifier&lt;/h2>
&lt;p>&lt;code>terminal-notifier&lt;/code> is a program written in the awesome &lt;a href="https://www.ruby-lang.org/en/">Ruby&lt;/a> program language, we can visit &lt;a href="https://github.com/alloy/terminal-notifier/releases">the releases page&lt;/a> and download the newest version of terminal-notifier. Steps to install it:&lt;!-- raw HTML omitted -->&lt;/p></description></item><item><title>Split logs automatically every day</title><link>https://blog.hackerpie.com/posts/archive/split-logs-automatically-every-day/</link><pubDate>Sat, 07 Sep 2013 01:11:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/split-logs-automatically-every-day/</guid><description>&lt;p>&lt;strong>Related resource(s):&lt;/strong>&lt;/p>
&lt;p>&amp;ldquo;linuxcommand: logrotate&amp;rdquo;:http://linuxcommand.org/man_pages/logrotate8.html&lt;!-- raw HTML omitted -->
&lt;strong>logrotate&lt;/strong> is designed to ease administration of systems that generate large numbers of log files. Normally, logrotate is run as a daily cron job.&lt;/p>
&lt;p>&lt;strong>Some important knowledges:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>Any number of config files may be given. Later config files may override the options given in earlier files, so the order in which the logrotate config files are listed in is important. Normally, &lt;strong>a single config file which includes any other config files which are needed should be used&lt;/strong>. If a directory is given, every file in that directory is used as a config file.&lt;/li>
&lt;li>&lt;strong>Default config file:&lt;/strong> /etc/logrotate.conf. You can include other config files within it using &lt;strong>include&lt;/strong> directive.&lt;/li>
&lt;/ul>
&lt;!-- raw HTML omitted -->
&lt;h2 id="assumption">Assumption&lt;/h2>
&lt;ol>
&lt;li>Your site is &lt;code>example.com&lt;/code>&lt;/li>
&lt;li>The site is located in &lt;code>/var/www/example/&lt;/code>&lt;/li>
&lt;li>Your site is deployed by Capistrano, so you can find your logs in &lt;code>/var/www/example/shared/log/&lt;/code>&lt;/li>
&lt;li>Your static contents server is &lt;strong>Nginx&lt;/strong>, and its logs are located in &lt;code>/var/www/example/shared/log/&lt;/code> and their names start with &lt;code>nginx_&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="how-to-do">How to do&lt;/h2>
&lt;h3 id="1-login-your-server">1. Login your server&lt;/h3>
&lt;h3 id="2-make-sure-that-include-etclogrotated-is-existed-in-default-config-file-and-not-commented">2. Make sure that &amp;ldquo;include /etc/logrotate.d&amp;rdquo; is existed in default config file and not commented:&lt;/h3>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>You should be able to find the directive shown below, if not, append it manully.&lt;/p></description></item><item><title>Backup database and other attachments in ROR</title><link>https://blog.hackerpie.com/posts/archive/backup-database-and-other-attachments-in-ror/</link><pubDate>Sat, 07 Sep 2013 00:26:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/backup-database-and-other-attachments-in-ror/</guid><description>&lt;h2 id="related-resources">Related Resources&lt;/h2>
&lt;ol>
&lt;li>&lt;strong>rsync&lt;/strong>:http://rsync.samba.org/&lt;/li>
&lt;li>&lt;strong>Crontab&lt;/strong>:http://unixhelp.ed.ac.uk/CGI/man-cgi?crontab+5&lt;/li>
&lt;li>&lt;strong>&amp;ldquo;Linux Crontab 定时任务 命令详解&amp;rdquo;&lt;/strong>:http://blog.csdn.net/tianlesoftware/article/details/5315039&lt;/li>
&lt;li>&lt;strong>[rubygem]&amp;ldquo;backup&amp;rdquo;&lt;/strong>:https://github.com/meskyanichi/backup&lt;/li>
&lt;li>&lt;strong>[rubygem]&amp;ldquo;whenever&amp;rdquo;&lt;/strong>:https://github.com/javan/whenever&lt;/li>
&lt;/ol>
&lt;h2 id="automatically-backup-on-the-remote-server">Automatically backup on the remote server:&lt;/h2>
&lt;p>Let&amp;rsquo;s firstly assumpt:&lt;/p>
&lt;ol>
&lt;li>You have a site named &amp;ldquo;&lt;strong>example.com&lt;/strong>&amp;rdquo;;&lt;/li>
&lt;li>You can login to it through a username &amp;ldquo;&lt;strong>deploy&lt;/strong>&amp;rdquo;, and its password is &amp;ldquo;&lt;strong>password&lt;/strong>&amp;rdquo;;&lt;/li>
&lt;li>You located the contents of your site in &lt;code>/var/www/example/&lt;/code>;&lt;/li>
&lt;li>Your database server is &lt;strong>Mysql&lt;/strong>, and the database for your site is &lt;strong>example_production&lt;/strong>.&lt;/li>
&lt;/ol>
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>1. SSH login:&lt;/strong>&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;!-- raw HTML omitted -->
&lt;p>&lt;strong>2. Install the backup:&lt;/strong>&lt;/p></description></item><item><title>Write css codes distinct from different pages</title><link>https://blog.hackerpie.com/posts/archive/write-css-codes-distinct-from-different-pages/</link><pubDate>Thu, 29 Aug 2013 15:32:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/write-css-codes-distinct-from-different-pages/</guid><description>&lt;p>In rails, there is normally a view corresponding to an action. So if you want to do some special styles based on different pages, you can render controller name and action name in your layout file like this:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-html" data-lang="html">&lt;span style="display:flex;">&lt;span>&amp;lt;&lt;span style="font-weight:bold">body&lt;/span> class=&lt;span style="font-style:italic">&amp;#34;#{controller_name} #{action_name}&amp;#34;&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">&amp;lt;!-- Render something --&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&amp;lt;/&lt;span style="font-weight:bold">body&lt;/span>&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Let&amp;rsquo;s assumpt that your current page controller is &lt;code>ProductsController&lt;/code>, and your action is &lt;code>index&lt;/code>, then you can write your style codes like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-scss" data-lang="scss">&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">.products.index&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="font-style:italic">/* some styles */&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>Failed to stop or restart Nginx server through serevice command</title><link>https://blog.hackerpie.com/posts/archive/failed-to-stop-or-restart-nginx-server-through-serevice-command/</link><pubDate>Fri, 09 Aug 2013 11:39:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/failed-to-stop-or-restart-nginx-server-through-serevice-command/</guid><description>&lt;p>Many people are accustomed to start a Nginx web server through init scripts and then they can control the state of the server through &lt;code>service&lt;/code> command, such as &lt;code>sudo service nginx restart&lt;/code>. But sometimes unobvious config error makes the scripts failed to work. Here I will show an error related to &lt;code>pid&lt;/code> directive in the config file of nginx, which defaultly located at &lt;code>/opt/nginx/conf/nginx.conf&lt;/code>. &lt;!-- raw HTML omitted -->
As ignored by many people, some init scripts assump there is a pid file of nginx located at &lt;code>/var/run/nginx.pid&lt;/code>, but in the fact, the default pid file for nginx is &lt;code>/opt/nginx/logs/nginx.pid&lt;/code>. Because the scripts can&amp;rsquo;t get the correct pid or even get nothing, they failed to stop the nginx process, some tasks dependent on it will be failed too, for example, you are not able to restart the server.&lt;!-- raw HTML omitted -->&lt;/p></description></item><item><title>export/import datas to/from a csv file</title><link>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</link><pubDate>Thu, 25 Jul 2013 22:19:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</guid><description>&lt;p>今天需要给客户的网站做支持产品数据导出并且更新的功能，所以就涉及到了数据的导入导出了。在经过一番对比之下，果断使用&lt;code>csv&lt;/code>格式文件作为数据导入导出的载体。&lt;!-- raw HTML omitted -->&lt;/p>
&lt;h4 id="导出csv文件">导出csv文件&lt;/h4>
&lt;p>与csv文件主要相关的类是&lt;code>CSV&lt;/code>,此类在ruby的标准库中被定义，所以只要在代码开头引入相关文件即可:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>require &lt;span style="font-style:italic">&amp;#39;csv&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>接着需要创建csv文件，并在其中写入数据:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>CSV.open &lt;span style="font-style:italic">&amp;#34;path/to/csv/file&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;wb&amp;#34;&lt;/span>, &lt;span style="font-style:italic">:col_sep&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;|&amp;#39;&lt;/span> &lt;span style="font-weight:bold">do&lt;/span> |csv|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	csv &amp;lt;&amp;lt; [&lt;span style="font-style:italic">&amp;#34;one&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;row&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;of&amp;#34;&lt;/span>, &lt;span style="font-style:italic">&amp;#34;contents&amp;#34;&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 这里有几个细节值得一提：**&lt;!-- raw HTML omitted -->&lt;/p>
&lt;ol>
&lt;li>&lt;code>open&lt;/code>方法是用于对CSV文件进行写操作的主要接口,对CSV文件进行写操作都应该使用此方法;&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>&amp;lt;&amp;lt;&lt;/code> 操作符支持将&lt;strong>字符串数组&lt;/strong>写入到csv文件,一个数组为一行，数组中的一个字符串为一个单元(field);&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>open&lt;/code>方法的第三个参数是一个哈希，用于为打开的文件指定初始化赋值，具体可用的option以及其值可参考&lt;code>new&lt;/code>方法的说明:http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html#method-c-new &lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>&lt;code>:col_sep&lt;/code>用于指定文件中每一行中的每个单元之间的分隔符，当通过字符串数组想文件中添加新行的时候，CSV将会在数组元素也就是每一行的单元之间插入指定的分隔符，分隔符需要尽量避开已经在待导出数据中存在的字符，以免后续导入的时候发生歧义。&lt;/li>
&lt;/ol>
&lt;h4 id="导入csv文件">导入csv文件&lt;/h4>
&lt;p>导入csv除了需要用到相关的类&lt;code>CSV&lt;/code>，还可能用到的类是&lt;code>CSV::Row&lt;/code>，前者提供打开文件以及将文件按行分隔的方法&lt;code>foreach&lt;/code>，foreach将分隔后的行逐行分配到CSV::Row的实例中，通过调用CSV::Row的实例方法&lt;code>field&lt;/code>可对每个单元进行读取。&lt;!-- raw HTML omitted -->
假设我有这样一个csv文件：&lt;/p>
&lt;pre tabindex="0">&lt;code>id | value
1234 		| 		hello
2345 		| 		world
&lt;/code>&lt;/pre>&lt;p>则相关的代码如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-ruby" data-lang="ruby">&lt;span style="display:flex;">&lt;span>CSV.foreach(&lt;span style="font-style:italic">&amp;#39;path/to/file&amp;#39;&lt;/span>), &lt;span style="font-style:italic">:col_sep&lt;/span> =&amp;gt; &lt;span style="font-style:italic">&amp;#39;|&amp;#39;&lt;/span>, &lt;span style="font-style:italic">:headers&lt;/span> =&amp;gt; &lt;span style="font-style:italic">:first_row&lt;/span> &lt;span style="font-weight:bold">do&lt;/span> |row|
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="font-style:italic"># use datas of each row&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	id 		= row.field &lt;span style="font-style:italic">&amp;#39;id&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	value = row.field &lt;span style="font-style:italic">&amp;#39;value&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="font-weight:bold">end&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>** 同样这里也有几个细节需要注意:**&lt;!-- raw HTML omitted -->&lt;/p></description></item><item><title>Rails HTTP Status Code to Symbol Mapping</title><link>https://blog.hackerpie.com/posts/archive/rails-http-status-code-to-symbol-mapping/</link><pubDate>Wed, 24 Jul 2013 15:00:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/rails-http-status-code-to-symbol-mapping/</guid><description>&lt;p>Sometimes you might need to set the HTTP response head with different status to specify the different handled results. You can do this in Rails by add a &lt;code>:status&lt;/code> to a rails method such as &lt;code>#respond_with&lt;/code>. Here list all the maps:&lt;/p>
&lt;p>{% gist 2405434 %}&lt;/p>
&lt;p>Addtionally, you can view all these on your local machine by installing the gem &lt;code>cheat&lt;/code>, and see all status codes using command &lt;code>cheat status_codes&lt;/code>.&lt;/p>
&lt;p>All these informations come from internet, the codes file comes from &lt;a href="https://gist.github.com/ktkaushik">ktkaushik&amp;rsquo;s&lt;/a> gist and other information comes from &lt;a href="http://www.codyfauser.com/2008/7/4/rails-http-status-code-to-symbol-mapping">Cody Fauser&amp;rsquo;s post&lt;/a>&lt;/p></description></item><item><title>Delete multiple git remote branches by prefixing all refs with a colon</title><link>https://blog.hackerpie.com/posts/archive/delete-multiple-git-remote-branches-by-prefixing-all-refs-with-a-colon/</link><pubDate>Sun, 21 Jul 2013 15:46:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/delete-multiple-git-remote-branches-by-prefixing-all-refs-with-a-colon/</guid><description>&lt;p>This article shows how to delete multiple remote branches in Git.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>git push origin :branch-1 :branch-2 [:other-branches]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Remember the colon &lt;code>:&lt;/code>&lt;/p></description></item><item><title>Track Original Repo When Fork</title><link>https://blog.hackerpie.com/posts/archive/track-original-repo-when-fork/</link><pubDate>Sun, 21 Jul 2013 10:24:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/track-original-repo-when-fork/</guid><description>&lt;p>{% gist 5908916 %}&lt;/p></description></item></channel></rss>