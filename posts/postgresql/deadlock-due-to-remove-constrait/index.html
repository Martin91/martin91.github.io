<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="一个在 DDL 事务中同时增加列和移除外键索引触发的线上数据库死锁问题"><meta name=baidu-site-verification content="code-O73IxgKIB2"><title>PostgreSQL 数据库删除外键约束引发的死锁问题
</title><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"PostgreSQL 数据库删除外键约束引发的死锁问题","datePublished":"2024-12-12T22:26:00\u002b08:00"}</script><style>.hljs-comment,.hljs-quote{color:#8e908c}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c82829}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5871f}.hljs-attribute{color:#eab700}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#718c00}.hljs-section,.hljs-title{color:#4271ae}.hljs-keyword,.hljs-selector-tag{color:#8959a8}.hljs{display:block;overflow-x:auto;background:#fff;color:#4d4d4c;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><link rel=canonical href=https://blog.hackerpie.com/posts/postgresql/deadlock-due-to-remove-constrait/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:1000px;margin:auto}p{margin:20px 0;letter-spacing:1pt}table{border-collapse:collapse;border-spacing:0}table th,td{border-bottom:1px solid #d3d3d3;padding:5px}table th{font-weight:700}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.section-title{font-family:fangsong,old standard tt,serif}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}figcaption{text-align:center;color:gray;font-size:90%;font-style:italic}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:16px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:16px}#content h1{font-size:22px}#content h2{font-size:20px}#content h3{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?288e2eb770bdfc3ef2b333b7d845fb2a",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><section id=nav><h1 id=site-title><a href=https://blog.hackerpie.com/>HackerPie</a></h1><h3>成长，折腾，保持单纯</h3><ul></ul></section><section id=content><h1 class=section-title>PostgreSQL 数据库删除外键约束引发的死锁问题</h1><div id=sub-header>12/Dec/2024 · 2 minute read</div><div id=toc class="well col-md-4 col-sm-6"><nav id=TableOfContents><ul><li><a href=#为什么从库也有死锁>为什么从库也有死锁？</a></li><li><a href=#根因ddl-与高并发的-select--from-a-join-b--查询形成死锁>根因：DDL 与高并发的 <code>SELECT ... FROM A JOIN B ...</code> 查询形成死锁</a></li><li><a href=#根因定位过程的一些有趣思考>根因定位过程的一些有趣思考</a><ul><li><a href=#区分症结和现象>区分症结和现象</a></li><li><a href=#为什么主库没有出现死锁>为什么主库没有出现死锁？</a></li><li><a href=#为什么另一个从库没有问题>为什么另一个从库没有问题？</a></li><li><a href=#为什么请求不是全部失败>为什么请求不是全部失败?</a></li></ul></li><li><a href=#最佳实践建议>最佳实践建议</a></li></ul></nav></div><div class=entry-content><p>上周将一个大功能发布到了线上环境，但是在半个多小时后收到数据库从库（我们使用的是 PostgreSQL 数据库）CPU 使用率接近 100% 的告警，同时 APM 监控表明部分 API 响应时间明显变长，并且相关 API 的错误追踪里会看到 Statement Timeout 错误。经过版本回滚后，数据库和服务恢复正常。后面是漫长的根因分析的过程，而最后我们确定的原因，竟是一个 Rails migration 触发（注意不是导致，因为死锁还得找到和它形成相互等待的另一方，双方同时运行才能导致死锁）的从库死锁，比较有意思，总结一下，跟各位分享。</p><h2 id=为什么从库也有死锁>为什么从库也有死锁？</h2><p>按照过去仅有的认知，我只知道死锁在主库中更为常见，因为死锁通常发生在两个冲突的事务之间，而一般只有主库才会有大量事务同时运行，而从库由于只需要同步主库的日志进行顺序回放即可，理论上不存在并发的事务。</p><p>但是我们的死锁发生在了从库，这是一个让人感觉有点匪夷所思的问题。</p><h2 id=根因ddl-与高并发的-select--from-a-join-b--查询形成死锁>根因：DDL 与高并发的 <code>SELECT ... FROM A JOIN B ...</code> 查询形成死锁</h2><p>经过死锁日志的分析，我们发现每次死锁出现时，都有类似以下模式的联表查询语句在等待同一个线程锁定的资源：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=font-weight:700>SELECT</span> users.id, users.name, cars.brand, ... <span style=font-weight:700>FROM</span> users <span style=font-weight:700>LEFT</span> <span style=font-weight:700>OUTER</span> <span style=font-weight:700>JOIN</span> cars <span style=font-weight:700>ON</span> cars.owner_id = users.id <span style=font-weight:700>WHERE</span> ...
</span></span></code></pre></div><p>（以上 SQL 中的表名和列名为示例，非真实表名列名）</p><p>完整的日志类似：</p><pre tabindex=0><code>[12345]:ERROR:  deadlock detected at character 234
Process 12345 waits for AccessShareLock on relation 2 of database 789; blocked by process 911.
	Process 911 waits for AccessExclusiveLock on relation 1 of database 789; blocked by process 12345.
	Process 12345: SELECT users.id, users.name, cars.brand, ... FROM users LEFT OUTER JOIN cars ON cars.owner_id = users.id WHERE ...
	Process 911: &lt;backend information not available&gt;
</code></pre><p>通过查询 PostgreSQL 数据库的元数据表，还原出 relation=1 对应表名是 <code>users</code>，而 relation=2 对应表名是 <code>cars</code>。
所以：</p><ol><li>这里的 SELECT 联表查询，正在等待 <code>cars</code> 的 <code>AccessShareLock</code>；</li><li>而线程 911 在等待 <code>users</code> 的 <code>AccessExclusiveLock</code> 锁。</li></ol><p>通过 PostgreSQL 官方文档，了解到这两个锁的求锁场景以及互斥性：</p><ol><li><code>AccessShareLock</code>: 仅在使用 SELECT 查询表时，对表进行加锁，并且 **只和 <code>AccessExclusiveLock</code> ** 互斥；</li><li><code>AccessExclusiveLock</code>: 和其它所有模式的锁互斥，这个锁保证同一时间只有持有这个锁的事务是唯一可访问目标表的事务。<code>DROP TABLE</code>, <code>TRUNCATE</code>, <code>REINDEX</code>, <code>CLUSTER</code>, <code>VACUUM FULL</code>，<code>REFRESH MATERIALIZED VIEW</code>（不使用 <code>CONCURRENTLY</code> 前提下）以及大多数的 <code>ALTER INDEX</code> 和 <code>ALTER TABLE</code> 操作都会尝试获取这个锁。</li></ol><p>从以上获取到的信息来看，那么死锁的形成，很有可能是有一个包含 DDL 的事务，并且整个事务里先后对 <code>cars</code> 和 <code>users</code> 加上了 <code>AccessExclusiveLock</code> 锁。</p><p>于是，我开始回顾这次版本里所有的数据库改动，也就是我们的 <code>db/migrations/</code> 里的新增的文件，但是一开始，我没有发现任何问题，因为所有的 migration，看起来都是只修改了一张表。直到我冷静下来思考：<strong>如果显式的 DDL 没有相关的，但是 DDL 又确实存在，那么一定是某个我们不熟悉的潜在代码引发了问题</strong>，进一步扩大了 review 的范围，我尝试找出 migration 中同时涉及这两个表的表名或者列名的，直到发现一个可疑对象：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rb data-lang=rb><span style=display:flex><span><span style=font-style:italic># db/migrate/20241212010203_add_repaired_at_to_and_remove_fk_constraint_from_cars.rb</span>
</span></span><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>AddReparedAtToAndRemoveFkConstraintFromCars</span> &lt; ActiveRecord::Migration[8.0]
</span></span><span style=display:flex><span>  <span style=font-weight:700>def</span> change
</span></span><span style=display:flex><span>    add_column <span style=font-style:italic>:cars</span>, <span style=font-style:italic>:repaired_at</span>, <span style=font-style:italic>:datetime</span>
</span></span><span style=display:flex><span>    remove_foreign_key <span style=font-style:italic>:remove_foreign_key</span>, <span style=font-style:italic>:cars</span>, <span style=font-style:italic>:owner_id</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>难道是<strong>这个 <code>remove_foreign_key</code> 会导致在 <code>users</code> 表上加锁</strong>？尝试 Google 搜索关键词“Pg remove foreign key constraint lock on table”，找到一篇讨论，标题是“Thread: Full table lock dropping a foreign key”，里边提到帖子作者通过 <code>pg_locks</code> 观察到当 pg 在执行外键约束删除时，会对被引用的表加上 <code>AccessExclusiveLock</code> 锁，底层原因是 PostgreSQL 数据库内部会在此过程中移除响应的 trigger，但是由于对数据库底层我不精通，到此打住不深究，但是已经足以我找出此次死锁的根因了。</p><p>所以，从始至终，包括我自己在内的开发人员，都没有意识到原来删除外键约束，会对外键引用的表进行加锁操作，这是我们写出这个风险代码，并且没有在死锁出现后第一时间怀疑到这里的原因，甚至我们一大帮人在分析根因的时候，虽然共享屏幕上正对着这行代码，但是我们都以为这行代码对于死锁原因分析无关紧要。</p><h2 id=根因定位过程的一些有趣思考>根因定位过程的一些有趣思考</h2><h3 id=区分症结和现象>区分症结和现象</h3><p>我们一开始引入 DBA 同事参与排查，DBA 同事将原因归为高并发，原因是当时并没有立马意识到死锁的存在以及监控显示数据库连接数在问题期间翻了一番。事实上，如我们一位 SRE 同事所怀疑的一致，连接数高不是因，而是果，是因为查询请求时延过高，导致连接池连接复用率下降，业务必须建立更多的数据库连接来完成数据查询。</p><p>事后冷静思考，我才想起去看一下当时其他的指标，如果是业务量临时变大导致，那请求 QPS 以及数据库 IO 应该明显变高，但是事实上是当时的 API QPS 和数据库 IO 并没有明显变化。如果当时把这些观察纳入推理，那我们会更快排除这个错误的原因。</p><h3 id=为什么主库没有出现死锁>为什么主库没有出现死锁？</h3><p>因为我们之前做了主从读写分离，主库的查询请求非常少，从概率的角度来看，这降低了这次死锁在主库出现的概率，但也不是说主库一定高枕无忧。</p><h3 id=为什么另一个从库没有问题>为什么另一个从库没有问题？</h3><p>我们有 2 个从库实例，事实上另一个从库也不是独善其身，事后分析日志，仍然发现另一个从库上出现了 8 次死锁日志，说明这个从库在重放的过程中，还是遇到了 8 次死锁，只不过第 9 次重试时，它很幸运，抢先一步完成所有 DDL 并提交了事务，之后正常提供查询服务。</p><p>而那个有问题的从库，则是很不幸地一直抢不到所有的锁，数据库一直重试，一直死锁，这点从事后回顾从库的复制的 lag 监控也能看出来，问题期间，数据库从库复制的 lag 持续拉大，表明数据库当时卡在了事务重放了，但是我们当时没有很快去排查这个监控，也是一个教训。</p><h3 id=为什么请求不是全部失败>为什么请求不是全部失败?</h3><p>PostgreSQL 数据库默认的死锁检测等待时间是 1s，之后启动死锁检测并且回滚导致死锁的事务。所以大量请求更多的影响是时延变高（等待 1 秒后拿到了共享锁，完成查询），并不会失败。但是也会有一些线程的查询很不幸，虽然 DDL 事务已经回滚，但是回滚同时这个线程可能在休眠中，等到线程调度进来的时候，新的 DDL 事务又已经开启并且进入等待了，所以这些不幸的线程再次等待。从事后监控看，问题期间，整体的 API 时延升高，P99 到达惊人的 1 分钟，说明极少数请求很不幸地一直在等待锁，直到 STATEMENT 超时（默认 60 秒）。</p><h2 id=最佳实践建议>最佳实践建议</h2><ol><li><strong>慎重使用数据库层面的 constraint</strong>
恰当使用数据库 constraint 可以简化应用层逻辑，保证数据完整性，但是对其不熟悉的前提下使用，容易踩坑。理想状况下，数据库只做数据存取这一件事，其他的事情交给应用层。</li><li><strong>避免多个表在同一个 DDL 事务里</strong>
需要特别警醒的是，Rails migration 会将每个 migration 包装成一个事务，为了防止死锁，一个事务，也就是一个 migration，只能操作一个表，如果你不确定，可以将操作分散到多个 migration 里，或者干脆关闭这个 migration 的事务，即调用 <code>disable_ddl_transaction!</code>。</li></ol><blockquote>版权声明：本文为原创文章，转载请注明来源：《<a href=https://blog.hackerpie.com/posts/postgresql/deadlock-due-to-remove-constrait/>PostgreSQL 数据库删除外键约束引发的死锁问题 - Hackerpie</a>》，谢绝未经允许的转载。</blockquote></div><div id=links><a href=https://blog.hackerpie.com/posts/remote/share-about-my-remote-work-experience-for-months/>&#171;&nbsp;灵活与专注——谈谈我这几个月来的远程工作体验</a></div></section></body><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js></script><script>hljs.highlightAll()</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script><script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading="lazy",t.src="http://www.plantuml.com/plantuml/svg/~1"+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display="none"})})()</script></html>