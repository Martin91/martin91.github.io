<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="总结在 Golang 编程中的一些关于错误处理和日志打印的建议。"><meta name=baidu-site-verification content="code-O73IxgKIB2"><title>Golang 错误处理和日志打印的 5 点建议</title><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"Golang 错误处理和日志打印的 5 点建议","datePublished":"2022-06-12T14:49:18\u002b08:00"}</script><style>.hljs-comment,.hljs-quote{color:#8e908c}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c82829}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5871f}.hljs-attribute{color:#eab700}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#718c00}.hljs-section,.hljs-title{color:#4271ae}.hljs-keyword,.hljs-selector-tag{color:#8959a8}.hljs{display:block;overflow-x:auto;background:#fff;color:#4d4d4c;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><link rel=canonical href=https://blog.hackerpie.com/posts/programming-paradigm/golang-error-logs/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:1000px;margin:auto}p{margin:20px 0;letter-spacing:1pt}table{border-collapse:collapse;border-spacing:0}table th,td{border-bottom:1px solid #d3d3d3;padding:5px}table th{font-weight:700}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.section-title{font-family:fangsong,old standard tt,serif}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}figcaption{text-align:center;color:gray;font-size:90%;font-style:italic}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:16px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:16px}#content h1{font-size:22px}#content h2{font-size:20px}#content h3{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?288e2eb770bdfc3ef2b333b7d845fb2a",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><section id=nav><h1 id=site-title><a href=https://blog.hackerpie.com/>HackerPie</a></h1><h3>成长，折腾，保持单纯</h3><ul></ul></section><section id=content><h1 class=section-title>Golang 错误处理和日志打印的 5 点建议</h1><div id=sub-header>12/Jun/2022 · 2 minute read</div><div id=toc class="well col-md-4 col-sm-6"><nav id=TableOfContents></nav></div><div class=entry-content><p>Golang 语言语法中，错误处理机制是一个非常有特色的设计，它是基于<a href=https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B>防御性编程</a>思想的设计。不过今天这篇文章不讨论 Golang 错误处理的语法设计问题，相反，今天想思考的是，Golang 里的错误日志应该怎样处理以及打印比较好。</p><h1 id=golang-中错误处理和日志打印的-5-点建议>Golang 中错误处理和日志打印的 5 点建议</h1><ol><li>使用错误栈的方式；</li><li>使用逻辑栈信息，而非代码调用栈；</li><li>使用 <code>fmt.Errorf</code>，不用 <code>pkg/errors</code> 第三方模块；</li><li>避免使用依赖标准库 <code>fmt</code> 格式化字符串的日志方法；</li><li>转换外部错误，基于内部错误类型判断。</li></ol><h1 id=使用错误栈的方式>使用错误栈的方式</h1><p>我从转 Golang 开发以来，从看过的 Golang 代码以及自己的实践来说，大概会有以下几种个人认为不是太合理的错误日志打印方式：</p><ol><li>每一个函数调用处在发现错误时都打印错误信息；</li><li>约定只在最里层或者最外层函数调用处发现错误时打印错误信息，进一步细分的话，还区分是否会在错误里携带调用栈信息；</li><li>没有明确规范，在整个调用链的任何一处或者多处调用发现错误时都有可能打印错误信息。</li></ol><p>第一种方式，好处是不会遗漏调用链路上的所有调用节点信息，但是在实际应用场景里，服务的线程是并发执行的，不同线程打印的日志行之间相互交错，这种方式打印的同一个链路上的日志非常散乱，导致尽管日志里有全部错误相关的日志，但是却难以简单快速过滤出相关而非干扰的日志行，所谓的好处名存实亡，还占据大量磁盘空间。</p><p>第二种方式，最大的问题是可能缺失对于错误排查所需的一些上下文信息。大多数函数调用都发生在跨层代码逻辑的调用上，如果只在最里层调用处打印错误，则一般缺少最外层请求的大多数参数信息，想象一个存储层代码调用的例子。而另外一种思路是通过记录代码调用栈，可以帮助开发人员还原程序执行路径，进而通过阅读源码以及推理还原请求的上下文信息，这种方式确实能够提高问题排查处理的效率。但是只是纯粹代码调用栈信息的话，一方面会有大量业务无关的代码栈信息可能被记录到日志造成存储空间浪费，另一方面是仍旧可能缺失一些关键的上下文信息，这些信息可能也是问题定位的必要元素。</p><p>第三种方式，本质上是开发者对错误处理本身缺乏思考以及团队缺乏相关的编码规范，看起来这种问题挺低级，但是并不少见。这种自然是最应该避免的。我在此之前，自己也没有好好思考过这个问题。</p><p>第一第二种方式，想要有效定位错误根源，本质上都是需要记录错误发生时的调用栈信息，以便我们知道错误是怎么一路出现的，所以我们得到第一个共识：<strong>错误需要携带调用栈信息</strong>。</p><h1 id=使用逻辑栈信息而非代码调用栈>使用逻辑栈信息，而非代码调用栈</h1><p>顺着第一点，我们明白了调用栈信息的重要性。关于调用栈，一种最直观的方式就是程序的函数调用栈，这种方式一定程度上并不是面向人的，尽管它详细记录了每个调用栈所在的源代码文件以及行数。比如 Golang 程序在遇到 panic 中打印的调用栈信息：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>panic: a problem
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>goroutine 1 [running]:
</span></span><span style=display:flex><span>main.main()
</span></span><span style=display:flex><span>	/tmp/sandbox4213436970/prog.<span style=font-weight:700>go</span>:15 +0x27
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Program exited.
</span></span></code></pre></div><p>这种方式看起来，往往只是一堆文件名和函数名的栈信息，避免不了需要回到源码中进行阅读，如果不是熟悉业务的开发人员，则可能难以快速理解问题产生的原因。</p><p>在我看来，另外一种思路是，如果我可以人为地在代码中主动记录错误发现时所在的位置以及参数等，不也是一种调用栈的思想吗？而且，这种方式下，我还可以额外增加必要的上下文信息。比如我期待拥有类似这样的日志来回溯错误发生的过程，它最大的优点是面向开发人员友好以及偏业务描述的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>handle upload failed, caused by:
</span></span><span style=display:flex><span>    parse file failed, format: JSON,caused by:
</span></span><span style=display:flex><span>    open file failed, caused by:
</span></span><span style=display:flex><span>    file not found, path: /path/to/file
</span></span></code></pre></div><p>这种日志下，信息是偏向于开发者易于理解的，阅读下来，很容易理解程序的目的以及所遇到的异常情况。日志里的“handle upload failed” 等是一种逻辑上的调用链路，而“format: JSON”以及“path: /path/to/file” 则是必要的上下文信息。</p><p>具体到 Golang 的设计的考虑，如果需要在错误中获取被调函数的调用栈信息，则需要依赖 Golang 的运行时实现，这将会导致程序比较明显的性能开销。</p><p>所以，综合考虑错误信息的引导性以及对程序的性能友好，<strong>应该使用逻辑栈信息，而避免使用代码调用栈</strong>。</p><h1 id=使用-fmterrorf不用-pkgerrors-第三方模块>使用 <code>fmt.Errorf</code>，不用 <code>pkg/errors</code> 第三方模块</h1><p>这一点是第2点的延伸。</p><p>在早期的 Golang 版本中，标准库中并没有对于错误栈信息的支持，从 Golang 1.13 开始，Golang 在 <code>fmt.Errorf</code> 标准库函数中增加了一个新的格式化占位符 <code>%w</code> 的支持，<code>w</code> 是 Wrap 的缩写，意即对原始错误对象进行一层包装。比如为了实现上节的逻辑栈，代码类似：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	cause := errors.New(<span style=font-style:italic>&#34;file not found, path: /path/to/file&#34;</span>)
</span></span><span style=display:flex><span>	err := fmt.Errorf(<span style=font-style:italic>&#34;open file failed, %w&#34;</span>, cause)
</span></span><span style=display:flex><span>	err = fmt.Errorf(<span style=font-style:italic>&#34;parse file failed, format: JSON, %w&#34;</span>, err)
</span></span><span style=display:flex><span>	err = fmt.Errorf(<span style=font-style:italic>&#34;handle upload failed, %w&#34;</span>, err)
</span></span><span style=display:flex><span>	fmt.Println(err) <span style=font-style:italic>// output: handle upload failed, parse file failed, format: JSON, open file failed, file not found, path: /path/to/file
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>Golang 1.13 除了 <code>fmt.Errorf</code> 的这个新功能，相应地在 <code>errors</code> 标准库中也增加了 <code>errors.Is</code> 以及 <code>errors.As</code> 两个新函数，前者用于判断制定错误的错误链上是否存在特定的错误值，而后者用于尝试将 <code>error</code> 值转换为具体的错误值。在此不展开，有兴趣的朋友可以点击<a href=https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html>《Go语言(golang)新发布的1.13中的Error Wrapping深度分析》</a>一文了解更多用法。</p><p>值得一提的是，Golang 1.13 的这个新特性，应该是源自 <a href=github.com/pkg/errors>pkg/errors</a> 这个第三方包的设计，所以早期大家可能会使用其实现上面的错误栈：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=font-weight:700>func</span> main() {
</span></span><span style=display:flex><span>	cause := errors.New(<span style=font-style:italic>&#34;file not found, path: /path/to/file&#34;</span>)
</span></span><span style=display:flex><span>	err := errors.WithMessage(cause, <span style=font-style:italic>&#34;open file failed&#34;</span>)
</span></span><span style=display:flex><span>	err = errors.WithMessage(err, <span style=font-style:italic>&#34;parse file failed, format: JSON&#34;</span>)
</span></span><span style=display:flex><span>	err = errors.WithMessage(err, <span style=font-style:italic>&#34;handle upload failed&#34;</span>)
</span></span><span style=display:flex><span>	fmt.Println(err) <span style=font-style:italic>// output: handle upload failed: parse file failed, format: JSON: open file failed: file not found, path: /path/to/file
</span></span></span><span style=display:flex><span><span style=font-style:italic></span>}
</span></span></code></pre></div><p>但是由于 Golang 已经实现这个错误栈的功能，<code>pkg/errors</code> 已经将项目归档，并且建议开发人员使用 Golang 官方实现的版本，这也是为了应用程序本身更好的向前兼容 Golang 2.0。</p><h1 id=避免使用依赖标准库-fmt-格式化字符串的日志方法>避免使用依赖标准库 <code>fmt</code> 格式化字符串的日志方法</h1><p>在标准库的日志功能实现中，其基于 <code>fmt</code> 标准库实现，而后者又重度依赖于反射的工作，这些都导致了比较高的 CPU 开销以及细碎的内存分配，前者通过挤占 CPU 时间片直接影响程序性能，而后者因为加大了运行时垃圾回收工作负担间接影响程序性能。</p><p>那怎么办好呢？可以考虑类似 <a href=https://github.com/uber-go/zap>uber-go/zap</a> 这类针对性能优化的第三方日志库。zap 主要通过几个角度优化性能：</p><ol><li>使用延迟加载机制避免不必要的计算，比如有些日志需要 Debug 日志级别才需打印，那在以 Info 日志级别启动的程序中，这部分日志其实是不打印的，不打印也就没有计算的需要，所以延迟加载有助于在高级别日志场景下直接省略格式化日志的工作；</li><li>使用显式的 Fields 机制，zap 可以避免大量的反射需求，另外结合零分配的 JSON 序列化编码器，提高了性能。</li></ol><h1 id=转换外部错误基于内部错误类型判断>转换外部错误，基于内部错误类型判断</h1><p>所谓外部错误，是指由自身应用程序源代码之外所定义的错误，比如系统调用的错误、rpc 服务返回的错误以及数据库读写操作错误等。应用程序设计讲究分层与解耦，如果没有对底层函数调用遇到的外部错误进行转换，则意味着上层逻辑与下层实现的耦合，破坏了低耦合性。比如，对于一个业务逻辑层的代码来说，它所依赖的数据库层函数应该给它统一的内部错误，比如 <code>DBConnectFailed</code>，而不是后者依赖某个 SDK 所定义的 <code>MySQLError</code> 或者 <code>PGError</code> 这类错误。</p><h1 id=参考资料>参考资料</h1><ol><li><a href=https://zh.wikipedia.org/wiki/%E9%98%B2%E5%BE%A1%E6%80%A7%E7%BC%96%E7%A8%8B>防御性编程</a></li><li><a href=https://www.flysnow.org/2019/09/06/go1.13-error-wrapping.html>Go语言(golang)新发布的1.13中的Error Wrapping深度分析</a></li><li><a href=https://github.com/uber-go/zap/blob/master/README.md>uber-go/zap: README</a></li></ol></div><div id=links><a href=https://blog.hackerpie.com/posts/work-efficiency/5-ways-to-keep-high-efficiency-and-focus/>&#171;&nbsp;保持高效与专注的 5 个习惯</a></div></section></body><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js></script>
<script>hljs.highlightAll()</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script>
<script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading='lazy',t.src='http://www.plantuml.com/plantuml/svg/~1'+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display='none'})})()</script></html>