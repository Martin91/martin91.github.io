<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=HandheldFriendly content="True">
<meta name=MobileOptimized content="320">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="柯理化是函数式编程中的一个重要技巧，本篇博文总结何谓部分应用与柯理化。">
<meta name=baidu-site-verification content="code-O73IxgKIB2">
<title>
部分应用与柯理化
</title><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"部分应用与柯理化","datePublished":"2021-08-15T21:18:18\u002b08:00"}</script>
<style>.hljs-comment,.hljs-quote{color:#8e908c}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c82829}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5871f}.hljs-attribute{color:#eab700}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#718c00}.hljs-section,.hljs-title{color:#4271ae}.hljs-keyword,.hljs-selector-tag{color:#8959a8}.hljs{display:block;overflow-x:auto;background:#fff;color:#4d4d4c;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><link rel=canonical href=https://blog.hackerpie.com/posts/programming-paradigm/partial-application-and-currying/>
<style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:1000px;margin:auto}p{margin:20px 0;letter-spacing:1pt}table{border-collapse:collapse;border-spacing:0}table th,td{border-bottom:1px solid #d3d3d3;padding:5px}table th{font-weight:700}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.section-title{font-family:fangsong,old standard tt,serif}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}figcaption{text-align:center;color:gray;font-size:90%;font-style:italic}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:16px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:16px}#content h1{font-size:22px}#content h2{font-size:20px}#content h3{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style><script>var _hmt=_hmt||[];(function(){var e=document.createElement("script"),t;e.src="https://hm.baidu.com/hm.js?288e2eb770bdfc3ef2b333b7d845fb2a",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script>
</head><body>
<section id=nav>
<h1 id=site-title><a href=https://blog.hackerpie.com/>Hackerpie</a></h1><h3>成长，折腾，保持单纯</h3><ul>
</ul></section><section id=content>
<h1 class=section-title> 部分应用与柯理化 </h1><div id=sub-header>
15/Aug/2021 · 2 minute read
</div><div id=toc class="well col-md-4 col-sm-6">
<nav id=TableOfContents>
<ul>
<li><a href=#柯理化>柯理化</a></li><li><a href=#部分应用>部分应用</a></li><li><a href=#柯理化与函数闭包>柯理化与函数闭包</a></li><li><a href=#参考资料>参考资料</a></li></ul></nav></div><div class=entry-content>
<p>在最近学习函数式编程的过程中，反复接触到的就是“柯理化”这个概念，特别数学范有没有？虽然看过多次，但是一直不是很好地理解它，恰逢今天在阅读《Scala 函数式编程》这本书的过程中加深了理解，便写个文章，总结一下。</p><h2 id=柯理化>柯理化</h2><p>柯理化，英文叫“Currying”，命名源自逻辑学家 Haskell Curry 的名字。在数学和编程领域，<strong>柯理化</strong>用于将一个接收多个参数的函数转换为一系列只接收单个输入参数的函数。比如，将一个接收三个参数的函数 <code>f</code> 进行柯理化，会得到三个新的函数：</p><pre tabindex=0><code>x = f(a, b, c) 变为：
    h = g(a)
    i = h(b)
    x = i(c)
或者使用匿名函数按序调用的形式，则为：
    x = g(a)(b)(c)
</code></pre><p>这样讲或许仍有点不好理解，我们用个数学函数的例子来分解。假如我们有函数 <code>f(a, b, c) = a² + b - c</code>，并且有 <code>a = 2</code>、<code>b = 3</code>、<code>c = 1</code>，则一般数学求解过程中，我们可以直接将 a、b、c 的值对应代入函数右侧式子，得到 <code>2² + 3 - 1 = 6</code>，于是我们知道 <code>f(2, 3, 1) = 6</code>。这个过程很直观很好理解，也很亲切对不对？</p><p>但是，假如我们要求每次只能代入函数的一个输入值，会是怎样的过程呢？</p><ul>
<li>第一步，我们代入 <code>a = 2</code>，我们将得到 <code>f(2, b, c) = 2² + b - c</code>，我们可以记 <code>g(b, c) = f(2, b, c) = 4 + b - c</code>；</li><li>第二步，我们代入 <code>b = 3</code>，我们得到 <code>g(3, c) = 4 + 3 - c</code>，我们可以记 <code>h(c) = g(3, c) = 7 - c</code>；</li><li>最后一步，我们代入 <code>c = 1</code>，我们得到 <code>h(1) = 7 - 1 = 6</code>。</li></ul><p>上述的过程，向我们展示了我们是如何通过每次代入一个输入值而得到一个输入值数量减 1 的新函数。</p><ul>
<li>第一步，<code>a</code> 在 <code>f(a, b, c)</code> 上的代入得到了 <code>g(b, c)</code>；</li><li>第二步，<code>b</code> 在 <code>g(b, c)</code> 上的代入得到了 <code>h(c)</code>。</li></ul><p>进一步，我们可以定义一组新的函数：</p><ul>
<li>对应第一步，我们定义一个新函数 <code>F(a)</code>，由于对 <code>a</code> 的代入得到了 <code>g(b, c)</code>，于是 <code>F(a) = g(b, c)</code>，即 <code>F(a)</code> 是一个输入为 <code>a</code>，输出为函数 <code>g(b, c)</code> 的函数；</li><li>对应第二步，我们定义一个新函数 <code>G(b)</code>，由于对 <code>b</code> 的代入得到了 <code>h(c)</code>，于是 <code>G(b) = h(c)</code>，即 <code>G(b)</code> 是一个输入为 <code>b</code>，输出为函数 <code>h(c)</code> 的函数；</li><li>对应第三步，我们定义一个新函数 <code>H(c)</code>，由于对 <code>c</code> 的代入得到了最终式子，这里可以暂时记为 <code>H(c) => R</code>，R 表示实数集合。</li><li>以上三步，结合到一起，就有 <code>f(a, b, c) = F(a)(b)(c)</code>。</li></ul><p>这样循环通过每次只代入一个输入值最后得到一组每个函数都只有一个输入值的新函数的过程，就叫<strong>柯理化</strong>，而 <code>F(a)</code>、<code>G(b)</code>以及 <code>H(c)</code> 就是我们在<strong>柯理化</strong>过程中间得到的中间函数。</p><h2 id=部分应用>部分应用</h2><p>从上面的分解过程可以看出，与我们习以为常的直接将 <code>a, b, c</code> 的值全部代入到式子中不同，我们在柯理化的过程中，每次只代入一个输入值，从而得到一个新的返回函数的函数，这种过程就叫<strong>部分应用</strong>。以下是部分应用的定义：</p><blockquote>
<p>部分应用（partial application）这个名词，表示函数被应用的参数不是它所需要的完整的参数。</p></blockquote><p>依然拗口，是不是？现在结合上面的例子，其实就好理解了，正常来说，我们要对 <code>f(a, b, c)</code> 求解，肯定是要应用 <code>a</code>、<code>b</code>、<code>c</code> 三个参数的，但是第一次只能应用 <code>a</code> 这个输入值，于是，我们还不能知道 <code>f(a, b, c)</code> 函数的值，但是我们得到了一个新的函数，这个新的函数将不再依赖 <code>a</code> 这个参数。</p><p>所以，柯理化的过程必然会有部分应用的身影，但是只是相关，并非等价，因为按照部分应用的定义，满足部分应用的过程不一定就是柯理化的过程，这个很好证伪，就不赘述了。</p><h2 id=柯理化与函数闭包>柯理化与函数闭包</h2><p>在前面函数柯理化的过程中，我们将函数输入值代入之后的输出都是一个新的函数，对应到编程中就是返回函数的函数，而编程语言中柯理化实现的基础就依赖了闭包的功能，即返回的新函数隐含了对于外部函数的输入值的引用。这点也是将函数闭包和柯理化关联起来的比较有意思的一点。</p><h2 id=参考资料>参考资料</h2><ul>
<li>《Scala 函数式编程》—— Paul Chiusano, Runar Bjarnason 著</li><li>Wikipedia: <a href=https://en.wikipedia.org/wiki/Currying>Currying</a></li><li>Wikipedia: <a href=https://zh.wikipedia.org/zh-hans/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)>闭包 (计算机科学)</a></li></ul></div><div id=links>
<a href=https://blog.hackerpie.com/posts/algorithms/monotonous-stacks/monotonous-stacks/>&#171;&nbsp;数据结构：单调栈</a>
<a href=https://blog.hackerpie.com/posts/2021/interview-thinking/>技术面试如何“试”&nbsp;&#187;</a>
</div></section></body><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js></script>
<script>hljs.highlightAll()</script>
</html>