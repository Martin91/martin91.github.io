<!doctype html><html lang=zh-cn>
<head>
<meta charset=utf-8>
<meta name=HandheldFriendly content="True">
<meta name=MobileOptimized content="320">
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content>
<meta name=baidu-site-verification content="code-O73IxgKIB2">
<title>
在 coding.net 上部署 Jekyll 博客
</title>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"在 coding.net 上部署 Jekyll 博客","datePublished":"2014-12-20T12:59:00\u002b08:00"}</script>
<style>.hljs-comment,.hljs-quote{color:#8e908c}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c82829}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5871f}.hljs-attribute{color:#eab700}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#718c00}.hljs-section,.hljs-title{color:#4271ae}.hljs-keyword,.hljs-selector-tag{color:#8959a8}.hljs{display:block;overflow-x:auto;background:#fff;color:#4d4d4c;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style>
<link rel=canonical href=https://blog.hackerpie.com/posts/archive/zai-coding-dot-netshang-bu-shu-jekyllbo-ke/>
<style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:1000px;margin:auto}p{margin:20px 0;letter-spacing:1pt}table{border-collapse:collapse;border-spacing:0}table th,td{border-bottom:1px solid #d3d3d3;padding:5px}table th{font-weight:700}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.section-title{font-family:fangsong,old standard tt,serif}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:16px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:16px}#content h1{font-size:22px}#content h2{font-size:20px}#content h3{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style>
<script>var _hmt=_hmt||[];(function(){var a=document.createElement("script"),b;a.src="https://hm.baidu.com/hm.js?288e2eb770bdfc3ef2b333b7d845fb2a",b=document.getElementsByTagName("script")[0],b.parentNode.insertBefore(a,b)})()</script>
</head>
<body>
<section id=nav>
<h1 id=site-title><a href=https://blog.hackerpie.com/>Hackerpie</a></h1>
<h3>成长，折腾，保持单纯</h3>
<ul>
</ul>
</section>
<section id=content>
<h1 class=section-title> 在 coding.net 上部署 Jekyll 博客 </h1>
<div id=sub-header>
20/Dec/2014 · 3 minute read
</div>
<div id=toc class="well col-md-4 col-sm-6">
<nav id=TableOfContents>
<ul>
<li><a href=#基本原理>基本原理</a>
<ul>
<li><a href=#1-将-jekyll-博客变为一个在线运行的-rack-程序>1. 将 Jekyll 博客变为一个在线运行的 Rack 程序</a></li>
<li><a href=#2-添加用于-coding-演示平台的启动脚本>2. 添加用于 Coding 演示平台的启动脚本</a></li>
<li><a href=#3-使用-webhook-在-push-后自动重新生成站点内容>3. 使用 Webhook 在 push 后自动重新生成站点内容</a></li>
</ul>
</li>
<li><a href=#总结>总结</a></li>
<li><a href=#其他联想>其他联想</a></li>
</ul>
</nav>
</div>
<div class=entry-content>
<p>自从 <a href=https://ruby-china.org/topics/22858>coding 推出 PaaS 演示平台以及开放自定义域名</a>之后，很多人开始尝试在 coding 上部署自己的博客，其中就有 <a href=http://jekyllrb.com/>jekyll</a>，coding 上就有官方推荐的 <a href=https://coding.net/u/chenwj233/p/jekyll-demo/git>jekyll-demo</a>。但是因为这个 Demo 的 README 文档中只是简单介绍配置步骤而已，没有详细介绍原理以及灵活配置的地方，我在参照着迁移 jekyll 博客的过程中也遇到一些问题。现在写下文章，希望能够把原理理清楚。</p>
<p>**声明：**这篇文章主要是对原来的 Demo 的几个主要思路做一个补充说明，而并非 coding 演示平台使用操作的详细教程，所以在有些细节上不一定覆盖到，建议最终的部署代码需要以官方推荐的 repo 里的代码为主。</p>
<h2 id=基本原理>基本原理</h2>
<p>因为 Coding 提供的演示平台是通用的 PaaS 平台，并非类似 Github 或者 Gitcafe 的 Pages 服务，所以 jekyll 部署到演示平台需要解决三个问题：</p>
<p><strong>1. 运行问题</strong>，blog 需要以常规 Web 程序的方式运行；<br>
<strong>2. 启动脚本</strong>，部署完成后自动启动服务器；<br>
<strong>3. 自动更新</strong>，blog 内容更新 push 后能够自动生成新的页面。</p>
<p>第一个问题我们可以通过 <a href=https://github.com/adaoraul/rack-jekyll>rack-jekyll</a> 解决；第二个问题通过 Coding 约定的 <code>Procfile</code> 文件解决；第三个问题我们通过 Coding 的 <a href=https://coding.net/help/about_git/what_is_web_hook>Webhook</a> 结合脚本解决。</p>
<h3 id=1-将-jekyll-博客变为一个在线运行的-rack-程序>1. 将 Jekyll 博客变为一个在线运行的 Rack 程序</h3>
<p>Jekyll 原本是一个用于生成静态博客站点的框架，但是为了能够在 coding 演示平台上直接运行 Jekyll 博客，我们需要一个能够在 <a href=http://unicorn.bogomips.org/>Unicorn</a> 服务器上运行 Jekyll 的方法。通过原来 coding 提供的 Demo，找到了一个叫 <a href=https://github.com/adaoraul/rack-jekyll>rack-jekyll</a> 的工具。</p>
<p>rack-jekyll 主要的功能如其介绍：</p>
<blockquote>
<p>Transform your Jekyll app into Rack application!</p>
</blockquote>
<p>就是将 Jekyll 作为 <a href=http://rack.github.io/>Rack</a> 程序运行。</p>
<p>首先，为了能够使用 rack-jekyll 以及 unicorn，我们在 <code>Gemfile</code> 文件(如果没有则直接新建即可)中加入:</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>gem <span style=font-style:italic>&#34;rack-jekyll&#34;</span>
gem <span style=font-style:italic>&#34;unicorn&#34;</span>
</code></pre></div><p>这两行，然后执行 <code>bundle install</code> 这样，我们的项目中就成功引入 <code>rack-jekyll</code> 以及 <code>unicorn</code> 了。</p>
<p>其次，因为 unicorn 默认会从项目根目录下的 <code>config.ru</code> 文件启动，再结合 <a href=https://github.com/adaoraul/rack-jekyll#how-to-use-it>rack-jekyll 的使用说明</a> ，我们在 jekyll 项目根目录下要创建一个包含以下内容的文件，并且名字就是 <code>config.ru</code>：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=font-style:italic># config.ru</span>
require <span style=font-style:italic>&#34;rack/jekyll&#34;</span>

run Rack::Jekyll.new
</code></pre></div><p>到此，可以在命令行中 cd 到当前项目根目录，执行 <code>jekyll build</code> 生成站点，然后再执行 <code>unicorn</code> 从默认配置启动服务器，成功启动后，在浏览器中访问“ http://127.0.0.1:8080 ”就可以看到博客了。</p>
<h3 id=2-添加用于-coding-演示平台的启动脚本>2. 添加用于 Coding 演示平台的启动脚本</h3>
<p>上面第一步只是解决了 Jekyll 能够以 Rack 方式运行的问题而已，但是为了部署到 coding 后，项目能够正常启动，我们还需要加入启动命令。</p>
<p>按照 <a href=http://docs.coding.io/ruby.html#%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4>coding 在关于 Ruby 部分的演示平台文档</a> 中的介绍得知，coding 会查找项目根目录下的 <code>Procfile</code> 文件，并将里边的内容作为启动命令，当此文件不存在时，则将默认使用一下启动命令：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=font-style:italic>web</span>: bundle exec rackup config.ru -p $PORT
</code></pre></div><p>按照默认启动命令的格式，我们也可以写出以下 <code>Procfile</code> 文件，用于部署后从 unicorn 启动项目：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=font-style:italic>web</span>: bundle exec unicorn -p $PORT -c ./unicorn.rb
</code></pre></div><p>完成前面两步之后，将代码 push 到 coding 上，再从演示平台一键部署的话，就应该可以成功启动 unicorn 服务器，并且能够访问你的 jekyll 博客了。但是，如果有了新文章呢？怎么自动在站点改动后重新生成站点？</p>
<h3 id=3-使用-webhook-在-push-后自动重新生成站点内容>3. 使用 Webhook 在 push 后自动重新生成站点内容</h3>
<p>coding 为用户提供了 <a href=https://coding.net/help/about_git/what_is_web_hook>webhook</a> 功能，方便用户在 push 代码改动后自动 POST 请求你指定的 Web URL，你可以利用这个 URL 在程序后台完成程序的自动部署等操作。更多的介绍跟使用方法请参考 <a href=https://coding.net/help/about_git/about_web_hook_content>&ldquo;WebHook 的内容是什么？"</a> 以及 <a href=https://coding.net/help/about_git/what_is_web_hook>&ldquo;WebHook 是什么？我该如何使用？"</a>。</p>
<p>为了增加新的入口以接收 coding 的 Webhook 通知，我们可以在 <code>config.ru</code> 中添加新的路由，并且添加响应的处理脚本，这部分的内容我先直接拷贝官方推荐的 <a href=https://coding.net/u/chenwj233/p/jekyll-demo/git/raw/master/config.ru>jekyll demo 的代码</a> 后再做必要的解读：</p>
<pre tabindex=0><code># config.ru
require &quot;bundler/setup&quot;
Bundler.require(:default)

WEBHOOK_TOKEN = ENV['WEBHOOK_TOKEN']

app = Proc.new do |env|
  request = Rack::Request.new(env)
  response = Rack::Response.new
  path_info = request.path_info

  if request.content_type =~ /application\/json/
    params = JSON.parse(request.body.read)
  else
    params = request.params
  end

  if request.post? &amp;&amp; params['token'] == WEBHOOK_TOKEN
    repo_url = params['repository']['url'] rescue nil
    if repo_url
      archive_url = &quot;#{repo_url}/archive/master&quot;
      puts &quot;--&gt; updating to #{params['ref']}..&quot;
      puts `jekyll build`
      `rm -rf $HOME/_posts; curl -s -L -o $TMPDIR/archive.zip #{archive_url}; unzip -qo -d $HOME $TMPDIR/archive.zip; cd $HOME; jekyll build`
      puts &quot;--&gt; done.&quot;
    else
      STDERR.puts &quot;--&gt; error: no url field found in params: #{params}&quot;
    end

    ['200', { 'Conetent-Type' =&gt; 'application/json;charset=utf-8' }, ['ok']]
  else
    ['403', { 'Conetent-Type' =&gt; 'application/json;charset=utf-8' }, [{ error: 'webhook token mismatch!' }.to_json]]
  end
end

jekyll = Rack::Jekyll.new(auto: true)

run Rack::URLMap.new('/' =&gt; jekyll, '/_' =&gt; app)
</code></pre><p>首先，程序在启动时，指定了两个路由入口分别指向不同的后台程序，其中 <code>'/'</code> 路径指向了我们的 <code>jekyll</code> 程序，这个跟原来的配置目的一致；而 <code>'/_'</code> 路径指向了 <code>app</code> 这个程序。</p>
<p>所以，当有外部向服务器发送了一个指向 &ldquo;/<em>&rdquo; 路径（比如“ <a href=http://test.codingapp.com/>http://test.codingapp.com/</a></em> ”）的请求时，服务器在内部启动了 <code>app</code> 的脚本。（注意，如果你希望使用别的路径名来配置 webhook 的入口，只要将下划线改成你需要的路径即可，比如： &ldquo;<a href=http://test.codingapp.com/deploy%22>http://test.codingapp.com/deploy"</a>）。</p>
<p><code>app</code> 脚本首先通过请求的 <code>Content-Type</code> 头信息判断请求格式，并据此从请求中提取请求参数赋给 <code>params</code> 变量；接着脚本验证请求的合法性，要求请求必须是 POST 方式，并且参数中的 <code>token</code> 参数的值必须与我们在 coding 后台中配置的 token 一致。</p>
<p>最后，在确认请求的合法性后，脚本先清空了当前部署的项目，然后下载解压指定分支的最新代码，并且进入项目根目录(<code>$HOME</code>环境变量)重新执行了 <code>jekyll build</code> 命令以重新生成静态站点，见代码：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=font-style:italic>`rm -rf $HOME/_posts; curl -s -L -o $TMPDIR/archive.zip </span><span style=font-weight:700;font-style:italic>#{</span>archive_url<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>; unzip -qo -d $HOME $TMPDIR/archive.zip; cd $HOME; jekyll build`</span>
</code></pre></div><p>其中值得一提的是，<code>archive_url</code>是在前面代码中拼接而来的链接：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>archive_url = <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>#{</span>repo_url<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/archive/master&#34;</span>
</code></pre></div><p>请注意其中硬编码的部分 <code>"archive/master"</code>，其中的 <code>master</code> 指定了是 <code>master</code> 分支上的代码压缩包的路径，所以假如你需要从 master 分支外的分支部署代码，请务必记得将 <code>master</code> 改为对应的分支名，比如我的部署分支是 <code>coding-pages</code>，那我这里的代码就应该改为：</p>
<div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby>archive_url = <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>#{</span>repo_url<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/archive/coding-pages&#34;</span>
</code></pre></div><p>完成 webhook 处理脚本后，需要重新 push 代码并且重新在演示平台部署一次，以使 <code>config.ru</code> 文件里的代码生效。至于如何配置 webhook ，直接参照 coding 的官方文档即可。</p>
<h2 id=总结>总结</h2>
<p>以上的三点主要是对在 coding 上部署 jekyll 博客的关键思路的说明，通过这三点，相信你再去看原来的 <a href=https://coding.net/u/chenwj233/p/jekyll-demo/git/raw/125f456d2dfa4d324e320a57a78adf7fda89c93e/README.md>README</a> 的时候，应该就能很快理解为什么需要配置 <code>WEBHOOK_TOKEN</code> 环境变量以及为什么要配置 webhook 的 URL 为类似 &ldquo;http://host/_&rdquo; 这么奇怪的链接了吧？除此之外，你也可以根据你的需要将脚本中的代码分支从 <code>master</code> 改为你所需要的目标分支了。<br>
其实用 unicorn 运行 jekyll 项目的原理还是非常简单的，知道了这些之后，将你的已有 jekyll 项目直接迁移到 coding 甚至是其他 PaaS 平台上就不是件麻烦的事了。</p>
<h2 id=其他联想>其他联想</h2>
<ol>
<li><a href=http://octopress.org/>Octopress</a> 博客是在 jekyll 的基础上封装而来的更高级也更方便的静态站点框架，所以按照上面的原理，将已有的 octopress 项目部署到 coding 平台上，应该也不是件难事。</li>
<li>Octopress 本身支持另外一种部署方式，就是本地生成静态站点之后，直接执行 <code>rake deploy</code> 将生成后的静态站点 push 到指定的远程 repo 或者指定的分支上，从这个角度考虑，其实也可以为 jekyll 实现类似的脚本，结合 coding 演示平台的 <a href=https://coding.net/help/project_demos/do_you_support_static_html_site>静态站点部署</a> ，就可以直接部署 jekyll 博客了，这种方式就省去了 unicorn 服务器等的配置了，也不需要再使用 webhook 重新生成站点了，而且纯静态站点的方案的最大优点就是，特别节约内存。这种方案只是构想，但是值得一试。如果哪位朋友尝试成功了，请记得在评论里回复一下。</li>
</ol>
</div>
<div id=links>
<a href=https://blog.hackerpie.com/posts/archive/railszhong-jie-he-yamlwen-jian-wan-cheng-shu-ju-dui-jie/>&#171;&nbsp;RAILS中利用YAML文件完成数据对接</a>
<a href=https://blog.hackerpie.com/posts/archive/how-do-i-fix-passenger-application-startup-problem/>How do I fix Passenger application startup problem&nbsp;&#187;</a>
</div>
</section>
</body>
<script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js></script>
<script>hljs.highlightAll()</script>
</html>