<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=MobileOptimized content="320"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content><meta name=baidu-site-verification content="code-O73IxgKIB2"><title>解读 Rails: Migrations</title><script type=application/ld+json>{"@context":"https://schema.org","@type":"Article","headline":"解读 Rails: Migrations","datePublished":"2017-10-14T22:29:00\u002b08:00"}</script><style>.hljs-comment,.hljs-quote{color:#8e908c}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#c82829}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5871f}.hljs-attribute{color:#eab700}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#718c00}.hljs-section,.hljs-title{color:#4271ae}.hljs-keyword,.hljs-selector-tag{color:#8959a8}.hljs{display:block;overflow-x:auto;background:#fff;color:#4d4d4c;padding:.5em}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><link rel=canonical href=https://blog.hackerpie.com/posts/archive/jie-du-rails-migrations/><style>*{border:0;font:inherit;font-size:100%;vertical-align:baseline;margin:0;padding:0;color:#000;text-decoration-skip:ink}body{font-family:open sans,myriad pro,Myriad,sans-serif;font-size:17px;line-height:160%;color:#1d1313;max-width:1000px;margin:auto}p{margin:20px 0;letter-spacing:1pt}table{border-collapse:collapse;border-spacing:0}table th,td{border-bottom:1px solid #d3d3d3;padding:5px}table th{font-weight:700}a img{border:none}img{margin:10px auto;max-width:100%;display:block}.left-justify{float:left}.right-justify{float:right}pre,code{font:12px Consolas,liberation mono,Menlo,Courier,monospace;background-color:#f7f7f7}code{font-size:12px;padding:4px}pre{margin-top:0;margin-bottom:16px;word-wrap:normal;padding:16px;overflow:auto;font-size:85%;line-height:1.45}pre>code{padding:0;margin:0;font-size:100%;word-break:normal;white-space:pre;background:0 0;border:0}pre code{display:inline;padding:0;margin:0;overflow:visible;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}pre code::before,pre code::after{content:normal}em,q,em,dfn{font-style:italic}.sans,html .gist .gist-file .gist-meta{font-family:open sans,myriad pro,Myriad,sans-serif}.mono,pre,code,tt,p code,li code{font-family:Menlo,Monaco,andale mono,lucida console,courier new,monospace}.section-title{font-family:fangsong,old standard tt,serif}.heading,.serif,h1,h2,h3{font-family:old standard tt,serif}figcaption{text-align:center;color:gray;font-size:90%;font-style:italic}strong{font-weight:600}q:before{content:"\201C"}q:after{content:"\201D"}del,s{text-decoration:line-through}blockquote{font-family:old standard tt,serif;text-align:center;padding:50px}blockquote p{display:inline-block;font-style:italic}blockquote:before,blockquote:after{font-family:old standard tt,serif;content:'\201C';font-size:35px;color:#403c3b}blockquote:after{content:'\201D'}hr{width:40%;height:1px;background:#403c3b;margin:25px auto}h1{font-size:35px}h2{font-size:28px}h3{font-size:22px;margin-top:18px}h1 a,h2 a,h3 a{text-decoration:none}h1,h2{margin-top:28px}#sub-header,.date{color:#403c3b;font-size:13px}#sub-header{margin:0 4px}#nav h1 a{font-size:35px;color:#1d1313;line-height:120%}.posts_listing a,#nav a{text-decoration:none}li{margin-left:20px}ul li{margin-left:5px}ul li{list-style-type:none}ul li:before{content:"\00BB \0020"}#nav ul li:before,.posts_listing li:before{content:'';margin-right:0}#content{text-align:left;width:100%;font-size:15px;padding:60px 0 80px}#content h1,#content h2{margin-bottom:5px}#content h2{font-size:25px}#content .entry-content{margin-top:15px}#content .date{margin-left:3px}#content h1{font-size:30px}.highlight{margin:10px 0}.posts_listing{margin:0 0 50px}.posts_listing li{margin:0 0 25px 15px}.posts_listing li a:hover,#nav a:hover{text-decoration:underline}#nav{text-align:center;position:static;margin-top:60px}#nav ul{display:table;margin:8px auto 0}#nav li{list-style-type:none;display:table-cell;font-size:15px;padding:0 20px}#links{display:flex;justify-content:space-between;margin:50px 0 0}#links :nth-child(1){margin-right:.5em}#links :nth-child(2){margin-left:.5em}#not-found{text-align:center}#not-found a{font-family:old standard tt,serif;font-size:200px;text-decoration:none;display:inline-block;padding-top:225px}@media(max-width:750px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:28px}#nav li{font-size:13px;padding:0 15px}#content{margin-top:0;padding-top:50px;font-size:14px}#content h1{font-size:25px}#content h2{font-size:22px}.posts_listing li div{font-size:12px}}@media(max-width:400px){body{padding-left:20px;padding-right:20px}#nav h1 a{font-size:22px}#nav li{font-size:16px;padding:0 10px}#content{margin-top:0;padding-top:20px;font-size:16px}#content h1{font-size:22px}#content h2{font-size:20px}#content h3{font-size:18px}.posts_listing li div{font-size:12px}}@media(prefers-color-scheme:dark){*,#nav h1 a{color:#fdfdfd}body{background:#121212}pre,code{background-color:#262626}#sub-header,.date{color:#bababa}hr{background:#ebebeb}}</style><script>var _hmt=_hmt||[];(function(){var e,t=document.createElement("script");t.src="https://hm.baidu.com/hm.js?288e2eb770bdfc3ef2b333b7d845fb2a",e=document.getElementsByTagName("script")[0],e.parentNode.insertBefore(t,e)})()</script></head><body><section id=nav><h1 id=site-title><a href=https://blog.hackerpie.com/>Hackerpie</a></h1><h3>成长，折腾，保持单纯</h3><ul></ul></section><section id=content><h1 class=section-title>解读 Rails: Migrations</h1><div id=sub-header>14/Oct/2017 · 3 minute read</div><div id=toc class="well col-md-4 col-sm-6"><nav id=TableOfContents><ul><li><ul><li><a href=#动身启程>动身启程</a></li><li><a href=#搜寻-migrations>搜寻 migrations</a></li><li><a href=#the-migration>The Migration</a></li><li><a href=#总结recap>总结（Recap）</a></li><li><a href=#喜欢这篇文章>喜欢这篇文章？</a></li></ul></li></ul></nav></div><div class=entry-content><p>此文翻译自<a href=http://www.monkeyandcrow.com/blog/reading_rails_migrations/>Reading Rails - Migrations</a>，限于本人水平，翻译不当之处，敬请指教！</p><p>今天我们将会探讨一下 Rails 经常被忽视的可靠的工作伙伴 —— Migrator。它是如何搜寻你的 migrations 并且执行它们的呢？我们将再一次慢慢地挖掘 Rails 的源代码，并在此过程中慧海拾珠。</p><p>为了跟随本文的步骤，请使用<a href=https://github.com/adamsanderson/qwandry>qwandry</a>打开相关的代码库，或者直接在<a href=https://github.com/rails/rails/tree/5505c1d700f17e2009e1189a7aa6dafafe7062a4>Github</a>上查看这些代码。</p><h3 id=动身启程>动身启程</h3><p>在展开讨论之前，此处并无特殊准备要求。或许你已经创建好了项目所需要的但是仍是空的数据库。如果你执行 <code>rake db:migrate</code>，所有的未执行的 migrations 就会开始执行。让我们从查看 <code>databases.rake</code> 里的 Rake 任务的源码开始动起来：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>desc <span style=font-style:italic>&#34;Migrate the database (options: VERSION=x, VERBOSE=false, SCOPE=blog).&#34;</span>
</span></span><span style=display:flex><span>task <span style=font-style:italic>:migrate</span> =&gt; [<span style=font-style:italic>:environment</span>, <span style=font-style:italic>:load_config</span>] <span style=font-weight:700>do</span>
</span></span><span style=display:flex><span>  ActiveRecord::Migration.verbose = ENV[<span style=font-style:italic>&#34;VERBOSE&#34;</span>] ? ENV[<span style=font-style:italic>&#34;VERBOSE&#34;</span>] == <span style=font-style:italic>&#34;true&#34;</span> : <span>true</span>
</span></span><span style=display:flex><span>  ActiveRecord::Migrator.migrate(ActiveRecord::Migrator.migrations_paths, ENV[<span style=font-style:italic>&#34;VERSION&#34;</span>] ? ENV[<span style=font-style:italic>&#34;VERSION&#34;</span>].to_i : <span>nil</span>)
</span></span><span style=display:flex><span>  <span style=font-style:italic>#...</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p>虽然我们并不打算揭露 Rake 本身的工作机制，但是值得注意的是，执行 <code>migrate</code> 要求另外两个任务 <code>[:environment, :load_config]</code> 的首先执行。这能确保 Rails 的运行环境以及你的 <code>database.yml</code> 文件被加载进来。</p><p>上面的 rake 任务通过环境变量配置了 <code>ActiveRecord::Migration</code> 以及 <code>ActiveRecord::Migrator</code>。环境变量是一种非常有效的可用于向你的应用程序传递信息的方式。缺省地，诸如<code>USER</code>的很多（环境）变量都是已经设置好的，他们也可以在每个（终端）命令执行时单独设置。举个例子，如果你通过 <code>VERBOSE=false rake db:migrate</code> 调用了 Rake 任务，<code>ENV["VERBOSE"]</code>的值就会是字符串<code>"false"</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-style:italic># 通过环境变量启动 irb：</span>
</span></span><span style=display:flex><span><span style=font-style:italic># &gt; FOOD=cake irb</span>
</span></span><span style=display:flex><span>ENV[<span style=font-style:italic>&#39;FOOD&#39;</span>]     <span style=font-style:italic>#=&gt; &#39;cake&#39;</span>
</span></span><span style=display:flex><span>ENV[<span style=font-style:italic>&#39;USER&#39;</span>]     <span style=font-style:italic>#=&gt; &#39;adam&#39;</span>
</span></span><span style=display:flex><span>ENV[<span style=font-style:italic>&#39;WAFFLES&#39;</span>]  <span style=font-style:italic>#=&gt; nil</span>
</span></span></code></pre></div><p>migration 的真正工作是从 <code>ActiveRecord::Migrator.migrate</code> 开始的，这个方法接受了第一个参数，用于表示 migrations 文件可能存在的路径的集合，另外还有一个可选参数，用于表示 migrate 执行的目标版本。</p><h3 id=搜寻-migrations>搜寻 migrations</h3><p>现在就打开 ActiveRecord 里的 <code>migration.rb</code> 文件，不过在深入探究之前，先查看下在这个文件里最上面定义的异常。定义自定义的异常是非常容易的，<code>migration.rb</code> 里就有一些不错的例子：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-weight:700>module</span> <span style=font-weight:700>ActiveRecord</span>
</span></span><span style=display:flex><span>  <span style=font-style:italic># 可以用于在回滚过程中中止 migrations 的异常类</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>class</span> <span style=font-weight:700>IrreversibleMigration</span> &lt; ActiveRecordError
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>#...</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>class</span> <span style=font-weight:700>IllegalMigrationNameError</span> &lt; ActiveRecordError<span style=font-style:italic>#:nodoc:</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> initialize(name)
</span></span><span style=display:flex><span>      <span style=font-weight:700>super</span>(<span style=font-style:italic>&#34;Illegal name for migration file: </span><span style=font-weight:700;font-style:italic>#{</span>name<span style=font-weight:700;font-style:italic>}</span><span style=font-weight:700;font-style:italic>\n\t</span><span style=font-style:italic>(only lower case letters, numbers, and &#39;_&#39; allowed)&#34;</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>#...</span>
</span></span></code></pre></div><p>像我们在之前讲 <a href=https://blog.hackerpie.com/blog/articles/2014/03/05/jie-du-rails-chu-li-yi-chang/>Rails 处理异常</a> 的文章中一样，自定义异常能够被特别处理。在这个案例里，<code>IrreversibleMigration</code> 表示当前的 <code>migration</code> 不能被回滚。另外一个需要定义你自己的异常的原因是，可以像<code>IllegalMigrationNameError</code>一样，通过重定义<code>initialize</code>方法来实现生成一致的错误消息。同时，要确保你调用了 <code>super</code>。</p><p>现在向下滚动（文件），让我们看看 <code>Migrator.migrate</code>：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Migrator</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>class</span> &lt;&lt; self
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> migrate(migrations_paths, target_version = <span>nil</span>, &amp;block)
</span></span><span style=display:flex><span>      <span style=font-weight:700>case</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>when</span> target_version.nil?
</span></span><span style=display:flex><span>        up(migrations_paths, target_version, &amp;block)
</span></span><span style=display:flex><span>      <span style=font-style:italic>#...</span>
</span></span><span style=display:flex><span>      <span style=font-weight:700>when</span> current_version &gt; target_version
</span></span><span style=display:flex><span>        down(migrations_paths, target_version, &amp;block)
</span></span><span style=display:flex><span>      <span style=font-weight:700>else</span>
</span></span><span style=display:flex><span>        up(migrations_paths, target_version, &amp;block)
</span></span><span style=display:flex><span>      <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>#...</span>
</span></span></code></pre></div><p>取决于 <code>target_version</code>，我们将通过 <code>up</code> 或者 <code>down</code> 完成 migrate。这两个方法遵循了同样的模式，都是扫描了 <code>migration_paths</code> 里的可执行的 migrations，然后初始化一个新的 <code>Migrator</code> 的实例。让我们看看这些 migrations 是如何被搜寻到的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Migrator</span>
</span></span><span style=display:flex><span>  <span style=font-weight:700>class</span> &lt;&lt; self
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> migrations(paths)
</span></span><span style=display:flex><span>      paths = Array(paths)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      files = Dir[*paths.map { |p| <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>#{</span>p<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/**/[0-9]*_*.rb&#34;</span> }]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      migrations = files.map <span style=font-weight:700>do</span> |file|
</span></span><span style=display:flex><span>        version, name, scope = file.scan(<span style=font-style:italic>/([0-9]+)_([_a-z0-9]*)\.?([_a-z0-9]*)?\.rb\z/</span>).first
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=font-weight:700>raise</span> IllegalMigrationNameError.new(file) <span style=font-weight:700>unless</span> version
</span></span><span style=display:flex><span>        version = version.to_i
</span></span><span style=display:flex><span>        name = name.camelize
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        MigrationProxy.new(name, version, file, scope)
</span></span><span style=display:flex><span>      <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>      migrations.sort_by(&amp;<span style=font-style:italic>:version</span>)
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span></code></pre></div><p>这个方法里满是非常值得学习的实例，让我们停留几分钟并且仔细阅读它。最开始，代码里通过一个 <code>Array()</code> 方法这样的小技巧，确保了参数始终是数组类型。“你说这（Array）是个方法？”是的！这虽然不是很正统，但定义一个驼峰式命名的方法是合法的，甚至这样的方法名还可以和类同名：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>Flummox</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>def</span> Flummox()
</span></span><span style=display:flex><span>  <span style=font-style:italic>&#34;confusing&#34;</span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Flummox       <span style=font-style:italic>#=&gt; Flummox</span>
</span></span><span style=display:flex><span>Flummox.new   <span style=font-style:italic>#=&gt; #&lt;Flummox:0x0000000bf0b5d0&gt;</span>
</span></span><span style=display:flex><span>Flummox()     <span style=font-style:italic>#=&gt; &#34;confusing&#34;</span>
</span></span></code></pre></div><p>Ruby 使用了这个特性定义了一个 <code>Array()</code> 方法，这个方法始终返回一个数组。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>Array(<span>nil</span>)                <span style=font-style:italic>#=&gt; []</span>
</span></span><span style=display:flex><span>Array([])                 <span style=font-style:italic>#=&gt; []</span>
</span></span><span style=display:flex><span>Array(1)                  <span style=font-style:italic>#=&gt; [1]</span>
</span></span><span style=display:flex><span>Array(<span style=font-style:italic>&#34;Hello&#34;</span>)            <span style=font-style:italic>#=&gt; [&#34;Hello&#34;]</span>
</span></span><span style=display:flex><span>Array([<span style=font-style:italic>&#34;Hello&#34;</span>, <span style=font-style:italic>&#34;World&#34;</span>]) <span style=font-style:italic>#=&gt; [&#34;Hello&#34;, &#34;World&#34;]</span>
</span></span></code></pre></div><p>这个方法类似于 <code>to_a</code>，但是可以在任何（类型的）对象上调用。Rails 通过 <code>paths = Array(paths)</code>使用了这个（方法），得以确保 <code>paths</code> 将是一个数组。</p><p>在接下来一行的代码里，Rails 搜寻了指定的路径并且进行了过滤：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>files = Dir[*paths.map { |p| <span style=font-style:italic>&#34;</span><span style=font-weight:700;font-style:italic>#{</span>p<span style=font-weight:700;font-style:italic>}</span><span style=font-style:italic>/**/[0-9]*_*.rb&#34;</span> }]
</span></span></code></pre></div><p>让我们将这个代码分解一下。<code>paths.map { |p| "#{p}/**/[0-9]*_*.rb" }</code>将每一个路径转换成一个 [<code>shell glob</code>](<a href=http://en.wikipedia.org/wiki/Glob_(programming>http://en.wikipedia.org/wiki/Glob_(programming</a>))。一个类似 <code>"db/migrate"</code> 的路径就变成了 <code>"db/migrate/**/[0-9]*_*.rb"</code>，这将会在 <code>"db/migrate"</code> 或者它的所有子目录里匹配所有用数字开头的文件。这些（shell glob 表示的）路径通过 <code>*</code> 操作符分成（单个元素）并且传递给了 <code>Dir[]</code>。</p><p><code>Dir[]</code> 是非常有用的。它接收类似 <code>"db/migrate/**/[0-9]*_*.rb"</code> 这样的模式（作为参数），然后返回匹配的文件列表。当你需要在指定路径里查找文件的时候，<code>Dir[]</code> 就是称手利器。其中，<code>**</code> 表示递归地在所有子目录中执行匹配，而 <code>*</code> 则表示一个或多个字符的通配符，也就是说，前面的这个模式就是为了匹配类似 <code>20131127051346_create_people.rb</code> 的 migrations （文件）。</p><p>Rails 遍历每一个匹配的文件，并且通过 <code>String#scan</code> 结合正则表达式提取信息。如果你对正则表达式不是很熟悉，那现在就应该抛开一切，先学习好正则表达式再说。<code>String#scan</code> 以字符串形式返回所有匹配的结果。如果表达式里还包含了 capturing groups（匹配分组），它们将会以内嵌数组（subarrays）的方式返回。比如：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>s = <span style=font-style:italic>&#34;123 abc 456&#34;</span>
</span></span><span style=display:flex><span><span style=font-style:italic># 没有 capturing groups:</span>
</span></span><span style=display:flex><span>s.scan(<span style=font-style:italic>/\d+/</span>)           <span style=font-style:italic>#=&gt; [&#34;123&#34;, &#34;456&#34;]</span>
</span></span><span style=display:flex><span>s.scan(<span style=font-style:italic>/\d+\s\w+/</span>)      <span style=font-style:italic>#=&gt; [&#34;123 abc&#34;]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># 先匹配数字，再匹配单词：</span>
</span></span><span style=display:flex><span>s.scan(<span style=font-style:italic>/(\d+)\s+(\w+)/</span>) <span style=font-style:italic>#=&gt; [[&#34;123&#34;, &#34;abc&#34;]]</span>
</span></span></code></pre></div><p>所以 <code>file.scan</code> 将会匹配版本号<code>([0-9]+)</code>，名字<code>([_a-z0-9]*)</code>，以及一个可选的 scope <code>([_a-z0-9]*)?</code>。由于 <code>String#scan</code> 始终返回数组，并且我们知道这个模式只会出现一次，所以 Rails 直接提取第一个匹配结果。Rails 一次性执行了多个变量赋值 <code>version, name, scope = ...</code>。这是得益于数组的解构：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>version, name, scope = [<span style=font-style:italic>&#34;20131127051346&#34;</span>, <span style=font-style:italic>&#34;create_people&#34;</span>]
</span></span><span style=display:flex><span>version <span style=font-style:italic>#=&gt; &#34;20131127051346&#34;</span>
</span></span><span style=display:flex><span>name    <span style=font-style:italic>#=&gt; &#34;create_people&#34;</span>
</span></span><span style=display:flex><span>scope   <span style=font-style:italic>#=&gt; nil</span>
</span></span></code></pre></div><p>注意一下，如果（等号左边）变量的数量大于（等号右边）数组的元素的数量，多余变量的值将会被赋值为<code>nil</code>。这是一种从正则表达式（匹配后的值）进行多个赋值的快捷技巧。</p><p>匹配的版本号 version 通过 <code>to_i</code> 方法转换为一个整数（Fixnum），而同时，名字 name 通过 <code>name.camelize</code> 完成了格式转换。<code>String#camelize</code>是 <code>ActiveSupport</code> 里的方法，用于下划线命名 <code>snake_case</code> 和 驼峰式命名 <code>CamelCase</code> 之间的相互转换。这个方法可以将 <code>"create_people"</code> 转换为 <code>CreatePeople</code>。</p><p>让我们过会再看下 <code>MigrationProxy</code>，现在先看下 <code>Migrator#migrations</code> 这个方法的最后一个部分，<code>migrations.sort_by(&:version)</code>。这个表达式将所有 migrations 基于版本号进行了排序。如何排序的方式会是更有趣的内容。</p><p>从 Ruby 1.9 开始，<code>&</code>操作将会在被它作用的对象上调用 <code>to_proc</code> 方法。当在一个 symbol 上调用时，返回的结果是一个代码块里调用与 symbol 同命名的方法的 <code>Proc</code> 对象。所以 <code>&:version</code> 等同于某行代码的 <code>{|obj| obj.version }</code>。</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>Library = Struct.new(<span style=font-style:italic>:name</span>, <span style=font-style:italic>:version</span>)
</span></span><span style=display:flex><span>libraries = [
</span></span><span style=display:flex><span>  Library.new(<span style=font-style:italic>&#34;Rails&#34;</span>, <span style=font-style:italic>&#34;4.0.1&#34;</span>),
</span></span><span style=display:flex><span>  Library.new(<span style=font-style:italic>&#34;Rake&#34;</span>, <span style=font-style:italic>&#34;10.1.0&#34;</span>)
</span></span><span style=display:flex><span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>libraries.map{|lib| lib.version } <span style=font-style:italic>#=&gt; [&#34;4.0.1&#34;, &#34;10.1.0&#34;]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-style:italic># &amp;:version =&gt; Proc.new{|lib| lib.version } (Roughly)</span>
</span></span><span style=display:flex><span>libraries.map(&amp;<span style=font-style:italic>:version</span>)          <span style=font-style:italic>#=&gt; [&#34;4.0.1&#34;, &#34;10.1.0&#34;]</span>
</span></span></code></pre></div><p>在 Rails 里，这种技巧在排序或者映射的时候非常常见。和众多的技巧一样，请确认你的团队能够适应这种语法。如有疑虑，更好的方案就是不再使用（这种技巧），这会让代码更清晰。</p><h3 id=the-migration>The Migration</h3><p>现在，回到 <code>MigrationProxy</code>。顾名思义，只是一个 <code>Migration</code> 的实例的代理。代理对象（Proxy objects）是一个常见的用于透明地将一个对象替换为另一个对象的设计模式。在这个例子中，<code>MigrationProxy</code>代替了一个真正的 <code>Migration</code> 对象，而且除非必需，它会延缓对 migration 的源码的实际的加载。<code>MigrationProxy</code> 通过委托方法（delegating methods）达到目的：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-weight:700>class</span> <span style=font-weight:700>MigrationProxy</span>
</span></span><span style=display:flex><span>  <span style=font-style:italic>#...</span>
</span></span><span style=display:flex><span>  delegate <span style=font-style:italic>:migrate</span>, <span style=font-style:italic>:announce</span>, <span style=font-style:italic>:write</span>, <span style=font-style:italic>:disable_ddl_transaction</span>, <span style=font-style:italic>to</span>: <span style=font-style:italic>:migration</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span>private</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> migration
</span></span><span style=display:flex><span>      @migration ||= load_migration
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=font-weight:700>def</span> load_migration
</span></span><span style=display:flex><span>      require(File.expand_path(filename))
</span></span><span style=display:flex><span>      name.constantize.new
</span></span><span style=display:flex><span>    <span style=font-weight:700>end</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=font-weight:700>end</span>
</span></span></code></pre></div><p><code>delegate</code> 方法将它的每一个参数都发送给了 <code>to:</code> 选项返回的对象，在这里，这个对象就是我们的 <code>migration</code>。如果 <code>@migration</code> 实例变量尚未定义或赋值，<code>migration</code> 方法将会执行懒加载migration <code>load_migration</code>。<code>load_migration</code> 方法按序加载(require) ruby 源码，然后使用 <code>name.constantize.new</code> 创建一个新的实例。<code>String#constantize</code> 是 ActiveSupport 中定义的方法，用于返回名字与字符串相同的常量：</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span><span style=font-style:italic>&#34;Person&#34;</span>.constantize       <span style=font-style:italic>#=&gt; Person</span>
</span></span><span style=display:flex><span><span style=font-style:italic>&#34;Person&#34;</span>.constantize.class <span style=font-style:italic>#=&gt; Class</span>
</span></span><span style=display:flex><span><span style=font-style:italic>&#34;person&#34;</span>.constantize       <span style=font-style:italic>#=&gt; NameError: wrong constant name person</span>
</span></span></code></pre></div><p>当你想要动态地引用一个类时，这个技巧非常有效。</p><p>通过 <code>MigrationProxy</code>，Rails 只加载并且实例化必要的 migrations，这能为 migration 的处理提速，同时节约更多内存。</p><p>真正的 <code>Migration</code> 类在代理委托了 <code>migrate</code> 方法的时候才被 <code>Migrator</code> 调用。这个按序调用 <code>Migration#up</code> 或者 <code>Migration#down</code> 取决于 migration 是在先前执行，还是在执行回滚。</p><h3 id=总结recap>总结（Recap）</h3><p>我们仅仅只是一瞥了 Rails 的 migration 机制的源码的表面，但是我们却已经学到了一些有趣的知识。Migrations 由一个调用了 <code>Migrator</code> 的 Rake 任务启动，<code>Migrator</code> 又按序查找到了我们的 migrations，并且使用了 <code>MigrationProxy</code> 对象对这些 migrations 进行了包装，直到真正的 <code>Migration</code> 需要被执行的时候。</p><p>一如既往，我们已经了解了一些有趣的方法、习惯以及技巧：</p><ul><li>环境变量可以通过 <code>ENV</code> 常量访问；</li><li>定义自定义的异常类，是一种常见的对异常进行处理的手段；</li><li><code>Array()</code> 方法将任意对象转换为数组；</li><li><code>Dir[]</code> 使用 <code>shell glob</code> 语法搜索文件；</li><li><code>String#scan</code> 返回字符串里所有匹配的结果，并且支持匹配分组（capturing groups）；</li><li><code>String#camelize</code> 将下划线形式（snake_case）字符串转换为驼峰式（CamelCase）;</li><li><code>&</code> 操作符在符号类型的对象上调用时，会创建一个 <code>Proc</code> 对象</li><li><code>delegate</code> 可以用于实现代理的设计模式</li><li>可以通过 <code>String#contantize</code> 方法动态加载常量</li></ul><p>下一次，或许我们就能弄明白 <code>Migrator</code> 是如何确切知道哪些 migrations 已经在你的数据库里执行过。</p><h3 id=喜欢这篇文章>喜欢这篇文章？</h3><p><a href=https://blog.hackerpie.com/blog/articles/2014/03/02/jie-du-rails-xi-lie-fan-yi/>阅读更多</a>“解读Rails”中的文章。“解读Rails”中的文章。</p></div><div id=links><a href=https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/>&#171;&nbsp;动态密码算法介绍与实现</a>
<a href=https://blog.hackerpie.com/posts/2018/ji-yi-ci-redisshu-ju-ku-pei-zhi-dao-zhi-de-lian-jie-shu-xie-lou-de-wen-ti/>记一次Redis数据库配置导致的连接数泄露的问题&nbsp;&#187;</a></div></section></body><script src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.2/highlight.min.js></script>
<script>hljs.highlightAll()</script><script src=https://cdn.jsdelivr.net/gh/jmnote/plantuml-encoder@1.2.4/dist/plantuml-encoder.min.js integrity="sha256-Qsk2KRBCN5qVZX7B+8+2IvQl1Aqc723qV1tBCQaVoqo=" crossorigin=anonymous></script>
<script>(function(){let e="language-plantuml";Array.prototype.forEach.call(document.querySelectorAll("[class^="+e+"]"),function(e){let t=document.createElement("IMG");t.loading='lazy',t.src='http://www.plantuml.com/plantuml/svg/~1'+plantumlEncoder.encode(e.innerText),e.parentNode.insertBefore(t,e),e.style.display='none'})})()</script></html>