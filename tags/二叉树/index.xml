<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>二叉树 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/</link><description>Recent content in 二叉树 on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 31 Jul 2021 18:20:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/index.xml" rel="self" type="application/rss+xml"/><item><title>算法题解：二叉树寻路</title><link>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</link><pubDate>Sat, 31 Jul 2021 18:20:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/binary-tree/binary-tree-routine/</guid><description>本题来自 Leetcode 的 1104 题，是一道很有趣的考察二叉树数据结构的题，同时由于二叉树父子节点之间的特殊关系，同时还可以运用到位运算来巧妙解题。
先贴一下题目：
在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。
如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；
而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。 给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。
示例 1：
输入：label = 14 输出：[1,3,4,14] 示例 2：
输入：label = 26 输出：[1,2,6,10,26] 算法题解思路1：运用二叉树的节点的数值特性推导出公式求解 观察这个“之”字形二叉树，我们可以得出几个特点：
假如所有节点都是按照从左到右依次递增，按照二叉树的特性，我们可以归纳总结出： 记 vi = 某个节点的数值 v(左子节点) = 2 x vi v(右子节点) = 2 x vi + 1 相反： v(父节点) = vi / 2 对于每层(第一层为根节点)的第一个和最后一个节点，会有： v（第一个节点）= 2^(n-1) // 2 的 n-1 次方，n为当前层数 v（最后一个节点）= 2^n - 1 // 2 的 n 次方减 1，n为当前层数 对于任意一个数值，可以求出其所在的层数为： level = log2(N) + 1 从根节点开始，所有奇数层的节点是从左到右依次递增的；而所有偶数层的节点是从右到左依次递增的； 对于某一层的所有节点来说，它们都是一个等差数列，所以数列对称位置上的两个节点数值之和总是相等，即第一个节点和最后一个节点的值之和一定等于第二个节点和倒数第二个节点的值之和。结合第 2 点，这个和始终为 2^(n-1) + 2^n - 1。 结合以上5点性质，我们写出求任意一个节点的伪代码为：</description></item></channel></rss>