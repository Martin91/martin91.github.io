<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>时间回拨 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8/</link><description>Recent content in 时间回拨 on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 27 Mar 2022 16:18:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E6%97%B6%E9%97%B4%E5%9B%9E%E6%8B%A8/index.xml" rel="self" type="application/rss+xml"/><item><title>多时钟解决雪花算法的时间回拨问题</title><link>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</link><pubDate>Sun, 27 Mar 2022 16:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</guid><description>&lt;p>分布式 ID 生成算法用于在分布式系统中生成全局唯一的 ID 标识，而 twitter 提出的雪花算法便是其中一种知名的算法，其每次会生成一个 64 位的全局唯一整数，算法的基本思想非常巧妙：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span> 0 1010......101 1010101010 101010101010
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="">\&lt;/span>_/ &lt;span style="">\&lt;/span>___________/ &lt;span style="">\&lt;/span>________/ &lt;span style="">\&lt;/span>__________/
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>第1位不使用 41位毫秒时间戳 10位机器ID 12位序列号
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>除了开头的第 1 位不使用，接下来的 41 位时间戳是从指定的起始时间到当前时间所经历的毫秒数，比如设定系统起始时间为 2022 年 3 月 15 日 0 点整，则在 2022 年 4 月 1 日中午 12:00:00.123 时，此时间戳的值应该为 &lt;code>1,512,000,123&lt;/code>，整个时间戳片段，支持最多 &lt;code>69.7&lt;/code> 年，这显然也超出了绝大多数 IT 系统的存活年限。&lt;/p>
&lt;p>而 10 位机器 ID，对应最多容纳一个 1024 个 ID 生成器实例的分布式集群，12 位序列号从 0 到 4095 周而复始连续递增，可以支持单个实例每毫秒 4096 次 ID 生成请求，意味着整个 ID 生成器实例的集群，理论上每毫秒便可以支持最多 &lt;code>4194304&lt;/code> 个 ID 生成，效率非常高。&lt;/p>
&lt;p>雪花算法生成的 ID 的全局唯一的理论基础是全局唯一性与单实例唯一性的结合，全局唯一性由唯一的机器 ID 保证，不同的机器ID保证不同实例生成的 ID 必然不会一致，而单实例唯一由同一毫秒结合不同的序列号来保证，这里的序列号只能做到理论上限，即理论上一毫秒内不会有超过 4096 次的请求。&lt;/p></description></item></channel></rss>