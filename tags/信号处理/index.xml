<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>信号处理 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/</link><description>Recent content in 信号处理 on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 20 Nov 2016 10:08:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86/index.xml" rel="self" type="application/rss+xml"/><item><title>Sidekiq 信号处理源码分析</title><link>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</link><pubDate>Sun, 20 Nov 2016 10:08:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/sidekiq-xin-hao-chu-li-yuan-ma-fen-xi/</guid><description>引言 在之前的文章《Sidekiq任务调度流程分析》中，我们一起仔细分析了 Sidekiq 是如何基于多线程完成队列任务处理以及调度的。我们在之前的分析里，看到了不管是 Sidekiq::Scheduled::Poller 还是 Sidekiq::Processor 的核心代码里，都会有一个由 @done 实例变量控制的循环体：
# https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/scheduled.rb#L63-L73 def start @thread ||= safe_thread(&amp;#34;scheduler&amp;#34;) do initial_wait while !@done # 这是 poller 的循环控制 enqueue wait end Sidekiq.logger.info(&amp;#34;Scheduler exiting...&amp;#34;) end end # https://github.com/mperham/sidekiq/blob/5ebd857e3020d55f5c701037c2d7bedf9a18e897/lib/sidekiq/processor.rb#L66-L77 def run begin while !@done # 这是我们常说的 worker 循环控制 process_one end @mgr.processor_stopped(self) rescue Sidekiq::Shutdown @mgr.processor_stopped(self) rescue Exception =&amp;gt; ex @mgr.processor_died(self, ex) end end 也就是说，这些 @done 实例变量决定了 poller 线程跟 worker 线程是否循环执行？一旦 @done 被改为 true，那循环体就不再执行，线程自然也就是退出了。于是，单从这些代码，我们可以断定， Sidekiq 就是通过设置 @done 的值来通知一个线程安全退出（graceful exit）的。我们也知道，生产环境中，我们是通过发送信号的方式来告诉 sidekiq 退出或者进入静默(quiet)状态的，那么，这里的 @done 是怎么跟信号处理联系起来的呢？这些就是今天这篇文章的重点了！</description></item></channel></rss>