<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Active_support on Hackerpie</title><link>https://blog.hackerpie.com/tags/active_support/</link><description>Recent content in Active_support on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Fri, 30 Oct 2015 20:48:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/active_support/index.xml" rel="self" type="application/rss+xml"/><item><title>谨防 ActiveSupport::Cache::Store 缓存 nil 值</title><link>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</link><pubDate>Fri, 30 Oct 2015 20:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jin-fang-activesupport-cache-store-huan-cun-nil-zhi/</guid><description>Rails 中的 active_support 组件主要基于 Rails 需要提供了很多非常有用的基础工具以及对 Ruby 内置类进行扩展。其中的 cache 模块主要提供了 Rails 中底层缓存的定义以及简单实现。今天要跟大家探讨的是之前在使用此模块所遇到的一个坑，有兴趣学习其基本用法的可以点击以下两个链接：
Rails Guides: ActiveSupport::Cache::Store Rails API: ActiveSupport::Cache::Store 从 ActiveSupport::Cache::Store#fetch 聊起 之前在实现一个需要从外部服务请求数据的功能时，处于性能考虑，我在代码中使用了缓存，并且设置缓存失效时间为 7 天，示例代码如下：
def read_external_service(params) # 这段代码稍微解释下： # 当缓存命中时，则直接读取缓存，如果无期待缓存，则通过 HTTP 向外请求结果，并且将结果 # 缓存下来，这样子，当下次继续调用时，则可直接返回缓存内容，而无需重复向外请求 # Rails.cache.fetch &amp;#39;example_cache_key_here&amp;#39;, expires_in: 7.days do response = HTTParty.get &amp;#39;https://example.com/example/request/path&amp;#39; JSON.parse(response.body)[&amp;#34;data&amp;#34;] end end 上面的代码其实不复杂，核心代码就是使用了 ActiveSupport::Cache::Store#fetch 方法。
一切都很正常地运行着，直到有一天，线上系统不断报警，出错原因就是这段代码总是返回 nil ，而调用者又因为没有判断 nil 值，就会出现 undefined method 'xxx' for nil:NilClass 错误。在 debug 时，我尝试了直接调用外部服务接口，发现请求都有正确返回数据，不可能返回 nil 啊，难道是缓存了 nil 值？下面就直接通过代码验证一下！
[1] pry(main)&amp;gt; require &amp;#39;active_support&amp;#39; =&amp;gt; true [2] pry(main)&amp;gt; cache = ActiveSupport::Cache::MemoryStore.</description></item></channel></rss>