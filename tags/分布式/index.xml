<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>分布式 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/</link><description>Recent content in 分布式 on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 28 Oct 2020 19:48:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>《Paxos Made Simple》中文翻译：Paxos 如此简单</title><link>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</link><pubDate>Wed, 28 Oct 2020 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2020/paxos-made-simple-translation/</guid><description>写在前面 个人在学习理解 Paxos 算法的过程中，花了比较多的时间，从最开始直接查看中文博客资料，感觉都是看完不知所以然或者有很多疑问，于是决定死磕《Paxos Made Simple》论文原文。但是由于有些英文的意思我自己理解起来还是有点困惑，于是过程中遇到无法理解的内容，一方面是会翻阅前辈们已经写过的论文的翻译作为参考，二是在搜索引擎里就一些难以理解的点搜索中英文的讨论，以此解决自己心中的困惑。在磕磕碰碰中完成论文的阅读之后，仍有一些不尽透彻之处，加上个人认为此论文已有的翻译质量参差不齐，所以斗胆想通过翻译以及必要译注再次加深自己的理解，另外可能的话，也希望本次翻译能够帮助到未来可能会遇到和我一样困惑的人。
部分关键术语表 论文中有一些关键术语，我已经力求用词准确，并在论文中尽力保持术语翻译的一致性，目的是尽量充分传达论文本身用词的精准，建议读者可先仔细阅读此表。
原文术语 翻译中使用术语 译者注 value(s) 值 值可能比较抽象，觉得太抽象的读者建议理解为提案的“内容”亦可 learn 获知 有些文章译作“了解”或者“学习”，但是这里反复斟酌，还是觉得“获知”更贴切，目的性更强烈 propose 提议 chosen 选定 一个被选定的值，意味着一个被“一致”确认下来的值 agent 代理 依旧觉得翻译成“代理”过于字面化 proposer(s) 提议者 acceptor(s) 接受者 learner(s) 学习者 fail / failure 失效/故障 意味着系统已经完全不能工作 proposal 提案 accept 接受 number 编号 distinguished 特定的 文中用于形容某个经过选举而被选中的角色 翻译全文 Paxos 如此简单 2001年11月1日
摘要 当用浅显易懂的英语来表达的话，Paxos 是非常简单的。
1 导引 Paxos 算法——一个用于实现一个容忍错误的分布式系统的算法，让很多人觉得难以理解，这可能是因为对于很多读者们而言，原来的表述太过于让人摸不着头脑1了。事实上，它是最简单浅显的分布式算法。它的核心是一个一致性算法——“synod”算法2。在下一节中，将会看到这个一致性算法不可避免地遵循一些我们希望它能够满足的特性。最后一节阐述了完整的 Paxos 算法，这个算法是通过将一致性（的实现）直接应用到用于构建分布式系统的（多副本）状态机3这种方法中得到的——这种所谓的方法应该是众所周知的，因为它是分布式系统理论中最常被引用的论文的主题。
2 一致性算法 2.1 问题描述 假设有一个由多个进程组成的集合，集合里的每个进程都可以提议（可能不同的）值4。一致性算法保证在被提议的这些值中只有一个值能够被选定。一旦一个值被选定，则所有进程都需要能够获知（learn）这个被选定的值。一致性的安全性要求做到：
只有被提议的值才可以被选定， 只能有一个值能被选定， 只有一个值真的已经“确定”被选定，进程才能获知这个值已被选定5（译注：只有一致同意后的值，且不可能会被推翻，才能够周知给集合里的进程，结果就能使所有进程达成共识） 我们不会尝试去明确精准的活性要求6。无论如何，（算法的）目标是要保证被提议的值中有某个值能够被选定，并且一旦一个值被选定了，进程最终能够获知这个被选定的值。
我们让三类代理（agent）来执行这个一致性算法中的三个角色：提议者（proposers）、接受者（acceptors）以及学习者（learners）。在实际实现中，一个独立的进程可以充当不止一个代理，但是从代理到进程之间的映射关系不是我们这里关注的重点。
设想代理之间可以通过发送消息的方式相互通信。我们使用传统的异步（模型），而不是拜占庭问题模型，也就是说：
代理以任意速度运行，可能因停止而失效（指不能正常工作），也可能重启。由于所有代理都有可能在一个值被选定之后失效再接着重启，除非失效或者重启的代理能够记住一些关键信息，否则没有任何解决方案。 消息发送的长度可以是任意的，消息也可以重复或者丢失，但消息不会被篡改7。 2.</description></item></channel></rss>