<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>算法 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E7%AE%97%E6%B3%95/</link><description>Recent content in 算法 on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sat, 18 Feb 2017 09:54:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>动态密码算法介绍与实现</title><link>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</link><pubDate>Sat, 18 Feb 2017 09:54:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/dong-tai-mi-ma-suan-fa-jie-shao-yu-shi-xian/</guid><description>动态密码，亦称一次性密码（One Time Password, 简称 OTP），是一种高效简单又比较安全的密码生成算法，在我们的生活以及工作中随处可见，身为开发者，也或多或少在自己的业务系统中集成了二步验证机制，那么，技术运用，既要知其然，更要知其所以然，动态密码算法是怎样的？
读前指引 通过这篇文章，你可以了解以下知识： 动态密码的背景知识 动态密码的分类 不同动态密码的生成算法，HOTP 以及 TOTP HOTP 以及 TOTP 的简单的 Ruby 编程语言的实现 两类算法各自注意事项 限于篇幅，我不会讨论以下几点，有兴趣的同学可以参考我文章末尾给出的参考资料了解： 不同动态密码的安全性分析 计时动态密码如何确保有效期间内，密码不被二次使用 动态密码背景介绍 从我的角度理解，动态密码是指随着某一事件（密码被使用、一定的时间流逝等）的发生而重新生成的密码，因为动态密码本身最大优点是防重复执行攻击(replay attack)，它能很好地避免类似静态密码可能被暴力破解等的缺陷，现实运用中，一般采用“静态密码+动态密码”相结合的双因素认证，我们也称二步验证。
而动态密码其实很早就出现在我们的生活里了，在移动支付发展起来之前，网银是当时最为流行的在线支付渠道，当时银行为了确保大家的网银账号支付安全，都会给网银客户配发动态密码卡，比如中国银行电子口令卡（按时间差定时生成新密码，口令卡自带电池，可保证连续使用几年），或者工商银行的电子银行口令卡（网银支付网页每次生成不同的行列序号，用户根据指定行列组合刮开密码卡上的涂层获取密码，密码使用后失效），又或者银行强制要求的短信验证码，这些都可以纳入动态密码的范畴。
而随着移动互联网的发展以及移动设备的智能化的不断提高，设备间的同步能力大幅提升，以前依赖独立设备的动态密码生成技术很快演变成了手机上的动态密码生成软件，以手机软件的形式生成动态密码的方式极大提高了动态密码的便携性，一个用户一个手机就可以管理任意多个动态密码的生成，这也使得在网站上推动二步验证减少了很多阻力，因为以往客户可能因为使用口令卡太麻烦，而拒绝打开二步验证机制，从而让自己的账号暴露在风险之下。最为知名的动态密码生成软件，当属 Google 的 Authenticator APP。
动态密码算法探索之旅 动态密码的分类 一般来说，常见的动态密码有两类：
**计次使用：**计次使用的OTP产出后，可在不限时间内使用，知道下次成功使用后，计数器加 1，生成新的密码。用于实现计次使用动态密码的算法叫 HOTP，接下来会对这个算法展开介绍； **计时使用：**计时使用的OTP则可设定密码有效时间，从30秒到两分钟不等，而OTP在进行认证之后即废弃不用，下次认证必须使用新的密码。用于实现计时使用动态密码的算法叫 TOTP，接下来会对这个算法展开介绍。 在真正开展算法介绍之前，需要补充介绍的是：动态密码的基本认证原理是在认证双方共享密钥，也称种子密钥，并使用的同一个种子密钥对某一个事件计数、或时间值进行密码算法计算，使用的算法有对称算法、HASH、HMAC等。记住这一点，这个是所有动态密码算法实现的基础。
HOTP HOTP 算法，全称是“An HMAC-Based One-Time Password Algorithm”，是一种基于事件计数的一次性密码生成算法，详细的算法介绍可以查看 RFC 4226。其实算法本身非常简单，算法本身可以用两条简短的表达式描述：
HOTP(K,C) = Truncate(HMAC-SHA-1(K,C)) PWD(K,C,digit) = HOTP(K,C) mod 10^Digit
上式中：
K 代表我们在认证服务器端以及密码生成端（客户设备）之间共享的密钥，在 RFC 4226 中，作者要求共享密钥最小长度是 128 位，而作者本身推荐使用 160 位长度的密钥 C 表示事件计数的值，8 字节的整数，称为移动因子（moving factor），需要注意的是，这里的 C 的整数值需要用二进制的字符串表达，比如某个事件计数为 3，则C是 &amp;quot;11&amp;quot;（此处省略了前面的二进制的数字0） HMAC-SHA-1 表示对共享密钥以及移动因子进行 HMAC 的 SHA1 算法加密，得到 160 位长度（20字节）的加密结果 Truncate 即截断函数，后面会详述 digit 指定动态密码长度，比如我们常见的都是 6 位长度的动态密码 Truncate 截断函数 由于 SHA-1 算法是既有算法，不是我们讨论重点，故而 Truncate 函数就是整个算法中最为关键的部分了。以下引用 Truncate 函数的步骤说明：</description></item></channel></rss>