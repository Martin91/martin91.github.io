<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>唯一ID on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E5%94%AF%E4%B8%80id/</link><description>Recent content in 唯一ID on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 27 Mar 2022 16:18:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E5%94%AF%E4%B8%80id/index.xml" rel="self" type="application/rss+xml"/><item><title>多时钟解决雪花算法的时间回拨问题</title><link>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</link><pubDate>Sun, 27 Mar 2022 16:18:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/snowflake/multiple-clocks-snowflake/</guid><description>分布式 ID 生成算法用于在分布式系统中生成全局唯一的 ID 标识，而 twitter 提出的雪花算法便是其中一种知名的算法，其每次会生成一个 64 位的全局唯一整数，算法的基本思想非常巧妙：
0 1010......101 1010101010 101010101010 \_/ \___________/ \________/ \__________/ 第1位不使用 41位毫秒时间戳 10位机器ID 12位序列号 除了开头的第 1 位不使用，接下来的 41 位时间戳是从指定的起始时间到当前时间所经历的毫秒数，比如设定系统起始时间为 2022 年 3 月 15 日 0 点整，则在 2022 年 4 月 1 日中午 12:00:00.123 时，此时间戳的值应该为 1,512,000,123，整个时间戳片段，支持最多 69.7 年，这显然也超出了绝大多数 IT 系统的存活年限。
而 10 位机器 ID，对应最多容纳一个 1024 个 ID 生成器实例的分布式集群，12 位序列号从 0 到 4095 周而复始连续递增，可以支持单个实例每毫秒 4096 次 ID 生成请求，意味着整个 ID 生成器实例的集群，理论上每毫秒便可以支持最多 4194304 个 ID 生成，效率非常高。</description></item></channel></rss>