<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>处理异常 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/</link><description>Recent content in 处理异常 on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Wed, 05 Mar 2014 13:53:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/index.xml" rel="self" type="application/rss+xml"/><item><title>解读Rails - 处理异常</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</link><pubDate>Wed, 05 Mar 2014 13:53:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</guid><description>此文翻译自Reading Rails - Handling Exceptions，限于本人水平，翻译不当之处，敬请指教！
我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。
Rails通过让你使用rescue_from方法，让你在你的controller里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。
class ApplicationController # Redirect users if they try to use disabled features. rescue_from FeatureDisabledError, InsufficientAccessError do |ex| flash[:alert] = &amp;#34;Your account does not support #{ex.feature_name}&amp;#34; redirect_to &amp;#34;/pricing&amp;#34; end #... 我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。
如果需要跟着我的步骤走，请使用qwandry打开每一个相关的代码库，或者直接从github查看源码即可。
定义处理器(Handlers) ActiveSupport包含了一个用于定义异常如何被处理的模块Rescuable。第一个需要了解的方法就是rescue_from。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（提示：查看代码，请在命令行中输入qw activesupport）：
def rescue_from(*klasses, &amp;amp;block) options = klasses.extract_options! unless options.has_key?(:with) if block_given? options[:with] = block else #... 首先，*klasses接收数量不定的异常类，所以你可以进行类似rescue_from(FeatureDisabledError, InsufficientAccessError)这样的调用。它们将会被存放在一个数组里。
接下来，请留意extract_options!的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用:with项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。
接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。
def rescue_from(*klasses, &amp;amp;block) #... key = if klass.is_a?(Class) &amp;amp;&amp;amp; klass &amp;lt;= Exception klass.</description></item></channel></rss>