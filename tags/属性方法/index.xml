<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>属性方法 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</link><description>Recent content in 属性方法 on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Wed, 12 Mar 2014 20:58:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/index.xml" rel="self" type="application/rss+xml"/><item><title>属性方法</title><link>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</link><pubDate>Wed, 12 Mar 2014 20:58:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</guid><description>此文翻译自Reading Rails - Attribute Methods，限于本人水平，翻译不当之处，敬请指教！
在我们上一篇的探讨中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似attribute_method_suffix这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似name这样的模型属性以及对应生成的类似name_changed?这样的方法的。
如果需要跟着我的步骤走，请使用qwandry打开每一个相关的代码库，或者直接从github查看源码即可。
声明（Declarations） 属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，attribute_method_suffix后缀式方法是一个为每个属性都定义了一个helper方法的方法。在之前的讨论中，ActiveModel使用这种方式为您的每一个属性都定义了一个_changed?方法(提示： 命令行中键入qw activemodel查看代码)：
module Dirty extend ActiveSupport::Concern include ActiveModel::AttributeMethods included do attribute_method_suffix &amp;#39;_changed?&amp;#39;, &amp;#39;_change&amp;#39;, &amp;#39;_will_change!&amp;#39;, &amp;#39;_was&amp;#39; #... 让我们打开ActiveModel库中的attribute_methods.rb文件，并且看一下到底发生了什么事情。
def attribute_method_suffix(*suffixes) self.attribute_method_matchers += suffixes.map! do |suffix| AttributeMethodMatcher.new suffix: suffix end #... end 当你调用attribute_method_suffix方法的时候，每一个后缀都通过map!方法转换为一个AttributeMethodMatcher对象。这些对象会被存储在attribute_method_matchers中。如果你重新看一下这个module的顶部，你会发现attribute_method_matchers是在每一个包含此module的类中使用class_attribute定义的方法：
module AttributeMethods extend ActiveSupport::Concern included do class_attribute :attribute_aliases, :attribute_method_matchers, instance_writer: false #... class_attribute方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
class Person class_attribute :database #... end class Employee &amp;lt; Person end Person.database = Sql.new(:host=&amp;gt;&amp;#39;localhost&amp;#39;) Employee.database #=&amp;gt; &amp;lt;Sql:host=&amp;#39;localhost&amp;#39;&amp;gt; Ruby中并没有class_attribute的内置实现，它是在ActiveSupport(提示:命令行中键入qw activesupport查看代码)中定义的方法。如果你对此比较好奇，可以简单看下attribute.</description></item></channel></rss>