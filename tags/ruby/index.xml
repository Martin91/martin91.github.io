<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ruby on Hackerpie</title><link>https://blog.hackerpie.com/tags/ruby/</link><description>Recent content in Ruby on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 22 Sep 2019 19:48:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>谨防猴子补丁以及Python中排查技巧</title><link>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</link><pubDate>Sun, 22 Sep 2019 19:48:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/pay-attention-to-monkey-patch/</guid><description>背景 前两天晚上线上系统突发故障，在立马打开线上错误日志之后，却只能得到一堆毫无意义的程序调用栈(traceback)的输出，于是团队成员陷入漫长而又抓瞎的问题排查过程中。问题很幸运地得到了解决，但是我一直想不明白为什么日志里打印的调用栈毫无意义，按照经验，它应该打印的是异常产生过程中的调用栈才是。在经过后续的源码分析和排查之后，我才发现其实是因为项目中一个老旧的代码使用了猴子补丁导致，这也是这篇文章想要讨论的内容。
什么是猴子补丁 猴子补丁是一种用来在运行时修改（增加、变更、删除等）系统软件行为的编程方式。在动态语言里有广泛的猴子补丁应用的影子，比如 Ruby 的打开类的特性支持运行时扩展类的定义甚至替换方法的实现，Python 的方法或者函数由于可以在运行时进行替换而使得猴子补丁的应用非常方便，其他像 JavaScript 语言同样可以应用猴子补丁。
猴子补丁是把双刃剑 猴子补丁以其灵活性，可以实现补丁代码和应用代码的完全分离，同时使得应用代码在调用方式上保持调用方式始终不变。 从应用代码的角度来看，它调用的就是某个模块的原始定义的方法或者函数；而从被调用的方法或者函数的角度来看，猴子补丁的存在对它是透明的存在，以下展示一个 Python 语言的 Demo：
我们从一个极简例子开始，向这个美好的世界问好：
def greet(): print(&amp;#34;Hello World!&amp;#34;) if __name__ == &amp;#34;__main__&amp;#34;: greet() 假如执行以上脚本，得到的结果是：
$ python demo.py Hello World! 这个很简单，接下来假如打一个猴子补丁：我们扩充原来的 greet 的行为，现在除了打印信息，还要打印下当前的时间：
from datetime import datetime def greet(): print(&amp;#34;Hello World!&amp;#34;) # monkey patch original_greet = greet def greet_with_time(): original_greet() print(datetime.now()) greet = greet_with_time # replace the implementation # monkey patch if __name__ == &amp;#34;__main__&amp;#34;: greet() # 这里的调用和原来没有变化 运行它，得到的结果是：</description></item><item><title>Mac OS 环境 Rails 6.0 下 webpack-dev-server wrong version 问题解决方案</title><link>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</link><pubDate>Fri, 06 Sep 2019 15:18:30 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/fix-webpack-dev-server-wrong-version-in-rails-6/</guid><description>错误信息 昨天装上了 Ruby on Rails 6.0，满心欢喜初始化项目并且按照指引安装了 webpacker 之后，执行熟悉无比的 rails c 命令，却给了一个报错：
# 错误信息片段 yarn check v1.7.0 success Folder in sync. Done in 0.15s. yarn check v1.7.0 error &amp;#34;webpack-dev-server#yargs#cliui&amp;#34; is wrong version: expected &amp;#34;^4.0.0&amp;#34;, got &amp;#34;5.0.0&amp;#34; error &amp;#34;webpack-dev-server#yargs#yargs-parser&amp;#34; is wrong version: expected &amp;#34;^11.1.1&amp;#34;, got &amp;#34;13.1.1&amp;#34; error Found 2 errors. info Visit https://yarnpkg.com/en/docs/cli/check for documentation about this command. 解决方案 目前关于 Rails 6.0 相关的资料感觉不多，所幸找到了一篇日文版的帖子，成功解决了上边的问题：
$ brew upgrade yarn $ yarn upgrade 最终问题解决，又能愉快地前进了！
**注意：**我自己已经一年多没怎么开发 Rails 项目了，全栈开发那就更久远了。Rails 6.</description></item><item><title>不严谨的不同语言下大 Excel 文件写入的性能比较</title><link>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</link><pubDate>Sat, 23 Mar 2019 21:11:06 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2019/general-excel-writor-benchmark-comparation-among-different-languages/</guid><description>背景 去年因为线上系统需要导出大量数据（大概是 11 万行）到 Excel，代码是 Python 2.7 写的，除去数据库查询耗时，整个的 Excel 文件生成也还要耗费几十秒的时间，这听起来真是一个非常夸张的事情。后来为其更换了号称性能表现最好的 pyexcelerate 库，性能确实有提升，但是仍是差强人意的在小几十秒。
昨天突发奇想，如果是换成其他语言，这个 excel 导出是否还需要这么长时间？于是经过一番试验之后，就有了今天的这篇文章。
**特别声明：**试验只是为了感官上做个简单对比，测试结果采集数据只考虑了耗时，没有考虑资源消耗等情况，需要严谨的性能对比的读者，可以放弃阅读了。
测试内容 使用不同的语言及其版本，测试各自完成包含 100,000 行 x 50 列单元格的 excel 文件的生成，对比其各自耗费时间，3次重复执行取其平均值后进行横向比较。
已经测试的语言及版本 Ruby 2.6 + axlsx 2.0.1 Python 2.7 + pyexcelerate 0.7.3 Python 3.6 + pyexcelerate 0.7.3 Go 1.10.1 + gooxml 0.8 测试代码 https://github.com/Martin91/excel-writors-benchmark
结果 结论 就这个测试场景来说：
Go 1.10.1 + gooxml 0.8 是最快的； 同样是 pyexcelerate 0.7.3，Python 2.7 性能优于 Python 3.6; Ruby 2.6 + axlsx 2.0.1 表现最不给力，这里有个题外话，选择的 axlsx 本身并不是性能最好的 gem，只是流行度够高，Ruby 有一个专门针对性能优化后的 gem，但是因为知之甚少，没有采用。</description></item><item><title>Ruby中Hash的7个日常使用范例</title><link>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</link><pubDate>Tue, 25 Mar 2014 20:05:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/rubyzhong-hashde-7ge-ri-chang-shi-yong-fan-li/</guid><description>此文翻译自7 daily use cases of Ruby Hash，限于本人水平，翻译不当之处，敬请指教！
每一天，你都需要跟Hash相处。创建一个新的Hash或者是通过它的某一个键去检索其中的元素这样的工作，都是常见也是非常简单的。但是当你需要合并两个嵌套的Hash或者是从某一个Hash里边过滤某些键，你可能需要考虑得多一点。通过完整的文档，你可以找到对Hash中的每一个方法的充分解释。但是由于文档不是面向应用场景的，你可能没法很快找到你的解决方案。在下面，我分享了我日常中经常遇到的Hash中的7个常用场景，希望它们对你有用。
1. 如何将一个JSON转换为一个Hash？ 假设你刚刚接收到一个用JSON表示的Twitter账号的资料信息：
data = &amp;#39;{ &amp;#34;name&amp;#34;: &amp;#34;Aaron Patterson&amp;#34;, &amp;#34;screen_name&amp;#34;: &amp;#34;tenderlove&amp;#34;, &amp;#34;location&amp;#34;: &amp;#34;Seattle, WA&amp;#34; }&amp;#39; 你希望能够将它转化为一个Hash,这样会更方便你进行对数据的操作：
require &amp;#39;json&amp;#39; profile = JSON.parse(data) ** 在IRB中的输出结果：**
=&amp;gt; { &amp;#34;name&amp;#34;=&amp;gt;&amp;#34;Aaron Patterson&amp;#34;, &amp;#34;screen_name&amp;#34;=&amp;gt;&amp;#34;tenderlove&amp;#34;, &amp;#34;location&amp;#34;=&amp;gt;&amp;#34;Seattle, WA&amp;#34; } 查看文档：JSON#parse
2. 如何将一个Hash转换为一个JSON？ 在你的web应用程序中，你需要追踪当前星期每一天新注册用户的数量：
signups_of_the_week = { monday: 2, tuesday: 3, wednesday: 4, thursday: 20, friday: 5, saturday: 2, sunday: 5 } 你可以通过API的方式把它们以JSON格式提供给客户端：
require &amp;#39;json&amp;#39; signups_of_the_week.to_json ** 在IRB中的输出结果：**
=&amp;gt; &amp;#34;{\&amp;#34;monday\&amp;#34;:2,\&amp;#34;tuesday\&amp;#34;:3,\&amp;#34;wednesday\&amp;#34;:4,\&amp;#34;thursday\&amp;#34;:20,\&amp;#34;friday\&amp;#34;:5,\&amp;#34;saturday\&amp;#34;:2,\&amp;#34;sunday\&amp;#34;:5}&amp;#34; 查看文档：JSON#generate 边注：JSON#pretty_generate对于更好的打印以及调试非常有用。</description></item><item><title>属性方法</title><link>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</link><pubDate>Wed, 12 Mar 2014 20:58:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/shu-xing-fang-fa/</guid><description>此文翻译自Reading Rails - Attribute Methods，限于本人水平，翻译不当之处，敬请指教！
在我们上一篇的探讨中，我们已经看到了Rails在跟踪属性变更中使用到的属性方法（attribute methods）。有三种类型的属性方法：前缀式（prefix）、后缀式（suffix）以及固定词缀式（ affix）。为了表述简洁，我们将只关注类似attribute_method_suffix这样的后缀式属性方法，并且特别关注它是如何帮助我们实现类似name这样的模型属性以及对应生成的类似name_changed?这样的方法的。
如果需要跟着我的步骤走，请使用qwandry打开每一个相关的代码库，或者直接从github查看源码即可。
声明（Declarations） 属性方法是Rails中众多使用了元编程技术的案例之一。在元编程中，我们编写可以编写代码的代码。举例来说，attribute_method_suffix后缀式方法是一个为每个属性都定义了一个helper方法的方法。在之前的讨论中，ActiveModel使用这种方式为您的每一个属性都定义了一个_changed?方法(提示： 命令行中键入qw activemodel查看代码)：
module Dirty extend ActiveSupport::Concern include ActiveModel::AttributeMethods included do attribute_method_suffix &amp;#39;_changed?&amp;#39;, &amp;#39;_change&amp;#39;, &amp;#39;_will_change!&amp;#39;, &amp;#39;_was&amp;#39; #... 让我们打开ActiveModel库中的attribute_methods.rb文件，并且看一下到底发生了什么事情。
def attribute_method_suffix(*suffixes) self.attribute_method_matchers += suffixes.map! do |suffix| AttributeMethodMatcher.new suffix: suffix end #... end 当你调用attribute_method_suffix方法的时候，每一个后缀都通过map!方法转换为一个AttributeMethodMatcher对象。这些对象会被存储在attribute_method_matchers中。如果你重新看一下这个module的顶部，你会发现attribute_method_matchers是在每一个包含此module的类中使用class_attribute定义的方法：
module AttributeMethods extend ActiveSupport::Concern included do class_attribute :attribute_aliases, :attribute_method_matchers, instance_writer: false #... class_attribute方法帮助你在类上定义属性。你可以这样在你自己的代码中这样使用：
class Person class_attribute :database #... end class Employee &amp;lt; Person end Person.database = Sql.new(:host=&amp;gt;&amp;#39;localhost&amp;#39;) Employee.database #=&amp;gt; &amp;lt;Sql:host=&amp;#39;localhost&amp;#39;&amp;gt; Ruby中并没有class_attribute的内置实现，它是在ActiveSupport(提示:命令行中键入qw activesupport查看代码)中定义的方法。如果你对此比较好奇，可以简单看下attribute.</description></item><item><title>跟踪model中属性（值）的变更</title><link>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</link><pubDate>Fri, 07 Mar 2014 13:02:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zhui-zong-bian-geng/</guid><description>此文翻译自Reading Rails - Change Tracking，限于本人水平，翻译不当之处，敬请指教！
我们今天来看看Rails是如何追踪model里边属性的变更的。
person = Person.find(8) person.name = &amp;#34;Mortimer&amp;#34; person.name_changed? #=&amp;gt; true person.name_was #=&amp;gt; &amp;#34;Horton&amp;#34; person.changes #=&amp;gt; {&amp;#34;name&amp;#34;=&amp;gt;[&amp;#34;Horton&amp;#34;,&amp;#34;Mortimer&amp;#34;]} person.save! person.changes #=&amp;gt; {} name_changed?方法是从哪来的呢？变更又是如何被创建的？让我们顺着这个场景，看看这一切背后的秘密。
如果需要跟着我的步骤走，请使用qwandry打开每一个相关的代码库，或者直接从github查看源码即可。
ActiveModel 当你想探寻ActiveRecord里边的功能时，你应该首先了解ActiveModel。ActiveModel（提示： 命令行中键入qw activemodel查看代码）定义了没有与数据库捆绑的逻辑。我们将从dirty.rb文件开始。在这个模块最开始的地方，代码调用了attribute_method_suffix：
module Dirty extend ActiveSupport::Concern include ActiveModel::AttributeMethods included do attribute_method_suffix &amp;#39;_changed?&amp;#39;, &amp;#39;_change&amp;#39;, &amp;#39;_will_change!&amp;#39;, &amp;#39;_was&amp;#39; #... attribute_method_suffix定义了定制的属性读写器。这主要用来告诉Rails将一些带有类似_changed?后缀的调用分发到特定的处理器方法上。为了看看它们是如何实现的，请向下滚动代码，并且找到def attribute_changed?：
def attribute_changed?(attr) changed_attributes.include?(attr) end 我们将会在另外的一篇文章中再着重介绍如何连接这些方法的细节，当你调用一个类似name_changed?的方法时，Rails将会把&amp;quot;name&amp;quot;作为参数attr传给上述方法。往回看一点点，你会发现changed_attributes只是一个包含了从属性名到旧的属性值的映射的Hash而已：
# Returns a hash of the attributes with unsaved changes indicating their original # values like &amp;lt;tt&amp;gt;attr =&amp;gt; original value&amp;lt;/tt&amp;gt;.</description></item><item><title>解读Rails - 处理异常</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</link><pubDate>Wed, 05 Mar 2014 13:53:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-chu-li-yi-chang/</guid><description>此文翻译自Reading Rails - Handling Exceptions，限于本人水平，翻译不当之处，敬请指教！
我们今天开始会读一些Rails的源码。我们有双重的目的，先通过学习（Rails）如何处理异常，再扩展到整个Ruby中基础知识的学习。
Rails通过让你使用rescue_from方法，让你在你的controller里边为常见的异常定义处理方法。举例来说吧，你可以在用户试图访问他们尚未付费的功能时将他们重定向到指定的付费页面。
class ApplicationController # Redirect users if they try to use disabled features. rescue_from FeatureDisabledError, InsufficientAccessError do |ex| flash[:alert] = &amp;#34;Your account does not support #{ex.feature_name}&amp;#34; redirect_to &amp;#34;/pricing&amp;#34; end #... 我们将会探索Rails是如何定义异常处理器，如何将它们与具体的异常进行匹配，以及如何使用它们去rescue失败的action。
如果需要跟着我的步骤走，请使用qwandry打开每一个相关的代码库，或者直接从github查看源码即可。
定义处理器(Handlers) ActiveSupport包含了一个用于定义异常如何被处理的模块Rescuable。第一个需要了解的方法就是rescue_from。这个方法通过方法名或者代码块为你想rescue的异常注册处理器（提示：查看代码，请在命令行中输入qw activesupport）：
def rescue_from(*klasses, &amp;amp;block) options = klasses.extract_options! unless options.has_key?(:with) if block_given? options[:with] = block else #... 首先，*klasses接收数量不定的异常类，所以你可以进行类似rescue_from(FeatureDisabledError, InsufficientAccessError)这样的调用。它们将会被存放在一个数组里。
接下来，请留意extract_options!的使用。这是一个常见的用于从一个数组生成一个options哈希表的技巧。假如klasses里边的最后一个元素是一个哈希表，那么这个元素会被弹出数组。现在Rails将会使用:with项所指定的方法，或者是使用传递给rescue_from的代码块。Rails中的这种技巧创造了一个灵活的接口。
接着继续往下看这个方法，我们看到每一个异常类都被转换成一个String对象，我们待会便会看到为什么要这么做。
def rescue_from(*klasses, &amp;amp;block) #... key = if klass.is_a?(Class) &amp;amp;&amp;amp; klass &amp;lt;= Exception klass.</description></item><item><title>解读Rails - 适配器模式</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</link><pubDate>Mon, 03 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</guid><description>本文翻译自Reading Rails - The Adapter Pattern，限于本人水平有限，翻译不当之处，敬请指教！
今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是适配器模式（Adapter Pattern）。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。
为了跟随本文的步骤，请使用qwandry打开相关的代码库，或者直接在Github上查看这些代码。
适配器模式 适配器模式可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。
当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：
def find_nearest_restaurant(locator) locator.nearest(:restaurant, self.lat, self.lon) end 我们假设有一个针对locator的接口，但是如果我们想要find_nearest_restaurant能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：
def find_nearest_restaurant(locator) if locator.is_a? GeoFish locator.nearest(:restaurant, self.lat, self.lon) elsif locator.is_a? ActsAsFound locator.find_food(:lat =&amp;gt; self.lat, :lon =&amp;gt; self.lon) else raise NotImplementedError, &amp;#34;#{locator.class.name} is not supported.&amp;#34; end end 这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许find_nearest_restaurant就是我们使用locator的唯一场景。
那假如你真的需要去支持一个新的locator，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现find_nearest_hospital方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。
在这个例子中，我们可以为GeoFish以及ActsAsFound编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：
def find_nearest_hospital(locator) locator.find :type =&amp;gt; :hospital, :lat =&amp;gt; self.lat, :lon =&amp;gt; self.lon end locator = GeoFishAdapter.new(geo_fish_locator) find_nearest_hospital(locator) 特意假设的例子就到此为止，接下来让我们看看真实的代码。
MultiJSON ActiveSupport在做JSON格式的解码时，用到的是MultiJSON，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对oj和yajl的适配器。 (提示: 可在命令行中输入qw multi_json查看源码。)</description></item><item><title>在Ruby中使用WebSocket</title><link>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</link><pubDate>Sat, 01 Mar 2014 21:31:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/zai-rubyzhong-shi-yong-websocket/</guid><description>声明: 此文翻译自WebSockets in Ruby， 限于本人才疏学浅，其中有翻译不当之处，敬请指出，感激不尽！
在我的主要工作中，需要构建一个一直占用相当大CPU时间片的数据系统。这个任务主要用于在地理编码以及local reference system(本地地理系统？)之间进行编码以及解码。举个例子，这个工作将帮助我们在系统中标记一条对应于街道上某个地点的记录，并且可以知道本地地理位置所对应的坐标。
在第一次的尝试中，我开发了一个用于地理编码的Ruby库以及一个简单的基于Sinatra的web服务。当时我的解决方案表现得还不错，直到后来客户要求对每一个鼠标滑过的事件进行交互。这个需求上的更改让我不得不再一次通过Javascript语言去构建一个同样用于地理编码的基础构件，在之后的一段时间里，一切也都表现得非常好。
而意料之中的是，我们再一次决定在系统中允许每个用户与多个街道关联。现在，每次下载800KB的数据（存储在索引数据库中，用于记录最新的会话信息）尚且可以承受；但是潜在上来说，几个MB的数据将是致命的，甚至软件也有可能在会话的响应之前被使用-而这只是用户所期待的功能之一。
我知道我们必须寻找一个完美的解决方案，并且使一切都是可以管理控制的。在以前，我涉足过WebSocket领域（比如node.js以及Socket.IO）并且知道相关的底层知识。从之前的搜索中，我意识到Ruby在这方面的欠缺，我很快又考虑通过在节点上的Javascript端口来实现需求。这样的想法使我非常激动。
可选方案 第一步是找出可用的方案。以下列举我找到的：
sinatra-websocket faye-websocket websocket-rails tubesock webmachine-ruby 在上述五种方案中，前三种方案都是基于事件机制的，而tubesock使用了rake hijacking技术，webmachine-ruby通过基于Celluloid::IO的HTTP服务器Reel提供WebSockets。
首先，考虑到我已经使用了Sinatra，于是我试用了sinatra-websocket。但是因为部分原因，我无法将连接方式迁移到WebSocket，所以我决定快速跳过。而且坦白说的话，我还直接跳过了faye-websocket。
接下来的两个备选方案遇到了同样的问题：在一个配置较低的Heroku的站点上启动Rails并且加载了整个系统之后，剩下的内存只够几十个客户端同时使用的了。除此之外，Rails的启动时间加上其他用于构建的时间偶尔会让Heroku认为系统中出现异常，结果导致进程在服务正常启动之前就已经被强行退出了。
假如你有所留意，那么你也就知道了，剩下的唯一一个方案，就是webmachine-ruby。
webmachine-ruby 配置webmachine-ruby的环境还是相对容易的。为了逐步进行，我首先把原来基于HTTP的服务迁移到它的资源结构。比起Rails以及Sinatra，它更加具有面向对象的味道。它的分发器是易于理解的，我非常喜欢通过visual debugger来摆玩这一切。
迁移到WebSocket上后，一切都变了。我能建议的（包括文档中说明的）就是，你完全可以跳过常规的基础配置，转而提供一个可调用的配置项，比如：
App = Webmachine::Application do |app| app.configure do |config| config.adapter = :Reel config.adapter_options[:websocket_handler] = proc do |websocket| websocket &amp;lt;&amp;lt; &amp;#34;hello, world&amp;#34; end end end 这是相当多的文档所提到的方法。因为它只期望handler支持#call方法，所以你可以写一个你自己的ad-hoc分发器：
class WebsocketHandler def call(websocket) message = websocket.read # do something with the message, call methods on other objects, log stuff, have your fun end end 很多文档并不提及一些套接字编程的基础。假如你发现你的handler被挂起并且不再处理响应，这意味着你需要重新修改程序，但是不需要为此感到烦恼：你只需要实现一个不断从套接字中读取信息并且让Celluloid::IO实现它的非阻塞魔术方法的循环就行了：</description></item><item><title>export/import datas to/from a csv file</title><link>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</link><pubDate>Thu, 25 Jul 2013 22:19:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/export-slash-import-to-slash-from-a-csv-file/</guid><description>今天需要给客户的网站做支持产品数据导出并且更新的功能，所以就涉及到了数据的导入导出了。在经过一番对比之下，果断使用csv格式文件作为数据导入导出的载体。
导出csv文件 与csv文件主要相关的类是CSV,此类在ruby的标准库中被定义，所以只要在代码开头引入相关文件即可:
require &amp;#39;csv&amp;#39; 接着需要创建csv文件，并在其中写入数据:
CSV.open &amp;#34;path/to/csv/file&amp;#34;, &amp;#34;wb&amp;#34;, :col_sep =&amp;gt; &amp;#39;|&amp;#39; do |csv| csv &amp;lt;&amp;lt; [&amp;#34;one&amp;#34;, &amp;#34;row&amp;#34;, &amp;#34;of&amp;#34;, &amp;#34;contents&amp;#34;] end ** 这里有几个细节值得一提：**
open方法是用于对CSV文件进行写操作的主要接口,对CSV文件进行写操作都应该使用此方法; &amp;lt;&amp;lt; 操作符支持将字符串数组写入到csv文件,一个数组为一行，数组中的一个字符串为一个单元(field); open方法的第三个参数是一个哈希，用于为打开的文件指定初始化赋值，具体可用的option以及其值可参考new方法的说明:http://www.ruby-doc.org/stdlib-1.9.3/libdoc/csv/rdoc/CSV.html#method-c-new :col_sep用于指定文件中每一行中的每个单元之间的分隔符，当通过字符串数组想文件中添加新行的时候，CSV将会在数组元素也就是每一行的单元之间插入指定的分隔符，分隔符需要尽量避开已经在待导出数据中存在的字符，以免后续导入的时候发生歧义。 导入csv文件 导入csv除了需要用到相关的类CSV，还可能用到的类是CSV::Row，前者提供打开文件以及将文件按行分隔的方法foreach，foreach将分隔后的行逐行分配到CSV::Row的实例中，通过调用CSV::Row的实例方法field可对每个单元进行读取。 假设我有这样一个csv文件：
id | value 1234 | hello 2345 | world 则相关的代码如下：
CSV.foreach(&amp;#39;path/to/file&amp;#39;), :col_sep =&amp;gt; &amp;#39;|&amp;#39;, :headers =&amp;gt; :first_row do |row| # use datas of each row id = row.field &amp;#39;id&amp;#39; value = row.field &amp;#39;value&amp;#39; end ** 同样这里也有几个细节需要注意:**
foreach是CSV类中用于读取文件的标准方法； 通过指定:col_sep =&amp;gt; '|'可使CSV按照指定的分隔符分隔好文件内容，方便后面field方法的调用； 指定:headers =&amp;gt; :first_row可使CSV将第一行视为文件的headers，并且结合:col_sep的设定可以将headers进行分割，这两个是field方法的基础。 Related links: http://www.</description></item></channel></rss>