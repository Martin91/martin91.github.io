<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>依赖倒置 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/</link><description>Recent content in 依赖倒置 on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sun, 06 Mar 2022 17:40:19 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 编写易于单元测试的代码</title><link>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</link><pubDate>Sun, 06 Mar 2022 17:40:19 +0800</pubDate><guid>https://blog.hackerpie.com/posts/testing/golang-write-testable-codes/</guid><description>聊聊单测这个事 单元测试一直是大家老生长谈的话题之一，尽管各种测试方法论和测试工具集层层出不穷，但是实际上，在我所工作过的公司中，还没有见过能把单测坚持好的团队。单测的概念不复杂，单测的重要性大家也都是认同的，但是是什么造成单测没有执行下来呢？我觉得主要是两类原因吧：
开发工期太赶：时间只够写功能性代码，测试代码只能舍弃，系统功能依赖不可重复的人力操作 项目设计问题：项目代码结构设计不良，导致单测代码难以编写，或者运行需要过多复杂的依赖，加上项目已存在大量代码，不敢重构 第一个原因见仁见智，也不是我想聊的重点。我最近更多的实践和感悟是，如果一个项目从一开始就没有考虑好单测的需要，等到后期就几乎难以改造成易于单元测试执行的结构了。而另一方面，我也是最近才对单测这个事情有一种顿悟的感觉。所以，下面也是想通过一个小 demo 项目，来总结如何设计在 golang 里编写易于单测展开的代码。
项目设计问题导致的单测难以展开，一般都是因为代码组件之间形成了静态的依赖关系，比如对数据库的依赖，对外部服务的依赖，等等。这些依赖，可能是直接的，也可能是依赖的依赖，也就是间接的。而按照单测的定义，一个足够小的代码单元的测试，应该只关注这个单元的输入和输出即可，外加足以驱动单测执行的最小依赖集合，而不应该担心除此之外的其他一切东西。实际项目中，我们也会将代码进行分层设计，按照职责划分不同的代码模块，但是由于依赖管理的设计意识不足，常会发现模块之间形成了静态的依赖关系，导致编写单测时，不得不去关注各种间接的依赖，这就好比一个芯片在生产阶段就已经焊死在了主板之上，以至于如果我们需要对芯片的功能进行验证的话，就只能将整个主板制作完整之后，才能通过启动主板来检查芯片的功能，想想这有多离谱。
说明 出于演示目的，我编写了一个逻辑上不严谨的小示例项目，代码托管在 HackerPie/go-microblog。demo 实现了两个用于管理指定用户微博的 Restful API，按照后续讨论章节的内容，这份代码相应地通过多个 git tag 来识别对应的代码版本，分别为v1、v2、v3和v4。
概述 尽管只是一个小 demo，我还是希望提前说明下这个 demo 的分层设计。demo 核心逻辑存放在 internal 目录里，因为只是 demo，所以只划分了 service、repo 以及 model 三层：
demo 应用分层 各层说明：
service: 该层代码负责请求的处理与响应，同时负责核心业务逻辑，一般真实项目里，我会进一步分开服务处理和核心业务逻辑层，但是作为示例项目，就简化了； adapter: adapter 主要定义各类 dto 对象和数据库模型对象之间的转换适配，我认为这仍旧属于 service 层的逻辑，但是在实际代码中，我会独立一个目录来管理； repo: 该层代码负责单一数据模型的持久化操作，即数据的 CURD； model: 该层定义各类数据结构，按照使用场景不同，进一步划分 dto 和 db dto: 数据传输对象，用于定义一些需要返回给客户端或者从客户端请求反序列化的数据结构； db: 数据库模型定义，用于描述数据库表的结构，此层不负责任何数据读写操作。 各层代码在项目代码结构中的管理如图： internal 代码结构组织 v1: 依赖具体实现的版本 v1 版本 代码中，是一个经典的代码分层之间直接依赖具体实现的例子：
// cmd/api_server.go r := gin.Default() r.GET(&amp;#34;/users/:user_id/blogs&amp;#34;, service.</description></item><item><title>依赖倒置原则</title><link>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</link><pubDate>Wed, 07 Jul 2021 21:22:20 +0800</pubDate><guid>https://blog.hackerpie.com/posts/2021/dependency-inversion-principle-introduce/</guid><description>说起依赖倒置原则，已经不是个新鲜的词了，虽然也知道依赖倒置原则的具体设计模式，但是一直觉得难以理解何为“倒置”，直到今晚重新静心阅读了 Wikipedia 才恍然大悟！欣喜之余，赶紧写篇文章总结。
传统软件分层设计模式 在软件设计开发的时候，我们都会自然而然思考系统的分层设计，比如以一个典型的三层架构来举例：
--------------- 服务层 （提供 API 服务） --------------- ↓ --------------- 业务逻辑层 （封装具体的业务逻辑） --------------- ↓ --------------- 存储层 （处理数据存取） --------------- 依照此架构设计，我们可能自然而然地将各层代码实现直接封装在三个不同的代码包，其中 package.service 直接依赖 package.business，而 package.business 则直接依赖 package.repository。因此形成以下链式依赖链：
package.service ---&amp;gt; package.business ---&amp;gt; package.repository 这种分层代码设计风格直接耦合了依赖双方的实现，假如被依赖的包需要修改代码逻辑，则很可能导致依赖它的上层代码需要相应修改，极端场景下，这种耦合带来的变动影响可能扩散到整个依赖链。
其次，由于上层代码依赖了下层代码的具体实现，导致了上层代码的可复用性降低。举个具体例子，我们有一个运行了很久的系统，出于技术考量，我们需要将其存储层从 MySQL 移植到 MongoDB 上，而整个系统的核心业务逻辑并不需要也不应该有任何改变，如果是采用上述这种分层架构，则会导致我们除了替换存储层代码实现，还要相应修改业务逻辑层的代码，这就是我说的直接依赖实现会降低依赖一方的可复用性降低。
依赖倒置原则 先照本宣科讲下依赖倒置原则的含义：
高层级的模块不应该依赖低层级的模块。它们都应该依赖抽象（比如，接口）
抽象不应该依赖实现细节。实现细节（具体的实现）应该依赖抽象
有点抽象，有点拗口，有点无情，有点无理取闹对不对？
还是尝试用大白话解释一下：
高层级的模块应该依赖的是低层级的模块的行为的抽象，取决于具体编程语言，可以是抽象类或者接口等技术； 第2句话其实很简单，只有一个意思：只要依赖了实现，就是耦合了代码，所以我们需要始终依赖的是抽象，而不是实现。 将上面举的例子按照依赖倒置原则设计，就是这样子了：
package.service ---&amp;gt; package.business.interface ↑ ↑ 实现 ↑ package.business ---&amp;gt; package.repository.interface ↑ ↑ 实现 ↑ package.repository 以上面的模式来说，package.service 不再直接依赖于 package.business，而是依赖了 package.business.interface 接口，也就是 package.business 的抽象。</description></item></channel></rss>