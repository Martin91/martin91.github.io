<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>设计模式 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link><description>Recent content in 设计模式 on Hackerpie</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Mon, 03 Mar 2014 13:40:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml"/><item><title>解读Rails - 适配器模式</title><link>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</link><pubDate>Mon, 03 Mar 2014 13:40:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/archive/jie-du-rails-gua-pei-qi-mo-shi/</guid><description>本文翻译自Reading Rails - The Adapter Pattern，限于本人水平有限，翻译不当之处，敬请指教！
今天我们暂时先放下具体的代码片段，我们将要对Rails中所实现的一个比较常见的设计模式进行一番探索，这个模式就是适配器模式（Adapter Pattern）。从一定的意义上来说，这次的探索并不全面，但是我希望能够突出一些实际的例子。
为了跟随本文的步骤，请使用qwandry打开相关的代码库，或者直接在Github上查看这些代码。
适配器模式 适配器模式可以用于对不同的接口进行包装以及提供统一的接口，或者是让某一个对象看起来像是另一个类型的对象。在静态类型的编程语言里，我们经常使用它去满足类型系统的特点，但是在类似Ruby这样的弱类型编程语言里，我们并不需要这么做。尽管如此，它对于我们来说还是有很多意义的。
当使用第三方类或者库的时候，我们经常从这个例子开始（start out fine）：
def find_nearest_restaurant(locator) locator.nearest(:restaurant, self.lat, self.lon) end 我们假设有一个针对locator的接口，但是如果我们想要find_nearest_restaurant能够支持另一个库呢？这个时候我们可能就会去尝试添加新的特殊的场景的处理：
def find_nearest_restaurant(locator) if locator.is_a? GeoFish locator.nearest(:restaurant, self.lat, self.lon) elsif locator.is_a? ActsAsFound locator.find_food(:lat =&amp;gt; self.lat, :lon =&amp;gt; self.lon) else raise NotImplementedError, &amp;#34;#{locator.class.name} is not supported.&amp;#34; end end 这是一个比较务实的解决方案。或许我们也不再需要考虑去支持另一个库了。也或许find_nearest_restaurant就是我们使用locator的唯一场景。
那假如你真的需要去支持一个新的locator，那又会是怎么样的呢？那就是你有三个特定的场景。再假如你需要实现find_nearest_hospital方法呢？这样你就需要在维护这三种特定的场景时去兼顾两个不同的地方。当你觉得这种解决方案不再可行的时候，你就需要考虑适配器模式了。
在这个例子中，我们可以为GeoFish以及ActsAsFound编写适配器，这样的话，在我们的其他代码中，我们就不需要了解我们当前正在使用的是哪个库了：
def find_nearest_hospital(locator) locator.find :type =&amp;gt; :hospital, :lat =&amp;gt; self.lat, :lon =&amp;gt; self.lon end locator = GeoFishAdapter.new(geo_fish_locator) find_nearest_hospital(locator) 特意假设的例子就到此为止，接下来让我们看看真实的代码。
MultiJSON ActiveSupport在做JSON格式的解码时，用到的是MultiJSON，这是一个针对JSON库的适配器。每一个库都能够解析JSON，但是做法却不尽相同。让我们分别看看针对oj和yajl的适配器。 (提示: 可在命令行中输入qw multi_json查看源码。)</description></item></channel></rss>