<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>最优解 on Hackerpie</title><link>https://blog.hackerpie.com/tags/%E6%9C%80%E4%BC%98%E8%A7%A3/</link><description>Recent content in 最优解 on Hackerpie</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><lastBuildDate>Sat, 14 Jan 2023 09:13:00 +0800</lastBuildDate><atom:link href="https://blog.hackerpie.com/tags/%E6%9C%80%E4%BC%98%E8%A7%A3/index.xml" rel="self" type="application/rss+xml"/><item><title>贪心算法：LeetCode 409 最长回文串双 100 题解</title><link>https://blog.hackerpie.com/posts/algorithms/greedy/longest-palindrome/</link><pubDate>Sat, 14 Jan 2023 09:13:00 +0800</pubDate><guid>https://blog.hackerpie.com/posts/algorithms/greedy/longest-palindrome/</guid><description>这篇文章分享如何借助位的思想将 LeetCode 409——最长回文串的题解优化到双 100。
题目 题目本身是 easy 级别的，原题目是：
给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。 在构造过程中，请注意 区分大小写 。比如 &amp;#34;Aa&amp;#34; 不能当做一个回文字符串。 思路分析 基本的思路是遍历字符串中的所有字符，并且统计每个字符出现的次数，最后求和 length：
如果字符出现次数为偶数，则将结果 length 直接加 2； 如果字符出现次数为奇数，则进一步判断： 如果 length 未曾加过奇数，则将结果 length 直接加上这个奇数； 如果 length 已经加过奇数，则将结果 length 直接加上这个奇数-1。 这个思路的基本原则是所有出现次数为偶数的字符可以刚好位于回文中心的两侧，而最多只能有一个长度为奇数的回文中心，超过的子串就只能舍弃掉一个字符使其变成偶数长度。
对应代码 func longestPalindrome(s string) int { stats := map[rune]int{} for _, b := range s { if _, found := stats[b]; !found { stats[b] = 0 } stats[b]++ } length := 0 hasOdd := false for _, count := range stats { if count % 2 == 0 { length += count continue } if !</description></item></channel></rss>